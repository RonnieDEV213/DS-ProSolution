---
phase: 18-client-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/package.json
  - apps/web/src/lib/db/index.ts
  - apps/web/src/lib/db/schema.ts
  - apps/web/src/lib/db/init.ts
  - apps/web/src/lib/api.ts
  - apps/web/src/components/providers/database-provider.tsx
  - apps/web/src/app/layout.tsx
autonomous: true

must_haves:
  truths:
    - "IndexedDB database DSProSolution is accessible via browser devtools"
    - "Database has tables: accounts, records, sellers, _sync_meta"
    - "App initializes database on startup without errors"
    - "Sync API methods are available in api module"
  artifacts:
    - path: "apps/web/src/lib/db/index.ts"
      provides: "Dexie database singleton export"
      exports: ["db"]
    - path: "apps/web/src/lib/db/schema.ts"
      provides: "TypeScript interfaces for IndexedDB tables"
      exports: ["AccountRecord", "BookkeepingRecord", "SellerRecord", "SyncMeta"]
    - path: "apps/web/src/lib/db/init.ts"
      provides: "Database initialization with version check"
      exports: ["initializeDatabase"]
    - path: "apps/web/src/components/providers/database-provider.tsx"
      provides: "React provider for database initialization"
      exports: ["DatabaseProvider"]
    - path: "apps/web/src/lib/api.ts"
      provides: "Sync API methods"
      contains: "syncRecords"
  key_links:
    - from: "apps/web/src/app/layout.tsx"
      to: "apps/web/src/components/providers/database-provider.tsx"
      via: "JSX wrapper"
      pattern: "<DatabaseProvider>"
    - from: "apps/web/src/lib/db/index.ts"
      to: "apps/web/src/lib/db/schema.ts"
      via: "import"
      pattern: "from.*schema"
---

<objective>
Set up IndexedDB persistence layer with Dexie.js.

Purpose: Establish the local storage foundation for cache-first data access. This enables instant loads from IndexedDB before syncing with server.

Output: Dexie database singleton with typed schema, initialization provider, and sync API client methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-client-persistence/18-CONTEXT.md
@.planning/phases/18-client-persistence/18-RESEARCH.md

# Existing code to modify
@apps/web/src/lib/api.ts
@apps/web/src/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Dexie.js and dependencies</name>
  <files>apps/web/package.json</files>
  <action>
Install the required packages for IndexedDB persistence:

```bash
cd apps/web && npm install dexie dexie-react-hooks react-intersection-observer
```

Packages:
- dexie@4.2.1 - IndexedDB wrapper with TypeScript support
- dexie-react-hooks@4.2.0 - React hooks including useLiveQuery
- react-intersection-observer@9.x - Scroll position detection for prefetch

Note: dexie-react-hooks v1.1.3+ is required for Next.js App Router compatibility.
  </action>
  <verify>
`npm ls dexie dexie-react-hooks react-intersection-observer` shows all three packages installed
  </verify>
  <done>
All three dependencies appear in package.json dependencies and are installed in node_modules
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Dexie database singleton with typed schema</name>
  <files>
    apps/web/src/lib/db/schema.ts
    apps/web/src/lib/db/index.ts
    apps/web/src/lib/db/init.ts
  </files>
  <action>
Create the IndexedDB schema that mirrors server tables.

**apps/web/src/lib/db/schema.ts** - Type definitions:
```typescript
// Table interfaces matching server sync models exactly
// Only store raw data - computed fields (profit_cents, etc.) are calculated on read

export interface AccountRecord {
  id: string;           // Primary key
  account_code: string;
  name: string | null;
  updated_at: string;   // ISO timestamp for sync
  deleted_at: string | null;
}

export interface BookkeepingRecord {
  id: string;           // Primary key
  account_id: string;   // Foreign key
  ebay_order_id: string;
  sale_date: string;
  item_name: string;
  qty: number;
  sale_price_cents: number;
  ebay_fees_cents: number | null;
  amazon_price_cents: number | null;
  amazon_tax_cents: number | null;
  amazon_shipping_cents: number | null;
  amazon_order_id: string | null;
  status: string;       // Raw status value
  return_label_cost_cents: number | null;
  order_remark: string | null;
  service_remark: string | null;
  updated_at: string;
  deleted_at: string | null;
}

export interface SellerRecord {
  id: string;
  display_name: string;
  normalized_name: string;
  platform: string;
  platform_id: string | null;
  times_seen: number;
  flagged: boolean;
  updated_at: string;
  deleted_at: string | null;
}

// Sync metadata for per-table checkpoints
export interface SyncMeta {
  table_name: string;   // Primary key (e.g., "records:account-123")
  last_sync_at: string; // ISO timestamp of last successful sync
  cursor: string | null; // Opaque cursor for resuming partial sync
}
```

**apps/web/src/lib/db/index.ts** - Database singleton:
```typescript
import Dexie, { type EntityTable } from 'dexie';
import type { AccountRecord, BookkeepingRecord, SellerRecord, SyncMeta } from './schema';

// Schema version - increment to clear and resync all data
export const SCHEMA_VERSION = 1;

// Database singleton
const db = new Dexie('DSProSolution') as Dexie & {
  accounts: EntityTable<AccountRecord, 'id'>;
  records: EntityTable<BookkeepingRecord, 'id'>;
  sellers: EntityTable<SellerRecord, 'id'>;
  _sync_meta: EntityTable<SyncMeta, 'table_name'>;
};

db.version(SCHEMA_VERSION).stores({
  // Primary key first, then indexed columns
  accounts: 'id, account_code, updated_at',
  records: 'id, account_id, [account_id+sale_date], updated_at',
  sellers: 'id, normalized_name, flagged, updated_at',
  _sync_meta: 'table_name',
});

export { db };
export type { AccountRecord, BookkeepingRecord, SellerRecord, SyncMeta };
```

**apps/web/src/lib/db/init.ts** - Initialization with version check:
```typescript
import { db, SCHEMA_VERSION } from './index';

const VERSION_KEY = 'ds-pro-schema-version';

/**
 * Initialize database with version migration handling.
 * Clears all data if schema version changed (simpler than migrations).
 */
export async function initializeDatabase(): Promise<void> {
  const storedVersion = localStorage.getItem(VERSION_KEY);
  const currentVersion = String(SCHEMA_VERSION);

  if (storedVersion !== currentVersion) {
    // Schema version changed - clear all data for clean resync
    console.log('[DB] Schema version changed, clearing IndexedDB...');
    await db.delete();
    await db.open();
    localStorage.setItem(VERSION_KEY, currentVersion);
    console.log('[DB] Database cleared, will resync from server');
  } else {
    await db.open();
    console.log('[DB] Database opened');
  }
}
```

Key decisions:
- SCHEMA_VERSION = 1: Increment to trigger full resync on next load
- Compound index `[account_id+sale_date]` for efficient record queries
- _sync_meta table stores per-table checkpoints
- No migrations - clear and resync is simpler for this use case
  </action>
  <verify>
TypeScript compilation passes: `cd apps/web && npx tsc --noEmit`
  </verify>
  <done>
Three files exist with correct exports: db singleton, typed interfaces, initializeDatabase function
  </done>
</task>

<task type="auto">
  <name>Task 3: Create DatabaseProvider and wire to app layout</name>
  <files>
    apps/web/src/components/providers/database-provider.tsx
    apps/web/src/app/layout.tsx
  </files>
  <action>
Create a provider component that initializes the database and wire it into the app.

**apps/web/src/components/providers/database-provider.tsx**:
```typescript
'use client';

import { useEffect, useState, type ReactNode } from 'react';
import { initializeDatabase } from '@/lib/db/init';

interface DatabaseProviderProps {
  children: ReactNode;
}

/**
 * Initializes IndexedDB on app load.
 * Renders children only after database is ready.
 * Falls back gracefully if IndexedDB unavailable (app works without cache).
 */
export function DatabaseProvider({ children }: DatabaseProviderProps) {
  const [ready, setReady] = useState(false);

  useEffect(() => {
    initializeDatabase()
      .then(() => setReady(true))
      .catch((err) => {
        console.error('[DB] Database init failed, continuing without cache:', err);
        // Still render app - it will work without local cache
        setReady(true);
      });
  }, []);

  if (!ready) {
    // Brief loading state while DB initializes (typically <100ms)
    return null;
  }

  return <>{children}</>;
}
```

**Update apps/web/src/app/layout.tsx**:
Wrap children with DatabaseProvider inside the existing provider stack.

Find the existing provider structure and add DatabaseProvider as an outer wrapper:
```typescript
import { DatabaseProvider } from '@/components/providers/database-provider';

// In the layout JSX, wrap with DatabaseProvider:
<DatabaseProvider>
  {/* existing providers and children */}
</DatabaseProvider>
```

The DatabaseProvider should be high in the tree but below any SSR-only providers. Typically after body but before QueryClientProvider.
  </action>
  <verify>
1. `cd apps/web && npm run build` succeeds (no SSR issues)
2. Start dev server, open browser devtools -> Application -> IndexedDB -> DSProSolution exists with 4 tables
  </verify>
  <done>
- DatabaseProvider component exists and exports correctly
- App layout imports and uses DatabaseProvider
- IndexedDB database creates on app load without errors
  </done>
</task>

<task type="auto">
  <name>Task 4: Add sync API client methods</name>
  <files>apps/web/src/lib/api.ts</files>
  <action>
Add typed API methods for the sync endpoints created in Phase 16.

Add these types and methods to api.ts:

**Types** (add near other interface definitions):
```typescript
// Sync API types
export interface SyncParams {
  account_id?: string;
  cursor?: string | null;
  limit?: number;
  include_deleted?: boolean;
  updated_since?: string;
  status?: BookkeepingStatus;
  flagged?: boolean;
}

export interface SyncResponse<T> {
  items: T[];
  next_cursor: string | null;
  has_more: boolean;
  total_estimate: number | null;
}

// Sync item types (raw server data without computed fields)
export interface RecordSyncItem {
  id: string;
  account_id: string;
  ebay_order_id: string;
  sale_date: string;
  item_name: string;
  qty: number;
  sale_price_cents: number;
  ebay_fees_cents: number | null;
  amazon_price_cents: number | null;
  amazon_tax_cents: number | null;
  amazon_shipping_cents: number | null;
  amazon_order_id: string | null;
  status: BookkeepingStatus;
  return_label_cost_cents: number | null;
  order_remark: string | null;
  service_remark: string | null;
  updated_at: string;
  deleted_at: string | null;
}

export interface AccountSyncItem {
  id: string;
  account_code: string;
  name: string | null;
  updated_at: string;
  deleted_at: string | null;
}

export interface SellerSyncItem {
  id: string;
  display_name: string;
  normalized_name: string;
  platform: string;
  platform_id: string | null;
  times_seen: number;
  flagged: boolean;
  updated_at: string;
  deleted_at: string | null;
}
```

**API methods** (add to the api object):
```typescript
// Sync API (for IndexedDB sync)
syncRecords: async (params: SyncParams): Promise<SyncResponse<RecordSyncItem>> => {
  const searchParams = new URLSearchParams();
  if (params.account_id) searchParams.set('account_id', params.account_id);
  if (params.cursor) searchParams.set('cursor', params.cursor);
  if (params.limit) searchParams.set('limit', String(params.limit));
  if (params.include_deleted) searchParams.set('include_deleted', 'true');
  if (params.updated_since) searchParams.set('updated_since', params.updated_since);
  if (params.status) searchParams.set('status', params.status);
  return fetchAPI(`/sync/records?${searchParams}`);
},

syncAccounts: async (params: SyncParams): Promise<SyncResponse<AccountSyncItem>> => {
  const searchParams = new URLSearchParams();
  if (params.cursor) searchParams.set('cursor', params.cursor);
  if (params.limit) searchParams.set('limit', String(params.limit));
  if (params.include_deleted) searchParams.set('include_deleted', 'true');
  if (params.updated_since) searchParams.set('updated_since', params.updated_since);
  return fetchAPI(`/sync/accounts?${searchParams}`);
},

syncSellers: async (params: SyncParams): Promise<SyncResponse<SellerSyncItem>> => {
  const searchParams = new URLSearchParams();
  if (params.cursor) searchParams.set('cursor', params.cursor);
  if (params.limit) searchParams.set('limit', String(params.limit));
  if (params.include_deleted) searchParams.set('include_deleted', 'true');
  if (params.updated_since) searchParams.set('updated_since', params.updated_since);
  if (params.flagged !== undefined) searchParams.set('flagged', String(params.flagged));
  return fetchAPI(`/sync/sellers?${searchParams}`);
},
```
  </action>
  <verify>
TypeScript compilation passes: `cd apps/web && npx tsc --noEmit`
  </verify>
  <done>
- SyncParams, SyncResponse, and sync item types are exported
- api.syncRecords, api.syncAccounts, api.syncSellers methods exist
- All methods have correct TypeScript typing
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build check:** `cd apps/web && npm run build` passes without errors
2. **Type check:** `cd apps/web && npx tsc --noEmit` passes
3. **Runtime check:** Start dev server, open browser, verify:
   - No console errors on load
   - IndexedDB -> DSProSolution database exists
   - Database has 4 object stores: accounts, records, sellers, _sync_meta
</verification>

<success_criteria>
- Dexie.js installed and database singleton created
- Schema matches server tables (accounts, records, sellers)
- _sync_meta table exists for checkpoint tracking
- DatabaseProvider initializes DB on app load
- Sync API methods available (syncRecords, syncAccounts, syncSellers)
- App builds and runs without SSR issues
</success_criteria>

<output>
After completion, create `.planning/phases/18-client-persistence/18-01-SUMMARY.md`
</output>
