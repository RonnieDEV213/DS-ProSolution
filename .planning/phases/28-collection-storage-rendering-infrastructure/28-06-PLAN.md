---
phase: 28-collection-storage-rendering-infrastructure
plan: 06
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - apps/web/src/lib/db/index.ts
  - apps/web/src/lib/db/schema.ts
  - apps/web/src/lib/db/sync.ts
  - apps/web/src/lib/query-keys.ts
  - apps/web/src/hooks/sync/use-sync-run-history.ts
  - apps/web/src/hooks/use-collection-polling.ts
  - apps/web/src/components/admin/collection/collection-history.tsx
  - apps/web/src/components/admin/collection/history-panel.tsx
autonomous: true

# NOTE: Manual edit audit logs are tracked via the existing _pending_mutations
# table, which records ALL seller mutations (create, update, delete, flag)
# including manual edits. No separate audit log IndexedDB table is needed.
# The _pending_mutations table with its timestamp, operation, and data fields
# already provides a complete audit trail of user actions.

must_haves:
  truths:
    - "Collection run history loads instantly from IndexedDB on revisit (no loading spinner for cached data)"
    - "Run history syncs incrementally from server on mount (only fetching runs newer than last checkpoint)"
    - "useCollectionPolling uses TanStack Query with refetchInterval for automatic retry, caching, and devtools integration"
    - "Polling stops when no active run is detected (no unnecessary network requests)"
    - "collection-history.tsx and/or history-panel.tsx consume useSyncRunHistory instead of direct fetch"
  artifacts:
    - path: "apps/web/src/lib/db/schema.ts"
      provides: "CollectionRunRecord type for IndexedDB"
      contains: "CollectionRunRecord"
    - path: "apps/web/src/lib/db/index.ts"
      provides: "collection_runs Dexie table"
      contains: "collection_runs"
    - path: "apps/web/src/hooks/sync/use-sync-run-history.ts"
      provides: "Cache-first run history hook"
      exports: ["useSyncRunHistory"]
    - path: "apps/web/src/hooks/use-collection-polling.ts"
      provides: "TanStack Query based polling hook"
      contains: "useQuery"
    - path: "apps/web/src/components/admin/collection/collection-history.tsx"
      provides: "Run history UI consuming useSyncRunHistory"
      contains: "useSyncRunHistory"
    - path: "apps/web/src/components/admin/collection/history-panel.tsx"
      provides: "History panel consuming useSyncRunHistory"
      contains: "useSyncRunHistory"
  key_links:
    - from: "apps/web/src/hooks/sync/use-sync-run-history.ts"
      to: "apps/web/src/lib/db/sync.ts"
      via: "syncCollectionRuns() function"
      pattern: "syncCollectionRuns"
    - from: "apps/web/src/hooks/use-collection-polling.ts"
      to: "@tanstack/react-query"
      via: "useQuery with refetchInterval"
      pattern: "useQuery.*refetchInterval"
    - from: "apps/web/src/components/admin/collection/collection-history.tsx"
      to: "apps/web/src/hooks/sync/use-sync-run-history.ts"
      via: "useSyncRunHistory() replaces direct fetch"
      pattern: "useSyncRunHistory"
    - from: "apps/web/src/components/admin/collection/history-panel.tsx"
      to: "apps/web/src/hooks/sync/use-sync-run-history.ts"
      via: "useSyncRunHistory() replaces direct fetch"
      pattern: "useSyncRunHistory"
---

<objective>
Add IndexedDB persistence for collection run history, migrate useCollectionPolling to TanStack Query, and wire useSyncRunHistory into the consuming UI components.

Purpose: Three remaining CONTEXT.md requirements not covered by Plans 01-05. (1) Collection run history currently fetches from server on every visit with no caching. Persisting to IndexedDB gives instant load for the history panel, matching the sellers experience. (2) useCollectionPolling currently uses raw fetch+setInterval. Migrating to TanStack Query provides automatic retry, caching, devtools visibility, and consistency with the rest of the v3 infrastructure. (3) The useSyncRunHistory hook must be wired into collection-history.tsx and history-panel.tsx to actually deliver the cache-first benefit to users.

Note on audit logs: Manual edit audit log persistence (mentioned in CONTEXT.md) is implicitly covered by the existing _pending_mutations table. Every seller mutation (create, update, delete, flag) is recorded with timestamp, operation type, and mutation data, providing a complete audit trail. No separate audit table is needed.

Output: New collection_runs Dexie table, useSyncRunHistory hook wired into UI, and refactored useCollectionPolling with TanStack Query.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/28-collection-storage-rendering-infrastructure/28-CONTEXT.md
@.planning/phases/28-collection-storage-rendering-infrastructure/28-RESEARCH.md
@.planning/phases/28-collection-storage-rendering-infrastructure/28-01-SUMMARY.md
@apps/web/src/lib/db/index.ts
@apps/web/src/lib/db/schema.ts
@apps/web/src/lib/db/sync.ts
@apps/web/src/lib/query-keys.ts
@apps/web/src/hooks/use-collection-polling.ts
@apps/web/src/hooks/sync/use-sync-records.ts
@apps/web/src/components/admin/collection/collection-history.tsx
@apps/web/src/components/admin/collection/history-panel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add collection_runs table to Dexie, create useSyncRunHistory hook, and wire into UI components</name>
  <files>
    apps/web/src/lib/db/schema.ts
    apps/web/src/lib/db/index.ts
    apps/web/src/lib/db/sync.ts
    apps/web/src/lib/query-keys.ts
    apps/web/src/hooks/sync/use-sync-run-history.ts
    apps/web/src/components/admin/collection/collection-history.tsx
    apps/web/src/components/admin/collection/history-panel.tsx
  </files>
  <action>
1. **Add CollectionRunRecord to schema.ts:**
   ```typescript
   export interface CollectionRunRecord {
     id: string;
     status: 'pending' | 'running' | 'paused' | 'completed' | 'failed' | 'cancelled';
     started_at: string | null;
     completed_at: string | null;
     departments_total: number;
     departments_completed: number;
     categories_total: number;
     categories_completed: number;
     products_total: number;
     products_searched: number;
     sellers_found: number;
     sellers_new: number;
     updated_at: string;
     deleted_at: string | null;
   }
   ```

   Adjust fields based on what the `/collection/runs` endpoint actually returns. Read the endpoint response to verify field names. The above is a best-guess based on the EnhancedProgress interface in use-collection-polling.ts.

2. **Add collection_runs table to Dexie schema in index.ts:**

   **IMPORTANT:** Adding a new table requires bumping SCHEMA_VERSION from 2 to 3. This will cause a one-time wipe of all local data (IndexedDB clear + resync). This is acceptable because:
   - The sync infrastructure handles automatic resync on schema upgrade
   - `initializeDatabase()` in `init.ts` already handles version changes gracefully
   - Users just see a brief "syncing" state on first load after upgrade

   ```typescript
   export const SCHEMA_VERSION = 3; // Bumped from 2 for collection_runs table

   db.version(SCHEMA_VERSION).stores({
     accounts: 'id, account_code, updated_at',
     records: 'id, account_id, [account_id+sale_date], updated_at',
     sellers: 'id, normalized_name, flagged, updated_at',
     collection_runs: 'id, status, started_at, updated_at', // NEW
     _sync_meta: 'table_name',
     _pending_mutations: 'id, record_id, table, status, timestamp',
   });
   ```

3. **Add syncCollectionRuns() to sync.ts:**

   Mirror the existing `syncSellers()` pattern. Check if a `/sync/collection-runs` endpoint exists. If not, use the existing `/collection/runs` endpoint with cursor-based pagination (or simple offset pagination if cursor isn't available for runs).

   ```typescript
   export async function syncCollectionRuns(): Promise<SyncResult> {
     const metaKey = 'collection_runs';
     const meta = await db._sync_meta.get(metaKey);
     const lastSyncedAt = meta?.last_synced_at;

     // Fetch runs updated since last sync
     const params = new URLSearchParams();
     if (lastSyncedAt) {
       params.set('updated_since', lastSyncedAt);
     }
     params.set('limit', '100');

     const token = await getAccessToken();
     const response = await fetch(`${API_BASE}/collection/runs?${params}`, {
       headers: { Authorization: `Bearer ${token}` },
     });

     if (!response.ok) throw new Error(`Sync failed: ${response.status}`);
     const data = await response.json();
     const runs = data.runs || [];

     if (runs.length > 0) {
       await db.collection_runs.bulkPut(runs);
       // Update sync checkpoint
       const latestUpdatedAt = runs.reduce(
         (latest: string, r: any) => r.updated_at > latest ? r.updated_at : latest,
         lastSyncedAt || ''
       );
       await db._sync_meta.put({
         table_name: metaKey,
         last_synced_at: latestUpdatedAt,
         last_sync_count: runs.length,
       });
     }

     return { added: runs.length, updated: 0, deleted: 0 };
   }
   ```

   Note: `getAccessToken` is imported from `@/lib/api` (exported by Plan 01). The exact API shape depends on what the backend provides. Read the `/collection/runs` endpoint response to verify. If `updated_since` isn't supported as a query param, sync all runs each time (the dataset is small -- typically <100 runs total).

4. **Add collection query keys to query-keys.ts:**
   ```typescript
   collection: {
     runs: {
       all: () => ['collection', 'runs'] as const,
       active: () => ['collection', 'runs', 'active'] as const,
       progress: (runId: string) => ['collection', 'runs', runId, 'progress'] as const,
     },
   },
   ```

5. **Create useSyncRunHistory hook:**

   ```typescript
   // apps/web/src/hooks/sync/use-sync-run-history.ts
   'use client';

   import { useLiveQuery } from 'dexie-react-hooks';
   import { useEffect, useRef, useState, useCallback } from 'react';
   import { db, type CollectionRunRecord } from '@/lib/db';
   import { syncCollectionRuns } from '@/lib/db/sync';

   interface UseSyncRunHistoryResult {
     runs: CollectionRunRecord[];
     isLoading: boolean;
     isSyncing: boolean;
     error: Error | null;
     refetch: () => void;
   }

   export function useSyncRunHistory(): UseSyncRunHistoryResult {
     const [isSyncing, setIsSyncing] = useState(false);
     const [error, setError] = useState<Error | null>(null);
     const syncingRef = useRef(false);

     // Live query - reactive, sorted by most recent first
     const runs = useLiveQuery(async () => {
       const allRuns = await db.collection_runs
         .orderBy('started_at')
         .reverse()
         .toArray();
       return allRuns;
     }, []);

     const doSync = useCallback(async () => {
       if (syncingRef.current) return;
       syncingRef.current = true;
       setIsSyncing(true);
       setError(null);

       try {
         await syncCollectionRuns();
       } catch (err) {
         setError(err instanceof Error ? err : new Error('Run history sync failed'));
       } finally {
         syncingRef.current = false;
         setIsSyncing(false);
       }
     }, []);

     // Sync on mount
     useEffect(() => {
       doSync();
     }, [doSync]);

     return {
       runs: runs ?? [],
       isLoading: runs === undefined,
       isSyncing,
       error,
       refetch: doSync,
     };
   }
   ```

6. **Wire useSyncRunHistory into collection-history.tsx and history-panel.tsx:**

   This step delivers the cache-first benefit to users. Without it, the hook exists but is unused.

   **In collection-history.tsx:**
   - Read the file to identify the current data fetching pattern (likely direct fetch or useEffect + setState).
   - Replace it with `useSyncRunHistory()`:
     ```typescript
     import { useSyncRunHistory } from '@/hooks/sync/use-sync-run-history';

     // Inside the component:
     const { runs, isLoading, isSyncing, error, refetch } = useSyncRunHistory();
     ```
   - Remove the old fetch/useEffect/useState for runs data.
   - Keep all existing UI rendering logic -- only change the data source.
   - If the component receives runs via props from a parent, trace the prop source and update the parent instead, or update whichever component owns the fetch.

   **In history-panel.tsx:**
   - Same approach: read current data fetching, replace with `useSyncRunHistory()`.
   - If history-panel.tsx receives runs as props from collection-history.tsx (or vice versa), wire the hook at the appropriate level to avoid duplicate fetching. Only ONE component should call `useSyncRunHistory()` and pass data down, OR both can call it (Dexie's live query deduplicates the IndexedDB read).
   - Remove old fetch/state management for runs.
   - Preserve all existing UI rendering.

   **Key principle:** The useSyncRunHistory hook provides `{ runs, isLoading, isSyncing, error, refetch }`. Map these to the existing UI state variables. For example, if the component has `const [runs, setRuns] = useState([])` and `const [loading, setLoading] = useState(true)`, replace both with the hook's return values.
  </action>
  <verify>
    - `npx tsc --noEmit` passes.
    - Grep confirms `collection_runs` in Dexie schema (index.ts).
    - Grep confirms `CollectionRunRecord` exported from schema.ts.
    - Grep confirms `syncCollectionRuns` exported from sync.ts.
    - Grep confirms `useSyncRunHistory` exported from use-sync-run-history.ts.
    - Grep confirms `collection:` in query-keys.ts.
    - Grep confirms SCHEMA_VERSION is 3 (bumped from 2).
    - Grep confirms `useSyncRunHistory` imported in collection-history.tsx.
    - Grep confirms `useSyncRunHistory` imported in history-panel.tsx (or data passed via props from collection-history.tsx).
    - Grep confirms no remaining direct fetch for run history in collection-history.tsx or history-panel.tsx (old pattern removed).
  </verify>
  <done>
    - CollectionRunRecord type defined in schema.ts.
    - collection_runs table added to Dexie with indexes on id, status, started_at, updated_at.
    - SCHEMA_VERSION bumped to 3 (triggers one-time data wipe + resync).
    - syncCollectionRuns() function syncs run history incrementally.
    - useSyncRunHistory hook provides cache-first run history with background sync.
    - Query keys include collection.runs namespace.
    - collection-history.tsx and/or history-panel.tsx consume useSyncRunHistory (direct fetch patterns removed).
    - Users see instant history load from IndexedDB cache on revisit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate useCollectionPolling to TanStack Query</name>
  <files>
    apps/web/src/hooks/use-collection-polling.ts
  </files>
  <action>
Rewrite useCollectionPolling to use TanStack Query's `useQuery` with `refetchInterval` instead of manual setInterval + fetch.

**Current implementation:**
- Manual `setInterval` polling at 500ms
- Direct `fetch()` with manual AbortController timeout
- Manual `createClient()` for Supabase auth
- useState for activeRun and progress

**New implementation using TanStack Query:**

```typescript
'use client';

import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useState, useCallback } from 'react';
import { queryKeys } from '@/lib/query-keys';
import { getAccessToken } from '@/lib/api';

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:8000';

// Keep existing interfaces (EnhancedProgress, CollectionRun) unchanged

export function useCollectionPolling(pollingInterval = 500) {
  const queryClient = useQueryClient();
  const [newSellerIds, setNewSellerIds] = useState<Set<string>>(new Set());

  // Query for active run
  const {
    data: activeRun,
    refetch: refetchActiveRun,
  } = useQuery({
    queryKey: queryKeys.collection.runs.active(),
    queryFn: async ({ signal }): Promise<CollectionRun | null> => {
      const token = await getAccessToken();
      if (!token) return null;

      const response = await fetch(`${API_BASE}/collection/runs?limit=1`, {
        headers: { Authorization: `Bearer ${token}` },
        signal,
      });

      if (!response.ok) return null;
      const data = await response.json();
      const runs = data.runs || [];
      return runs.find(
        (r: CollectionRun) => r.status === 'running' || r.status === 'paused'
      ) || null;
    },
    refetchInterval: pollingInterval,
    // Stop polling when page is not visible (built-in TanStack Query behavior)
    refetchIntervalInBackground: false,
    // Don't show error toasts for polling failures
    retry: false,
    // Stale time 0 - always refetch on interval
    staleTime: 0,
  });

  // Query for progress (only runs when activeRun exists)
  const {
    data: progress,
  } = useQuery({
    queryKey: queryKeys.collection.runs.progress(activeRun?.id ?? ''),
    queryFn: async ({ signal }): Promise<EnhancedProgress | null> => {
      if (!activeRun) return null;

      const token = await getAccessToken();
      if (!token) return null;

      const response = await fetch(
        `${API_BASE}/collection/runs/${activeRun.id}/progress`,
        {
          headers: { Authorization: `Bearer ${token}` },
          signal,
        }
      );

      if (!response.ok) return null;
      const data = await response.json();
      return {
        ...data,
        run_id: activeRun.id,
        status: activeRun.status,
        phase: data.phase || 'amazon',
        products_found: data.products_found ?? 0,
      };
    },
    enabled: !!activeRun && (activeRun.status === 'running' || activeRun.status === 'paused'),
    refetchInterval: pollingInterval,
    refetchIntervalInBackground: false,
    retry: false,
    staleTime: 0,
  });

  const addNewSellerId = useCallback((id: string) => {
    setNewSellerIds(prev => new Set([...prev, id]));
  }, []);

  const clearNewSellerIds = useCallback(() => {
    setNewSellerIds(new Set());
  }, []);

  const refreshAll = useCallback(async () => {
    await refetchActiveRun();
  }, [refetchActiveRun]);

  return {
    activeRun: activeRun ?? null,
    progress: progress ?? null,
    newSellerIds,
    addNewSellerId,
    clearNewSellerIds,
    refresh: refreshAll,
  };
}
```

**Key changes:**
- TanStack Query manages the polling lifecycle (refetchInterval).
- AbortController is built into TanStack Query (signal passed to queryFn).
- Progress query is conditionally enabled (only when activeRun exists).
- No manual setInterval, clearInterval, or mounted checks.
- Polling automatically stops when no active run (enabled: false).
- Results visible in TanStack Query DevTools.
- Automatic retry and error handling via TanStack Query.

**IMPORTANT:** Import `getAccessToken` from `@/lib/api`. This is exported by Plan 01 Task 1. Do NOT use `createClient().auth.getSession()`. This matches the pattern used in all other hooks after v3 migration.

**Preserve the return shape exactly** -- the consuming components (collection-progress-context.tsx, etc.) must not need changes. The return type `{ activeRun, progress, newSellerIds, addNewSellerId, clearNewSellerIds, refresh }` remains identical.
  </action>
  <verify>
    - `npx tsc --noEmit` passes.
    - Grep confirms `useQuery` import from `@tanstack/react-query`.
    - Grep confirms `refetchInterval` in the useQuery config.
    - Grep confirms `queryKeys.collection` used for query keys.
    - Grep confirms `getAccessToken` imported from `@/lib/api`.
    - Grep confirms NO `setInterval` or `clearInterval` in the file.
    - Grep confirms NO `createClient` import in the file.
    - Return type matches existing interface (activeRun, progress, newSellerIds, addNewSellerId, clearNewSellerIds, refresh).
  </verify>
  <done>
    - useCollectionPolling uses TanStack Query with refetchInterval.
    - Active run query polls at configured interval.
    - Progress query conditionally enabled (only during active run).
    - No manual setInterval, AbortController, or createClient.
    - getAccessToken imported from @/lib/api (exported by Plan 01).
    - Built-in retry, error handling, devtools visibility.
    - Return shape unchanged (backward compatible with all consumers).
    - Polling automatically pauses when page not visible.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` from apps/web/ passes with zero errors.
- Collection history panel loads from IndexedDB cache (instant on revisit).
- collection-history.tsx and/or history-panel.tsx use useSyncRunHistory (no direct fetch for runs).
- useCollectionPolling visible in TanStack Query DevTools.
- No regressions to existing collection polling behavior.
- SCHEMA_VERSION bumped triggers clean resync on first load.
</verification>

<success_criteria>
- Collection run history persists in IndexedDB via collection_runs table.
- useSyncRunHistory provides cache-first history with background sync.
- collection-history.tsx and history-panel.tsx consume useSyncRunHistory (old fetch patterns removed).
- useCollectionPolling fully migrated to TanStack Query with getAccessToken from @/lib/api.
- All consumers of useCollectionPolling continue to work without changes.
- SCHEMA_VERSION correctly bumped with no data corruption.
- Manual edit audit logs are covered by _pending_mutations (no separate table needed).
</success_criteria>

<output>
After completion, create `.planning/phases/28-collection-storage-rendering-infrastructure/28-06-SUMMARY.md`
</output>
