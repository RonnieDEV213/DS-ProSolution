---
phase: 28-collection-storage-rendering-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/lib/query-keys.ts
  - apps/web/src/lib/api.ts
  - apps/web/src/lib/db/pending-mutations.ts
autonomous: true

must_haves:
  truths:
    - "Query key factory includes sellers keys for cache management"
    - "api.ts exports typed seller CRUD functions (createSeller, updateSeller, deleteSeller, flagSeller, bulkDeleteSellers)"
    - "executeMutation() in pending-mutations.ts dispatches seller operations to correct API functions"
  artifacts:
    - path: "apps/web/src/lib/query-keys.ts"
      provides: "Seller query key factory"
      contains: "sellers:"
    - path: "apps/web/src/lib/api.ts"
      provides: "Typed seller API functions"
      contains: "sellerApi"
    - path: "apps/web/src/lib/db/pending-mutations.ts"
      provides: "Seller mutation dispatch"
      contains: "case 'sellers':"
  key_links:
    - from: "apps/web/src/lib/db/pending-mutations.ts"
      to: "apps/web/src/lib/api.ts"
      via: "sellerApi function calls in executeMutation"
      pattern: "sellerApi\\."
---

<objective>
Add seller query keys, typed seller API functions, and seller mutation dispatch to the existing v3 infrastructure.

Purpose: The SellersGrid currently uses raw fetch() calls with manual auth token handling. This plan creates the typed API layer and cache key infrastructure that the sync hooks (Plan 03) and mutation hooks (Plan 03) will consume. It also ensures the offline queue can replay seller mutations when connectivity returns.

Output: Extended query-keys.ts, api.ts with sellerApi object, pending-mutations.ts with seller case handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/28-collection-storage-rendering-infrastructure/28-CONTEXT.md
@.planning/phases/28-collection-storage-rendering-infrastructure/28-RESEARCH.md
@apps/web/src/lib/query-keys.ts
@apps/web/src/lib/api.ts
@apps/web/src/lib/db/pending-mutations.ts
@apps/web/src/lib/db/schema.ts
@apps/api/src/app/routers/sellers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend query-keys.ts and add seller API functions to api.ts</name>
  <files>
    apps/web/src/lib/query-keys.ts
    apps/web/src/lib/api.ts
  </files>
  <action>
1. In query-keys.ts:
   - Add a `SellerFilters` interface with optional fields: `flagged?: boolean`, `search?: string`.
   - Add a `sellers` section to the `queryKeys` object mirroring the existing `records` pattern:
     ```
     sellers: {
       all: (orgId: string) => ['sellers', orgId] as const,
       list: (orgId: string, filters?: SellerFilters) => ['sellers', orgId, 'list', filters] as const,
       infinite: (orgId: string, filters?: SellerFilters) => ['sellers', orgId, 'infinite', filters] as const,
     },
     ```

2. In api.ts:
   - Add a `sellerApi` object (exported, separate from `api`) with these typed functions using the existing `fetchAPI` helper:
     - `createSeller: (name: string) => fetchAPI<SellerSyncItem>('/sellers', { method: 'POST', body: JSON.stringify({ name }) })`
     - `createSellersBulk: (names: string[]) => fetchAPI<{ success_count: number; failed_count: number; errors: string[] }>('/sellers/bulk', { method: 'POST', body: JSON.stringify({ names }) })`
     - `updateSeller: (id: string, name: string) => fetchAPI<SellerSyncItem>('/sellers/' + id, { method: 'PATCH', body: JSON.stringify({ name }) })`
     - `deleteSeller: (id: string) => void` -- same pattern as api.deleteRecord (manual fetch, handle 204)
     - `bulkDeleteSellers: (ids: string[]) => fetchAPI<{ deleted_count: number }>('/sellers/bulk/delete', { method: 'POST', body: JSON.stringify({ ids }) })`
     - `flagSeller: (id: string) => fetchAPI<{ flagged: boolean }>('/sellers/' + id + '/flag', { method: 'POST' })`
   - Reuse the existing `fetchAPI` and `getAccessToken` helpers (they are file-scoped, already available).
   - Do NOT modify the existing `api` object -- add `sellerApi` as a separate export.
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no errors in query-keys.ts or api.ts.
    - Grep confirms `sellerApi` is exported from api.ts.
    - Grep confirms `sellers:` exists in queryKeys object.
  </verify>
  <done>
    - queryKeys.sellers.all, .list, .infinite functions exist and return correct tuple shapes.
    - sellerApi exports 6 typed functions: createSeller, createSellersBulk, updateSeller, deleteSeller, bulkDeleteSellers, flagSeller.
    - No changes to existing api or queryKeys entries (backward compatible).
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend executeMutation for seller operations</name>
  <files>
    apps/web/src/lib/db/pending-mutations.ts
  </files>
  <action>
Extend the `executeMutation()` function to handle seller table operations. Currently it only handles `case 'create'`, `case 'update'`, `case 'delete'` for records (the switch is on `mutation.operation` but doesn't check `mutation.table`).

1. Wrap the existing operation switch inside a `switch (mutation.table)` block:
   ```typescript
   async function executeMutation(mutation: PendingMutation): Promise<void> {
     switch (mutation.table) {
       case 'records': {
         // Move existing create/update/delete cases here (unchanged)
         switch (mutation.operation) {
           case 'create': { /* existing code */ break; }
           case 'update': { /* existing code */ break; }
           case 'delete': { api.deleteRecord(mutation.record_id); break; }
         }
         break;
       }
       case 'sellers': {
         switch (mutation.operation) {
           case 'create': {
             const name = mutation.data.name as string;
             await sellerApi.createSeller(name);
             break;
           }
           case 'update': {
             if ('flagged' in mutation.data) {
               await sellerApi.flagSeller(mutation.record_id);
             } else if ('name' in mutation.data) {
               await sellerApi.updateSeller(mutation.record_id, mutation.data.name as string);
             }
             break;
           }
           case 'delete': {
             await sellerApi.deleteSeller(mutation.record_id);
             break;
           }
         }
         break;
       }
       case 'accounts':
         // No mutations currently supported for accounts
         break;
     }
   }
   ```

2. Add import for `sellerApi` from `@/lib/api` at the top of the file (alongside existing `api` import).

3. Important: The existing `fetchServerRecord` function used for conflict detection only handles records. For sellers, skip conflict detection (CONTEXT.md says "last write wins" for sellers). The existing `processQueue` function already only runs conflict detection for `mutation.operation === 'update'` on records -- verify this is still the case after refactoring. If needed, add a table check: only run `detectConflict` when `mutation.table === 'records'`.
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no errors in pending-mutations.ts.
    - Grep confirms `case 'sellers':` exists in executeMutation.
    - Grep confirms `sellerApi` is imported.
    - Existing record mutation behavior is unchanged (verify the records case still has the same code).
  </verify>
  <done>
    - executeMutation dispatches seller create/update/delete to sellerApi functions.
    - Seller flag operations route through sellerApi.flagSeller.
    - Seller name updates route through sellerApi.updateSeller.
    - Conflict detection only runs for records table (last-write-wins for sellers).
    - Existing record mutation behavior preserved exactly.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` from apps/web/ passes with zero errors.
- All three files compile and export correctly.
- No regressions to existing bookkeeping functionality.
</verification>

<success_criteria>
- Query key factory has sellers namespace with all/list/infinite keys.
- Seller API has 6 typed functions matching backend endpoints.
- Offline mutation queue can dispatch seller operations (create, update, delete, flag).
- Zero changes to existing records/accounts functionality.
</success_criteria>

<output>
After completion, create `.planning/phases/28-collection-storage-rendering-infrastructure/28-01-SUMMARY.md`
</output>
