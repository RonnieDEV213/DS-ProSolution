---
phase: 28-collection-storage-rendering-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - apps/web/src/hooks/sync/use-sync-sellers.ts
  - apps/web/src/hooks/mutations/use-flag-seller.ts
  - apps/web/src/hooks/mutations/use-update-seller.ts
  - apps/web/src/hooks/mutations/use-delete-seller.ts
autonomous: true

must_haves:
  truths:
    - "useSyncSellers returns sellers from IndexedDB with reactive updates via useLiveQuery"
    - "useSyncSellers triggers background sync on mount via syncSellers()"
    - "useFlagSeller optimistically updates IndexedDB and calls API (or queues offline)"
    - "useUpdateSeller optimistically updates IndexedDB seller name and calls API (or queues offline)"
    - "useDeleteSeller optimistically removes from IndexedDB and calls API (or queues offline)"
  artifacts:
    - path: "apps/web/src/hooks/sync/use-sync-sellers.ts"
      provides: "Cache-first seller data hook"
      exports: ["useSyncSellers"]
    - path: "apps/web/src/hooks/mutations/use-flag-seller.ts"
      provides: "Seller flag toggle mutation"
      exports: ["useFlagSeller"]
    - path: "apps/web/src/hooks/mutations/use-update-seller.ts"
      provides: "Seller name update mutation"
      exports: ["useUpdateSeller"]
    - path: "apps/web/src/hooks/mutations/use-delete-seller.ts"
      provides: "Seller delete mutation"
      exports: ["useDeleteSeller"]
  key_links:
    - from: "apps/web/src/hooks/sync/use-sync-sellers.ts"
      to: "apps/web/src/lib/db/sync.ts"
      via: "syncSellers() import"
      pattern: "import.*syncSellers.*from.*db/sync"
    - from: "apps/web/src/hooks/mutations/use-flag-seller.ts"
      to: "apps/web/src/lib/api.ts"
      via: "sellerApi.flagSeller"
      pattern: "sellerApi\\.flagSeller"
    - from: "apps/web/src/hooks/mutations/use-flag-seller.ts"
      to: "apps/web/src/lib/db/index.ts"
      via: "db.sellers.update"
      pattern: "db\\.sellers\\.update"
---

<objective>
Create the seller sync hook and seller mutation hooks that bridge IndexedDB with React state.

Purpose: These hooks are the data layer that Plan 04 will consume. useSyncSellers provides cache-first seller reads with background sync. The mutation hooks provide optimistic IndexedDB updates with offline queue support. Together they replace the direct fetch()+useState pattern in SellersGrid.

Output: 4 new hook files following the exact patterns of useSyncRecords and useUpdateRecord/useDeleteRecord/useCreateRecord.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/28-collection-storage-rendering-infrastructure/28-CONTEXT.md
@.planning/phases/28-collection-storage-rendering-infrastructure/28-RESEARCH.md
@apps/web/src/hooks/sync/use-sync-records.ts
@apps/web/src/hooks/mutations/use-update-record.ts
@apps/web/src/hooks/mutations/use-delete-record.ts
@apps/web/src/hooks/mutations/use-create-record.ts
@apps/web/src/lib/db/index.ts
@apps/web/src/lib/db/schema.ts
@apps/web/src/lib/db/sync.ts
@apps/web/src/lib/query-keys.ts
@apps/web/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useSyncSellers hook</name>
  <files>
    apps/web/src/hooks/sync/use-sync-sellers.ts
  </files>
  <action>
Create `use-sync-sellers.ts` mirroring `use-sync-records.ts` but adapted for sellers (no accountId scoping, different filters, different query shape):

```typescript
'use client';

import { useLiveQuery } from 'dexie-react-hooks';
import { useEffect, useRef, useCallback, useState } from 'react';
import { db, type SellerRecord } from '@/lib/db';
import { syncSellers } from '@/lib/db/sync';

interface UseSyncSellersOptions {
  filters?: {
    flagged?: boolean;
    search?: string;
  };
}

interface UseSyncSellersResult {
  sellers: SellerRecord[];
  isLoading: boolean;
  isSyncing: boolean;
  error: Error | null;
  totalCount: number;
  flaggedCount: number;
  refetch: () => void;
}

export function useSyncSellers(options: UseSyncSellersOptions = {}): UseSyncSellersResult {
  const { filters } = options;
  const [isSyncing, setIsSyncing] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const syncingRef = useRef(false);

  // Live query - reactive to IndexedDB changes
  // Returns ALL sellers matching filters (no pagination at hook level --
  // SellersGrid uses react-window virtualization for rendering performance)
  const sellers = useLiveQuery(async () => {
    let results: SellerRecord[];

    // Use index for flagged filter if no search (more efficient)
    if (filters?.flagged !== undefined && !filters?.search) {
      // Dexie stores booleans as 0/1 in indexes
      results = await db.sellers
        .where('flagged')
        .equals(filters.flagged ? 1 : 0)
        .toArray();
    } else {
      results = await db.sellers.toArray();
    }

    // Apply filters in memory
    if (filters?.flagged !== undefined && filters?.search) {
      results = results.filter(s => {
        // Dexie boolean comparison: s.flagged may be boolean or 0/1
        const isFlagged = s.flagged === true || (s.flagged as unknown) === 1;
        return filters.flagged ? isFlagged : !isFlagged;
      });
    }

    if (filters?.search) {
      const term = filters.search.toLowerCase();
      results = results.filter(s =>
        s.display_name.toLowerCase().includes(term)
      );
    }

    // Sort by display_name ASC for consistent grid order
    results.sort((a, b) => a.display_name.localeCompare(b.display_name));

    return results;
  }, [filters?.flagged, filters?.search]);

  const totalCount = useLiveQuery(() => db.sellers.count(), []) ?? 0;

  // Flagged count: use index for efficiency
  // Note: Dexie boolean index stores as 0/1, so use equals(1) for true
  const flaggedCount = useLiveQuery(async () => {
    try {
      return await db.sellers.where('flagged').equals(1).count();
    } catch {
      // Fallback if index doesn't work with 0/1: filter in memory
      const all = await db.sellers.toArray();
      return all.filter(s => s.flagged === true || (s.flagged as unknown) === 1).length;
    }
  }, []) ?? 0;

  // Sync function
  const doSync = useCallback(async () => {
    if (syncingRef.current) return;
    syncingRef.current = true;
    setIsSyncing(true);
    setError(null);

    try {
      await syncSellers();
    } catch (err) {
      const syncError = err instanceof Error ? err : new Error('Seller sync failed');
      setError(syncError);
      console.error('[useSyncSellers] Sync failed:', err);
    } finally {
      syncingRef.current = false;
      setIsSyncing(false);
    }
  }, []);

  // Background sync on mount
  useEffect(() => {
    doSync();
  }, [doSync]);

  return {
    sellers: sellers ?? [],
    isLoading: sellers === undefined,
    isSyncing,
    error,
    totalCount,
    flaggedCount,
    refetch: doSync,
  };
}
```

Key differences from useSyncRecords:
- No `accountId` parameter (sellers are org-wide).
- No pagination at hook level (useLiveQuery returns all matching sellers; react-window handles rendering).
- `flaggedCount` separate live query for header display.
- Dexie boolean index quirk handled with fallback (equals(1) for true).
- Sort by display_name for consistent grid ordering.
  </action>
  <verify>
    - `npx tsc --noEmit` passes.
    - File exports `useSyncSellers` function.
    - Grep confirms `syncSellers` import from `@/lib/db/sync`.
    - Grep confirms `useLiveQuery` usage for reactive reads.
  </verify>
  <done>
    - useSyncSellers reads from IndexedDB via useLiveQuery (reactive to changes).
    - Background sync triggers on mount via syncSellers().
    - Filters (flagged, search) work correctly.
    - totalCount and flaggedCount are live-computed.
    - refetch() manually triggers re-sync.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create seller mutation hooks (flag, update, delete)</name>
  <files>
    apps/web/src/hooks/mutations/use-flag-seller.ts
    apps/web/src/hooks/mutations/use-update-seller.ts
    apps/web/src/hooks/mutations/use-delete-seller.ts
  </files>
  <action>
Create three mutation hooks mirroring the existing record mutation hooks but adapted for sellers. Sellers use IndexedDB as source of truth (via useLiveQuery in useSyncSellers), so these hooks update IndexedDB directly -- no TanStack Query cache manipulation needed (useLiveQuery is reactive).

1. **use-flag-seller.ts:**
```typescript
'use client';
import { useMutation } from '@tanstack/react-query';
import { db } from '@/lib/db';
import { sellerApi } from '@/lib/api';
import { useOnlineStatus } from '@/hooks/sync/use-online-status';
import { queueMutation } from '@/lib/db/pending-mutations';

interface FlagSellerVars {
  id: string;
  flagged: boolean;
}

export function useFlagSeller() {
  const isOnline = useOnlineStatus();

  return useMutation<void, Error, FlagSellerVars>({
    mutationFn: async ({ id, flagged }) => {
      // Optimistically update IndexedDB immediately
      await db.sellers.update(id, { flagged });

      if (!isOnline) {
        await queueMutation({
          record_id: id,
          table: 'sellers',
          operation: 'update',
          data: { flagged },
        });
        return;
      }

      // Online: call API
      await sellerApi.flagSeller(id);
    },
    onError: async (_error, { id, flagged }) => {
      // Rollback IndexedDB on failure
      await db.sellers.update(id, { flagged: !flagged });
    },
    retry: (failureCount, error) => {
      if (error instanceof Error) {
        const statusMatch = error.message.match(/\b(4\d{2})\b/);
        if (statusMatch) return false;
      }
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}
```

2. **use-update-seller.ts:**
```typescript
'use client';
import { useMutation } from '@tanstack/react-query';
import { db, type SellerRecord } from '@/lib/db';
import { sellerApi } from '@/lib/api';
import { useOnlineStatus } from '@/hooks/sync/use-online-status';
import { queueMutation } from '@/lib/db/pending-mutations';

interface UpdateSellerVars {
  id: string;
  name: string;
}

interface UpdateSellerContext {
  previousRecord: SellerRecord | undefined;
}

export function useUpdateSeller() {
  const isOnline = useOnlineStatus();

  return useMutation<void, Error, UpdateSellerVars, UpdateSellerContext>({
    mutationFn: async ({ id, name }) => {
      // Optimistically update IndexedDB
      await db.sellers.update(id, { display_name: name });

      if (!isOnline) {
        await queueMutation({
          record_id: id,
          table: 'sellers',
          operation: 'update',
          data: { name },
        });
        return;
      }

      await sellerApi.updateSeller(id, name);
    },
    onMutate: async ({ id }) => {
      const previousRecord = await db.sellers.get(id);
      return { previousRecord };
    },
    onError: async (_error, _vars, context) => {
      // Rollback IndexedDB
      if (context?.previousRecord) {
        await db.sellers.put(context.previousRecord);
      }
    },
    retry: (failureCount, error) => {
      if (error instanceof Error) {
        const statusMatch = error.message.match(/\b(4\d{2})\b/);
        if (statusMatch) return false;
      }
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}
```

3. **use-delete-seller.ts:**
```typescript
'use client';
import { useMutation } from '@tanstack/react-query';
import { db, type SellerRecord } from '@/lib/db';
import { sellerApi } from '@/lib/api';
import { useOnlineStatus } from '@/hooks/sync/use-online-status';
import { queueMutation } from '@/lib/db/pending-mutations';

interface DeleteSellerVars {
  ids: string[];
}

interface DeleteSellerContext {
  deletedRecords: SellerRecord[];
}

export function useDeleteSeller() {
  const isOnline = useOnlineStatus();

  return useMutation<void, Error, DeleteSellerVars, DeleteSellerContext>({
    mutationFn: async ({ ids }) => {
      if (!isOnline) {
        for (const id of ids) {
          await queueMutation({
            record_id: id,
            table: 'sellers',
            operation: 'delete',
            data: {},
          });
        }
        return;
      }

      // Online: use bulk delete for multiple, single for one
      if (ids.length === 1) {
        await sellerApi.deleteSeller(ids[0]);
      } else {
        await sellerApi.bulkDeleteSellers(ids);
      }
    },
    onMutate: async ({ ids }) => {
      // Snapshot for rollback
      const deletedRecords: SellerRecord[] = [];
      for (const id of ids) {
        const record = await db.sellers.get(id);
        if (record) deletedRecords.push(record);
      }
      // Optimistically remove from IndexedDB
      await db.sellers.bulkDelete(ids);
      return { deletedRecords };
    },
    onError: async (_error, _vars, context) => {
      // Rollback: restore deleted records
      if (context?.deletedRecords?.length) {
        await db.sellers.bulkPut(context.deletedRecords);
      }
    },
    retry: (failureCount, error) => {
      if (error instanceof Error) {
        const statusMatch = error.message.match(/\b(4\d{2})\b/);
        if (statusMatch) return false;
      }
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
}
```

Key design decisions:
- No TanStack Query cache manipulation (unlike record mutations). Sellers use useLiveQuery which is automatically reactive to IndexedDB changes. When db.sellers.update() runs, useLiveQuery re-runs and UI updates.
- useFlagSeller toggles the boolean -- the API endpoint already toggles server-side, so we just call it.
- useDeleteSeller accepts an array of IDs to support bulk delete (existing SellersGrid feature).
- All three have rollback on error.
- All three queue offline mutations when !isOnline.
  </action>
  <verify>
    - `npx tsc --noEmit` passes for all three files.
    - Each file exports its named hook function.
    - Grep confirms `db.sellers.update` or `db.sellers.bulkDelete` in each file.
    - Grep confirms `sellerApi` import in each file.
    - Grep confirms `queueMutation` import in each file.
  </verify>
  <done>
    - useFlagSeller optimistically toggles flagged in IndexedDB, calls API or queues offline.
    - useUpdateSeller optimistically updates display_name in IndexedDB, calls API or queues offline.
    - useDeleteSeller optimistically removes sellers from IndexedDB, calls API (single/bulk) or queues offline.
    - All three have error rollback.
    - All three have retry logic (3 attempts, skip 4xx errors).
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` from apps/web/ passes with zero errors.
- All 4 new hook files compile and export correctly.
- Each hook uses the correct db.sellers operations.
- Each mutation hook handles online/offline paths.
</verification>

<success_criteria>
- useSyncSellers provides reactive seller reads from IndexedDB with background sync.
- Three mutation hooks (flag, update, delete) provide optimistic IndexedDB updates with offline queue.
- All hooks follow established v3 patterns (useSyncRecords, useUpdateRecord, etc.).
- Ready for SellersGrid consumption in Plan 04.
</success_criteria>

<output>
After completion, create `.planning/phases/28-collection-storage-rendering-infrastructure/28-03-SUMMARY.md`
</output>
