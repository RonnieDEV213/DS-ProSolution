---
phase: 28-collection-storage-rendering-infrastructure
plan: 05
type: execute
wave: 4
depends_on: ["28-04"]
files_modified:
  - apps/web/src/components/admin/collection/sellers-grid.tsx
autonomous: true

must_haves:
  truths:
    - "All seller mutations (flag, edit, delete, add) go through IndexedDB + mutation hooks"
    - "No direct fetch() calls remain in SellersGrid for seller CRUD"
    - "No setSellers() calls remain in SellersGrid (useLiveQuery is sole source of truth)"
    - "Export flag-on-export persists to IndexedDB (survives page reload)"
    - "Undo/redo operates on IndexedDB (single-level undo per CONTEXT.md)"
    - "Offline mutations queue correctly for later replay"
  artifacts:
    - path: "apps/web/src/components/admin/collection/sellers-grid.tsx"
      provides: "Fully migrated SellersGrid with no direct fetch or setSellers"
      contains: "useFlagSeller"
  key_links:
    - from: "apps/web/src/components/admin/collection/sellers-grid.tsx"
      to: "apps/web/src/hooks/mutations/use-flag-seller.ts"
      via: "useFlagSeller hook"
      pattern: "useFlagSeller"
    - from: "apps/web/src/components/admin/collection/sellers-grid.tsx"
      to: "apps/web/src/hooks/mutations/use-update-seller.ts"
      via: "useUpdateSeller hook"
      pattern: "useUpdateSeller"
    - from: "apps/web/src/components/admin/collection/sellers-grid.tsx"
      to: "apps/web/src/hooks/mutations/use-delete-seller.ts"
      via: "useDeleteSeller hook"
      pattern: "useDeleteSeller"
    - from: "apps/web/src/components/admin/collection/sellers-grid.tsx"
      to: "apps/web/src/lib/db/index.ts"
      via: "db.sellers for add/export operations"
      pattern: "db\\.sellers"
---

<objective>
Migrate all SellersGrid mutations from direct fetch()+setSellers() to mutation hooks + IndexedDB. Complete the data layer migration.

Purpose: Plan 04 replaced the data source (reads). This plan replaces all writes. After this plan, SellersGrid has ZERO direct fetch calls and ZERO setSellers calls. Every data change flows through IndexedDB (via mutation hooks or db.sellers directly), and useLiveQuery reactively updates the UI. This completes the offline-capable, cache-first architecture for sellers.

Output: sellers-grid.tsx fully migrated. No createClient, no API_BASE, no direct fetch, no setSellers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/28-collection-storage-rendering-infrastructure/28-CONTEXT.md
@.planning/phases/28-collection-storage-rendering-infrastructure/28-RESEARCH.md
@apps/web/src/components/admin/collection/sellers-grid.tsx
@apps/web/src/hooks/mutations/use-flag-seller.ts
@apps/web/src/hooks/mutations/use-update-seller.ts
@apps/web/src/hooks/mutations/use-delete-seller.ts
@apps/web/src/lib/db/index.ts
@apps/web/src/lib/db/schema.ts
@apps/web/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate flag painting, single flag toggle, and bulk flag operations</name>
  <files>
    apps/web/src/components/admin/collection/sellers-grid.tsx
  </files>
  <action>
**CRITICAL: Read the entire sellers-grid.tsx file first. After Plan 04, it uses useSyncSellers for reading but still has direct fetch()+setSellers() for mutations. This task replaces all flagging operations.**

1. **Add mutation hook imports:**
   ```typescript
   import { useFlagSeller } from '@/hooks/mutations/use-flag-seller';
   import { useUpdateSeller } from '@/hooks/mutations/use-update-seller';
   import { useDeleteSeller } from '@/hooks/mutations/use-delete-seller';
   import { db } from '@/lib/db';
   import { sellerApi } from '@/lib/api';
   ```

2. **Initialize mutation hooks in component body:**
   ```typescript
   const flagMutation = useFlagSeller();
   const updateMutation = useUpdateSeller();
   const deleteMutation = useDeleteSeller();
   ```

3. **Replace handleRightDragEnd flag operations:**

   Current pattern (single seller right-click toggle):
   ```typescript
   setSellers(prev => prev.map(s =>
     s.id === seller.id ? { ...s, flagged: newFlagged } : s
   ));
   // Then: fetch(`${API_BASE}/sellers/${seller.id}/flag`, ...)
   ```

   Replace with:
   ```typescript
   flagMutation.mutate({ id: seller.id, flagged: newFlagged });
   // No setSellers needed -- useLiveQuery reacts to IndexedDB change
   ```

   Current pattern (batch flag painting after drag):
   ```typescript
   setSellers(prev => prev.map(s =>
     previewIds.includes(s.id) ? { ...s, flagged: mode } : s
   ));
   // Then: Promise.all(idsToToggle.map(id => fetch(...)))
   ```

   Replace with:
   ```typescript
   // Update IndexedDB in bulk for immediate UI feedback
   await db.sellers.bulkPut(
     idsToToggle.map(id => {
       const seller = sellersRef.current.find(s => s.id === id);
       return seller ? { ...seller, flagged: mode! } : null;
     }).filter(Boolean) as SellerRecord[]
   );
   // Then sync to API for each toggled seller
   for (const id of idsToToggle) {
     flagMutation.mutate({ id, flagged: mode! });
   }
   ```

   Actually, simpler approach: the flagMutation already updates IndexedDB optimistically. So just call it for each:
   ```typescript
   for (const id of idsToToggle) {
     flagMutation.mutate({ id, flagged: mode! });
   }
   // Also update the ones in preview that already had the target state
   // (they don't need API calls but should show correct state)
   ```

   The key insight: useFlagSeller.mutate updates IndexedDB immediately in mutationFn. useLiveQuery reacts. No setSellers needed.

4. **Replace all setSellers calls that modify flagged state:**
   Search for every `setSellers(prev => prev.map(s =>` that involves `flagged`. Replace each with the appropriate flagMutation.mutate call. Remove the subsequent fetch() calls.

5. **Remove supabase.auth.getSession() calls used for flagging:**
   After migration, the mutation hooks handle auth internally (via sellerApi which uses getAccessToken()). Remove `const { data: { session } } = await supabase.auth.getSession();` from flag-related functions.
  </action>
  <verify>
    - Grep: no `setSellers.*flagged` patterns remain.
    - Grep: no `fetch.*sellers.*flag` patterns remain.
    - Grep: `flagMutation.mutate` appears in the right-click handlers.
    - `npx tsc --noEmit` passes.
  </verify>
  <done>
    - All flag operations go through useFlagSeller mutation hook.
    - Single right-click toggle uses flagMutation.mutate.
    - Batch flag painting uses flagMutation.mutate for each changed seller.
    - No direct fetch() or setSellers() for flagging.
    - Flag changes persist to IndexedDB immediately.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate add, edit, delete, export, and undo/redo operations</name>
  <files>
    apps/web/src/components/admin/collection/sellers-grid.tsx
  </files>
  <action>
**Continue the migration from Task 1. Replace remaining setSellers/fetch patterns.**

1. **handleAddSeller (add seller):**

   Current: Uses fetch(`${API_BASE}/sellers`, ...) and fetch(`${API_BASE}/sellers/bulk`, ...) then calls fetchSellers().

   Replace with:
   ```typescript
   const handleAddSeller = async () => {
     if (!newSellerName.trim()) return;
     setAddError(null);

     const sellerNames = newSellerName
       .split(/[\r\n]+/)
       .map(name => name.trim())
       .filter(name => name.length > 0);

     if (sellerNames.length === 0) return;

     try {
       if (sellerNames.length === 1) {
         await sellerApi.createSeller(sellerNames[0]);
       } else {
         const result = await sellerApi.createSellersBulk(sellerNames);
         if (result.failed_count > 0) {
           if (result.success_count > 0) {
             setAddError(`Added ${result.success_count}, failed ${result.failed_count}: ${result.errors[0]}${result.errors.length > 1 ? '...' : ''}`);
           } else {
             setAddError(result.errors[0] || "Failed to add sellers");
             return;
           }
         }
       }
       setNewSellerName("");
       onSellerChange();
       // Trigger re-sync to pull new sellers into IndexedDB
       refetch();
     } catch (e) {
       setAddError("Failed to add seller");
     }
   };
   ```

2. **saveEdit (rename seller):**

   Current: Uses fetch(`${API_BASE}/sellers/${editingId}`, { method: "PATCH", ... }) then calls fetchSellers().

   Replace with:
   ```typescript
   const saveEdit = async () => {
     if (!editingId || !editValue?.trim()) {
       setEditingId(null);
       setEditValue("");
       return;
     }

     try {
       updateMutation.mutate({ id: editingId, name: editValue.trim() });
       setEditingId(null);
       setEditValue("");
       onSellerChange();
     } catch (e) {
       console.error("Failed to update seller:", e);
     }
   };
   ```

3. **handleBulkDelete:**

   Current: Uses fetch DELETE/POST then setSellers to optimistically remove.

   Replace with:
   ```typescript
   const handleBulkDelete = async () => {
     if (selectedIds.size === 0) return;

     const idsArray = Array.from(selectedIds);

     // Capture for undo before deletion (read from IndexedDB)
     const deletedSellers: SellerRecord[] = [];
     for (const id of idsArray) {
       const seller = await db.sellers.get(id);
       if (seller) deletedSellers.push(seller);
     }

     // Push to undo stack (simplified to single-level per CONTEXT.md)
     setUndoStack([{ sellers: deletedSellers.map((s, i) => ({ ...s, originalIndex: i })), timestamp: Date.now() }]);
     setRedoStack([]);
     setSelectedIds(new Set());

     // Delete via mutation hook (handles IndexedDB + API)
     deleteMutation.mutate({ ids: idsArray });

     toast.success(
       `Deleted ${idsArray.length} seller${idsArray.length > 1 ? 's' : ''}`,
       {
         duration: 5000,
         action: {
           label: 'Undo',
           onClick: () => handleUndo(),
         },
       }
     );
     onSellerChange();
   };
   ```

4. **handleUndo (restore deleted sellers):**

   Current: Uses fetch POST to re-add sellers, then fetchSellers().

   Replace with:
   ```typescript
   const handleUndo = useCallback(async () => {
     if (undoStack.length === 0) return;

     const lastEntry = undoStack[undoStack.length - 1];
     setUndoStack(prev => prev.slice(0, -1));

     // Restore to IndexedDB immediately
     await db.sellers.bulkPut(lastEntry.sellers);

     // Re-add to server
     try {
       const names = lastEntry.sellers.map(s => s.display_name);
       if (names.length === 1) {
         await sellerApi.createSeller(names[0]);
       } else {
         await sellerApi.createSellersBulk(names);
       }
       toast.success(`Restored ${names.length} seller${names.length > 1 ? 's' : ''}`);
       onSellerChange();
       refetch(); // Re-sync to get correct server IDs
     } catch (e) {
       console.error("Undo failed:", e);
       toast.error("Failed to restore sellers");
     }
   }, [undoStack, onSellerChange, refetch]);
   ```

5. **handleRedo: Simplify per CONTEXT.md (single-level undo only).**

   Remove the redo functionality entirely (CONTEXT.md: "Simplify to single-level undo"). Remove:
   - `redoStack` state
   - `handleRedo` callback
   - `Ctrl+Shift+Z` handler for redo
   - Any redo-related code

   This simplifies the undo/redo system significantly.

6. **flagExportedSellers (export with flag):**

   Current: Uses setSellers to flag, then fetch to sync.

   Replace with:
   ```typescript
   const flagExportedSellers = useCallback(async (sellerIds: string[]) => {
     if (!exportFlagOnExport || sellerIds.length === 0) return;

     const currentSellers = sellersRef.current;
     const idsToFlag = sellerIds.filter(id => {
       const seller = currentSellers.find(s => s.id === id);
       return seller && !seller.flagged;
     });

     if (idsToFlag.length === 0) return;

     // Update IndexedDB in bulk
     for (const id of idsToFlag) {
       flagMutation.mutate({ id, flagged: true });
     }
   }, [exportFlagOnExport, flagMutation]);
   ```

7. **Remove all remaining cleanup:**
   - Remove `const supabase = createClient();` if still present.
   - Remove `import { createClient } from "@/lib/supabase/client";` if still present.
   - Remove `const API_BASE = ...` line.
   - Remove all remaining `setSellers` calls. The `useState<Seller[]>` declaration was removed in Plan 04; if any `setSellers` references remain, they will cause compile errors -- find and replace each one.
   - Remove `DeletedSeller` interface (replace with SellerRecord + originalIndex).

8. **Update UndoEntry type:**
   ```typescript
   interface UndoEntry {
     sellers: (SellerRecord & { originalIndex: number })[];
     timestamp: number;
   }
   ```

9. **Verify SellersGridProps:**
   The `refreshTrigger` prop is still used (triggers refetch). `onSellerChange` is still called to notify parent. `newSellerIds` prop is still used for highlight animation. No props changes needed.
  </action>
  <verify>
    - Grep: ZERO `setSellers` calls remain in sellers-grid.tsx.
    - Grep: ZERO `fetch\(.*API_BASE` calls remain in sellers-grid.tsx.
    - Grep: ZERO `supabase.auth.getSession` calls remain in sellers-grid.tsx.
    - Grep: ZERO `createClient` imports remain in sellers-grid.tsx.
    - Grep confirms: `flagMutation`, `updateMutation`, `deleteMutation` all used.
    - Grep confirms: `sellerApi` imported for add operations.
    - Grep confirms: `db.sellers` used for IndexedDB operations.
    - `npx tsc --noEmit` passes.
    - `npm run build` succeeds.
  </verify>
  <done>
    - All seller mutations route through mutation hooks or sellerApi.
    - No direct fetch() calls remain in SellersGrid.
    - No setSellers() calls remain (useLiveQuery is sole source of truth).
    - Export flag-on-export persists to IndexedDB via flagMutation.
    - Undo simplified to single-level per CONTEXT.md (no redo).
    - Add seller uses sellerApi directly + refetch for IndexedDB sync.
    - Edit seller uses updateMutation hook.
    - Delete seller uses deleteMutation hook.
    - SellersGrid is fully offline-capable for mutations.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` and `npm run build` from apps/web/ both pass.
- Grep: ZERO occurrences of `setSellers`, `createClient`, `API_BASE`, or `supabase.auth` in sellers-grid.tsx.
- All data flows through IndexedDB: reads via useSyncSellers/useLiveQuery, writes via mutation hooks + db.sellers.
- Undo works for delete (single-level).
- Export flagging persists across page reload.
</verification>

<success_criteria>
- Complete data layer migration: no direct fetch, no setSellers, no createClient.
- All CRUD operations: add (sellerApi), edit (updateMutation), delete (deleteMutation), flag (flagMutation).
- Single-level undo for delete operations.
- Export flag-on-export persists to IndexedDB.
- Offline mutation queuing works for all operations.
- All existing interactions preserved: drag select, flag paint, shift-click, Ctrl+A, Ctrl+C, Ctrl+Z, hover detail.
</success_criteria>

<output>
After completion, create `.planning/phases/28-collection-storage-rendering-infrastructure/28-05-SUMMARY.md`
</output>
