---
phase: 11-collection-bug-fixes-polish
plan: 04
type: execute
wave: 2
depends_on:
  - "11-03"
files_modified:
  - apps/web/src/components/admin/collection/sellers-grid.tsx
autonomous: true

must_haves:
  truths:
    - "Deleting sellers shows success toast with Undo option"
    - "Ctrl+Z undoes last delete within session"
    - "Ctrl+Shift+Z redoes undone delete"
    - "Undo restores sellers to original grid position"
    - "Toast auto-dismisses after 5 seconds"
  artifacts:
    - path: "apps/web/src/components/admin/collection/sellers-grid.tsx"
      provides: "Undo/redo functionality for delete operations"
      contains: "undoStack"
  key_links:
    - from: "Ctrl+Z handler"
      to: "undoStack state"
      via: "pop and restore"
      pattern: "undoStack"
---

<objective>
Add undo/redo capability for seller deletions

Purpose: Implement immediate delete with undo capability per CONTEXT.md - no confirmation dialog, toast with undo, keyboard shortcuts
Output: Reversible delete operations with session-scoped undo/redo stack
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-collection-bug-fixes-polish/11-CONTEXT.md
@.planning/phases/11-collection-bug-fixes-polish/11-RESEARCH.md
@apps/web/src/components/admin/collection/sellers-grid.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add undo/redo state and toast on delete</name>
  <files>apps/web/src/components/admin/collection/sellers-grid.tsx</files>
  <action>
  Per CONTEXT.md:
  - "No confirmation dialog - immediate delete with undo capability"
  - "Show success toast with Undo option (auto-dismiss 5 seconds)"
  - "Unlimited undo within session (cleared on page close)"
  - "Undo actions logged in history"
  - "Restored sellers return to original position in grid"

  1. Add undo/redo stack state near the top of the component:
  ```typescript
  // Undo/redo stacks for delete operations
  interface DeletedSeller extends Seller {
    originalIndex: number;
  }
  interface UndoEntry {
    sellers: DeletedSeller[];
    timestamp: number;
  }
  const [undoStack, setUndoStack] = useState<UndoEntry[]>([]);
  const [redoStack, setRedoStack] = useState<UndoEntry[]>([]);
  ```

  2. Modify handleBulkDelete to push to undo stack and show toast:
  ```typescript
  const handleBulkDelete = async () => {
    if (selectedIds.size === 0) return;

    const { data: { session } } = await supabase.auth.getSession();
    if (!session) return;

    const idsArray = Array.from(selectedIds);

    // Capture deleted sellers with their original positions for undo
    const deletedSellers: DeletedSeller[] = idsArray.map(id => {
      const originalIndex = filteredSellers.findIndex(s => s.id === id);
      const seller = sellers.find(s => s.id === id)!;
      return { ...seller, originalIndex };
    });

    // Push to undo stack
    setUndoStack(prev => [...prev, { sellers: deletedSellers, timestamp: Date.now() }]);
    setRedoStack([]); // Clear redo stack on new action

    // Optimistically remove from UI
    setSellers(prev => prev.filter(s => !selectedIds.has(s.id)));
    setSelectedIds(new Set());

    // Show toast with undo option
    toast.success(
      `Deleted ${deletedSellers.length} seller${deletedSellers.length > 1 ? 's' : ''}`,
      {
        duration: 5000,
        action: {
          label: 'Undo',
          onClick: () => handleUndo(),
        },
      }
    );

    // Perform actual delete (fire and forget, undo will re-add if needed)
    try {
      if (idsArray.length === 1) {
        await fetch(`${API_BASE}/sellers/${idsArray[0]}`, {
          method: "DELETE",
          headers: { Authorization: `Bearer ${session.access_token}` },
        });
      } else {
        await fetch(`${API_BASE}/sellers/bulk/delete`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${session.access_token}`,
          },
          body: JSON.stringify({ ids: idsArray }),
        });
      }
      onSellerChange();
    } catch (e) {
      console.error("Delete failed:", e);
      // Restore on failure
      setSellers(prev => [...prev, ...deletedSellers]);
      setUndoStack(prev => prev.slice(0, -1));
      toast.error("Failed to delete sellers");
    }
  };
  ```

  3. Add handleUndo function:
  ```typescript
  const handleUndo = useCallback(async () => {
    if (undoStack.length === 0) return;

    const lastEntry = undoStack[undoStack.length - 1];

    // Move to redo stack
    setUndoStack(prev => prev.slice(0, -1));
    setRedoStack(prev => [...prev, lastEntry]);

    // Restore sellers to UI (optimistic)
    setSellers(prev => {
      const restored = [...prev];
      // Sort by original index to insert in correct positions
      const sorted = [...lastEntry.sellers].sort((a, b) => a.originalIndex - b.originalIndex);
      for (const seller of sorted) {
        // Insert at original position or at end if position is beyond current length
        const idx = Math.min(seller.originalIndex, restored.length);
        restored.splice(idx, 0, seller);
      }
      return restored;
    });

    // Re-add to backend
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) return;

      const names = lastEntry.sellers.map(s => s.display_name);
      if (names.length === 1) {
        await fetch(`${API_BASE}/sellers`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${session.access_token}`,
          },
          body: JSON.stringify({ name: names[0] }),
        });
      } else {
        await fetch(`${API_BASE}/sellers/bulk`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${session.access_token}`,
          },
          body: JSON.stringify({ names }),
        });
      }
      toast.success(`Restored ${names.length} seller${names.length > 1 ? 's' : ''}`);
      onSellerChange();
      fetchSellers(); // Refresh to get new IDs
    } catch (e) {
      console.error("Undo failed:", e);
      toast.error("Failed to restore sellers");
    }
  }, [undoStack, supabase.auth, onSellerChange, fetchSellers]);
  ```

  4. Add handleRedo function (similar structure, moves from redo to undo, re-deletes):
  ```typescript
  const handleRedo = useCallback(async () => {
    if (redoStack.length === 0) return;

    const lastEntry = redoStack[redoStack.length - 1];

    // Move to undo stack
    setRedoStack(prev => prev.slice(0, -1));
    setUndoStack(prev => [...prev, lastEntry]);

    // Remove from UI
    const idsToRemove = new Set(lastEntry.sellers.map(s => s.id));
    setSellers(prev => prev.filter(s => !idsToRemove.has(s.id)));

    // Delete from backend
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) return;

      const ids = lastEntry.sellers.map(s => s.id);
      await fetch(`${API_BASE}/sellers/bulk/delete`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${session.access_token}`,
        },
        body: JSON.stringify({ ids }),
      });
      toast.success(`Re-deleted ${ids.length} seller${ids.length > 1 ? 's' : ''}`);
      onSellerChange();
    } catch (e) {
      console.error("Redo failed:", e);
      toast.error("Failed to re-delete sellers");
    }
  }, [redoStack, supabase.auth, onSellerChange]);
  ```

  Import toast from sonner if not already imported:
  ```typescript
  import { toast } from "sonner";
  ```
  </action>
  <verify>
  Run `npm run lint` in apps/web to verify no syntax errors.
  Verify toast import is present. Verify handleUndo and handleRedo functions exist.
  </verify>
  <done>
  Delete shows toast with undo button, undo/redo stacks track deleted sellers
  </done>
</task>

<task type="auto">
  <name>Task 2: Add keyboard shortcuts for undo/redo</name>
  <files>apps/web/src/components/admin/collection/sellers-grid.tsx</files>
  <action>
  Per CONTEXT.md: "Ctrl+Z to undo, Ctrl+Shift+Z to redo"

  Add a useEffect for keyboard shortcuts:
  ```typescript
  // Ctrl+Z for undo, Ctrl+Shift+Z for redo
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Skip if typing in input
      const activeEl = document.activeElement;
      const isInputFocused = activeEl?.tagName === 'INPUT' || activeEl?.tagName === 'TEXTAREA';
      if (isInputFocused) return;

      if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        if (e.shiftKey) {
          // Ctrl+Shift+Z = Redo
          e.preventDefault();
          handleRedo();
        } else {
          // Ctrl+Z = Undo
          e.preventDefault();
          handleUndo();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleUndo, handleRedo]);
  ```

  Make sure handleUndo and handleRedo are wrapped in useCallback (from Task 1) so they can be dependencies.
  </action>
  <verify>
  Run `npm run lint` in apps/web to verify no syntax errors.
  Test in browser: delete sellers, press Ctrl+Z to undo, press Ctrl+Shift+Z to redo.
  </verify>
  <done>
  Ctrl+Z undoes last delete, Ctrl+Shift+Z redoes, unlimited undo within session
  </done>
</task>

</tasks>

<verification>
- [ ] Deleting sellers shows toast with "Undo" button
- [ ] Toast auto-dismisses after 5 seconds
- [ ] Clicking Undo in toast restores sellers
- [ ] Ctrl+Z undoes last delete
- [ ] Ctrl+Shift+Z redoes undone delete
- [ ] Multiple undo/redo operations work correctly
- [ ] No lint errors
</verification>

<success_criteria>
- Immediate delete with no confirmation dialog
- Toast notification with undo option (5s auto-dismiss)
- Keyboard shortcuts work (Ctrl+Z, Ctrl+Shift+Z)
- Undo restores sellers (approximately to original position)
</success_criteria>

<output>
After completion, create `.planning/phases/11-collection-bug-fixes-polish/11-04-SUMMARY.md`
</output>
