---
phase: 03-extension-auth-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/extension/service-worker.js
autonomous: true

must_haves:
  truths:
    - "Extension stores clock-in state and JWT in chrome.storage.local"
    - "Clock-in request validates access code against backend and stores response"
    - "Inactivity timeout clocks user out after 1 hour"
    - "Session resumes on browser restart if JWT valid and not expired"
  artifacts:
    - path: "packages/extension/service-worker.js"
      provides: "Access code auth state management, clock-in/out handlers, inactivity alarms"
      exports: ["handleClockIn", "clockOut", "startInactivityTimer", "checkSessionOnStartup"]
  key_links:
    - from: "service-worker.js handleClockIn"
      to: "POST /access-codes/validate"
      via: "fetch request"
      pattern: "fetch.*access-codes/validate"
    - from: "service-worker.js inactivity alarm"
      to: "clockOut function"
      via: "chrome.alarms.onAlarm listener"
      pattern: "chrome\\.alarms\\.onAlarm"
---

<objective>
Add access code authentication ("clock-in") state management to the extension service worker.

Purpose: Implements the backend integration for EXT-01/EXT-02/EXT-04 - validates access codes against the backend, stores JWT and user context, manages session lifecycle with inactivity timeout.

Output: Service worker with clock-in/out handlers, state persistence, and inactivity timeout management.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-extension-auth-flow/03-CONTEXT.md
@.planning/phases/03-extension-auth-flow/03-RESEARCH.md
@packages/extension/service-worker.js
@apps/api/src/app/routers/access_codes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend state schema and add auth state management</name>
  <files>packages/extension/service-worker.js</files>
  <action>
    Extend the getState() function to include new auth-related fields in the storage schema:

    ```javascript
    // Add to getState() storage keys:
    'auth_state',           // 'needs_clock_in' | 'clocked_in' | 'clocked_out'
    'access_token',         // JWT from validation
    'access_token_expires_at', // Unix timestamp
    'user_context',         // { id, name, email, user_type, org_id, is_admin }
    'roles',                // Array from validation response
    'effective_permission_keys', // Flattened permissions
    'rbac_version',         // For cache invalidation
    'last_activity_at',     // Unix timestamp for inactivity tracking
    'session_started_at',   // For future time tracking
    'clock_out_reason',     // 'manual' | 'inactivity' | 'code_rotated' | 'token_expired'
    ```

    Add defaults in getState() return:
    - auth_state: data.auth_state || null (null = not yet needed)
    - access_token: data.access_token || null
    - access_token_expires_at: data.access_token_expires_at || null
    - user_context: data.user_context || null
    - roles: data.roles || []
    - effective_permission_keys: data.effective_permission_keys || []
    - rbac_version: data.rbac_version || null
    - last_activity_at: data.last_activity_at || null
    - session_started_at: data.session_started_at || null
    - clock_out_reason: data.clock_out_reason || null

    Update buildStateSummary() to include auth fields for side panel:
    - auth_state (string)
    - user_context (object, safe to expose)
    - clock_out_reason (string)
    - session_started_at (number)

    Do NOT include access_token or sensitive data in summary.
  </action>
  <verify>Read the file and confirm getState() includes all new fields with proper defaults.</verify>
  <done>State schema extended with auth_state, access_token, user_context, roles, permissions, activity timestamps, and clock_out_reason fields.</done>
</task>

<task type="auto">
  <name>Task 2: Add clock-in handler with validation and inactivity management</name>
  <files>packages/extension/service-worker.js</files>
  <action>
    Add constants for inactivity timing:

    ```javascript
    const INACTIVITY_TIMEOUT_MS = 60 * 60 * 1000; // 1 hour
    const INACTIVITY_WARNING_MS = 5 * 60 * 1000;  // 5 minutes before timeout
    ```

    Add validateAccessCode function (similar pattern to existing apiRequest but for public endpoint):

    ```javascript
    async function validateAccessCode(code) {
      try {
        const response = await fetch(`${API_BASE}/access-codes/validate`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code }),
        });

        if (!response.ok) {
          const error = await response.json().catch(() => ({}));
          const detail = error.detail || {};
          return {
            ok: false,
            error_code: detail.error_code || 'UNKNOWN',
            message: detail.message || 'Validation failed',
            retry_after: detail.retry_after || null,
          };
        }

        const data = await response.json();
        return { ok: true, data };
      } catch (err) {
        console.warn('[SW] validateAccessCode error:', err.message);
        return { ok: false, error_code: 'NETWORK_ERROR', message: 'Connection error' };
      }
    }
    ```

    Add handleClockIn function:

    ```javascript
    async function handleClockIn(code, port) {
      // Notify UI of validation start
      port.postMessage({ type: 'CLOCK_IN_STARTED' });

      const result = await validateAccessCode(code);

      if (!result.ok) {
        port.postMessage({
          type: 'CLOCK_IN_FAILED',
          error_code: result.error_code,
          message: result.message,
          retry_after: result.retry_after,
        });
        return;
      }

      const { access_token, expires_in, user, roles, effective_permission_keys, rbac_version } = result.data;

      const now = Date.now();
      await updateState({
        auth_state: 'clocked_in',
        access_token,
        access_token_expires_at: now + (expires_in * 1000),
        user_context: user,
        roles,
        effective_permission_keys,
        rbac_version,
        session_started_at: now,
        last_activity_at: now,
        clock_out_reason: null,
      });

      // Start inactivity timer
      await startInactivityTimer();

      port.postMessage({ type: 'CLOCK_IN_SUCCESS' });
      console.log('[SW] Clocked in user:', user.id);
    }
    ```

    Add startInactivityTimer function:

    ```javascript
    async function startInactivityTimer() {
      await chrome.alarms.clear('inactivity_warning');
      await chrome.alarms.clear('inactivity_timeout');

      const now = Date.now();
      await chrome.storage.local.set({ last_activity_at: now });

      // Warning 5 minutes before timeout
      chrome.alarms.create('inactivity_warning', {
        when: now + INACTIVITY_TIMEOUT_MS - INACTIVITY_WARNING_MS
      });

      // Timeout after 1 hour
      chrome.alarms.create('inactivity_timeout', {
        when: now + INACTIVITY_TIMEOUT_MS
      });
    }
    ```

    Add resetInactivityTimer function:

    ```javascript
    async function resetInactivityTimer() {
      const state = await getState();
      if (state.auth_state !== 'clocked_in') return;
      await startInactivityTimer();
    }
    ```

    Add clockOut function:

    ```javascript
    async function clockOut(reason) {
      await updateState({
        auth_state: 'clocked_out',
        access_token: null,
        access_token_expires_at: null,
        user_context: null,
        roles: [],
        effective_permission_keys: [],
        session_started_at: null,
        clock_out_reason: reason,
      });

      await chrome.alarms.clear('inactivity_warning');
      await chrome.alarms.clear('inactivity_timeout');

      // Broadcast state change to side panels
      broadcastState();

      console.log('[SW] Clocked out:', reason);
    }
    ```

    Add alarm handlers in the existing chrome.alarms.onAlarm listener:

    ```javascript
    case 'inactivity_warning':
      // Broadcast warning to side panels
      for (const port of sidePanelPorts) {
        try {
          port.postMessage({ type: 'INACTIVITY_WARNING', minutes_remaining: 5 });
        } catch (e) {
          // Port may be disconnected
        }
      }
      break;

    case 'inactivity_timeout':
      clockOut('inactivity');
      break;
    ```

    Add session check on startup in initialize():

    ```javascript
    // Check session validity on startup (after existing initialization)
    await checkSessionOnStartup();
    ```

    Add checkSessionOnStartup function:

    ```javascript
    async function checkSessionOnStartup() {
      const state = await getState();

      // Not clocked in, nothing to check
      if (state.auth_state !== 'clocked_in') {
        return;
      }

      // Check token expiry
      if (!state.access_token || !state.access_token_expires_at) {
        await clockOut('token_expired');
        return;
      }

      const now = Date.now();
      if (now >= state.access_token_expires_at - 30000) { // 30s buffer
        await clockOut('token_expired');
        return;
      }

      // Check inactivity (alarm may not have fired during shutdown)
      if (state.last_activity_at) {
        const elapsed = now - state.last_activity_at;
        if (elapsed >= INACTIVITY_TIMEOUT_MS) {
          await clockOut('inactivity');
          return;
        }
      }

      // Session valid, restart inactivity timer
      await startInactivityTimer();
      console.log('[SW] Session resumed from startup');
    }
    ```

    Add message handlers in handleSidePanelMessage:

    ```javascript
    case 'CLOCK_IN':
      if (msg.code) {
        handleClockIn(msg.code, port);
      }
      break;

    case 'CLOCK_OUT':
      clockOut('manual');
      break;

    case 'RESET_ACTIVITY':
      resetInactivityTimer();
      break;
    ```

    Modify existing pairing approval flow: After pairing approval (when agent_id is set), also set auth_state to 'needs_clock_in':

    In pollPairingStatus(), after successful approval:
    ```javascript
    auth_state: 'needs_clock_in',  // Add this to the updateState call
    ```

    Same for requestPairing() auto-approval case.
  </action>
  <verify>
    Read the file and confirm:
    1. validateAccessCode function exists and handles all error types
    2. handleClockIn, clockOut, startInactivityTimer, resetInactivityTimer exist
    3. checkSessionOnStartup handles token expiry and inactivity checks
    4. Alarm handlers for inactivity_warning and inactivity_timeout exist
    5. CLOCK_IN, CLOCK_OUT, RESET_ACTIVITY message handlers exist
  </verify>
  <done>Clock-in handler validates code against backend, stores JWT and context, starts inactivity timer; clock-out clears auth state; session recovered on startup.</done>
</task>

</tasks>

<verification>
After completing both tasks:
1. Read packages/extension/service-worker.js and confirm all new functions exist
2. Verify getState() includes all auth fields
3. Verify buildStateSummary() exposes auth_state, user_context, clock_out_reason
4. Verify alarm listener handles inactivity_warning and inactivity_timeout
5. Verify handleSidePanelMessage handles CLOCK_IN, CLOCK_OUT, RESET_ACTIVITY
6. Verify pairing approval sets auth_state to 'needs_clock_in'
</verification>

<success_criteria>
- State schema extended with auth fields (auth_state, access_token, user_context, etc.)
- validateAccessCode function calls POST /access-codes/validate
- handleClockIn stores response in state and starts inactivity timer
- clockOut clears auth state and alarms
- Inactivity alarms created and handled (warning at 55min, timeout at 60min)
- Session validity checked on startup
- Message handlers for CLOCK_IN, CLOCK_OUT, RESET_ACTIVITY
- Pairing approval sets auth_state to 'needs_clock_in'
</success_criteria>

<output>
After completion, create `.planning/phases/03-extension-auth-flow/03-01-SUMMARY.md`
</output>
