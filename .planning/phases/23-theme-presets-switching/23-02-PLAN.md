---
phase: 23-theme-presets-switching
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - apps/web/src/components/providers/theme-provider.tsx
  - apps/web/src/app/layout.tsx
autonomous: true

must_haves:
  truths:
    - "ThemeProvider is configured with all 5 theme options (system, midnight, dawn, slate, carbon)"
    - "System theme maps OS dark preference to Carbon and OS light preference to Dawn"
    - "Theme persists across browser sessions via localStorage (automatic with next-themes)"
    - "Sonner toast notifications respect the current theme's light/dark mode"
    - "No flash of unstyled content on page load"
  artifacts:
    - path: "apps/web/src/components/providers/theme-provider.tsx"
      provides: "Multi-theme provider with system preference mapping"
      exports: ["ThemeProvider"]
    - path: "apps/web/src/app/layout.tsx"
      provides: "Root layout with updated ThemeProvider config and themed Toaster"
      contains: "themes={["
  key_links:
    - from: "apps/web/src/components/providers/theme-provider.tsx"
      to: "apps/web/src/app/globals.css"
      via: "data-theme attribute maps to CSS variable blocks"
      pattern: "data-theme"
    - from: "apps/web/src/app/layout.tsx"
      to: "apps/web/src/components/providers/theme-provider.tsx"
      via: "ThemeProvider component with themes prop"
      pattern: "ThemeProvider"
---

<objective>
Update ThemeProvider to support all 5 theme options with system preference mapping (OS dark -> Carbon, OS light -> Dawn), and update layout.tsx to configure the provider and make Sonner toasts theme-aware.

Purpose: Enables the theme system to recognize and apply all 4 named themes plus system auto-detection. Without this, the CSS variables from Plan 01 have no way to be activated.

Output: Updated theme-provider.tsx with system mapping logic, updated layout.tsx with multi-theme config and themed Toaster.
</objective>

<execution_context>
@C:\Users\User\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\User\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-theme-presets-switching/23-CONTEXT.md
@.planning/phases/23-theme-presets-switching/23-RESEARCH.md
@apps/web/src/components/providers/theme-provider.tsx
@apps/web/src/app/layout.tsx
@apps/web/src/lib/themes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ThemeProvider with multi-theme support and system preference mapping</name>
  <files>apps/web/src/components/providers/theme-provider.tsx</files>
  <action>
Rewrite theme-provider.tsx to:

1. **Keep the ThemeProvider wrapper** around NextThemesProvider, passing through all props.

2. **Add a `SystemThemeMapper` child component** that handles the OS dark/light -> Carbon/Dawn mapping:
   - Uses `useTheme()` from next-themes to get `theme` and `setTheme`
   - Only activates when `theme === "system"`
   - On mount and on OS preference change, reads `window.matchMedia("(prefers-color-scheme: dark)")`
   - If OS is dark -> sets `data-theme` attribute on `<html>` to `"carbon"` (NOT via setTheme -- that would override the "system" selection)
   - If OS is light -> sets `data-theme` attribute on `<html>` to `"dawn"`
   - Also sets the `class` attribute on `<html>` to match (dark/light class for Tailwind dark variant)
   - Cleans up matchMedia listener on unmount or when theme changes away from "system"

**Important implementation detail for system theme mapping:**
next-themes' built-in system detection maps to "light"/"dark" which don't match our custom theme names. We need to intercept and override:

```tsx
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider, useTheme } from "next-themes"

function SystemThemeMapper() {
  const { theme } = useTheme()

  React.useEffect(() => {
    if (theme !== "system") return

    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)")

    const applySystemTheme = (isDark: boolean) => {
      const html = document.documentElement
      const mappedTheme = isDark ? "carbon" : "dawn"
      html.setAttribute("data-theme", mappedTheme)
      // Update class for Tailwind dark variant
      if (isDark) {
        html.classList.add("dark")
      } else {
        html.classList.remove("dark")
      }
    }

    // Apply immediately
    applySystemTheme(mediaQuery.matches)

    // Listen for OS changes
    const handler = (e: MediaQueryListEvent) => applySystemTheme(e.matches)
    mediaQuery.addEventListener("change", handler)

    return () => mediaQuery.removeEventListener("change", handler)
  }, [theme])

  return null
}

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return (
    <NextThemesProvider {...props}>
      <SystemThemeMapper />
      {children}
    </NextThemesProvider>
  )
}
```

**Key constraint:** When user selects "system", next-themes stores "system" in localStorage. Our SystemThemeMapper reads the OS preference and directly manipulates the DOM attributes (data-theme, class) to apply the correct named theme. This approach avoids calling `setTheme()` which would overwrite the "system" selection in localStorage.

**Fallback:** If no OS preference signal is detectable (mediaQuery.matches returns false by default), map to Carbon (per CONTEXT.md: "Brand-new user with no OS preference signal defaults to Carbon").
  </action>
  <verify>
1. Confirm ThemeProvider still exports and wraps NextThemesProvider
2. Confirm SystemThemeMapper component exists inside ThemeProvider
3. Verify the effect only runs when theme === "system"
4. TypeScript compiles without errors
  </verify>
  <done>
ThemeProvider wraps NextThemesProvider with SystemThemeMapper that maps OS dark -> Carbon, OS light -> Dawn via DOM attribute manipulation when "system" theme is selected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update layout.tsx with multi-theme config and themed Toaster</name>
  <files>apps/web/src/app/layout.tsx</files>
  <action>
Update layout.tsx with these changes:

**1. Update ThemeProvider props:**
Change from:
```tsx
<ThemeProvider
  attribute={["class", "data-theme"]}
  defaultTheme="dark"
  enableSystem={false}
  disableTransitionOnChange
>
```
To:
```tsx
<ThemeProvider
  attribute={["class", "data-theme"]}
  defaultTheme="system"
  enableSystem={true}
  themes={["system", "midnight", "dawn", "slate", "carbon"]}
  disableTransitionOnChange={false}
>
```

Key changes:
- `defaultTheme="system"` -- first-time visitors get OS-matched theme
- `enableSystem={true}` -- enables system preference detection
- `themes={[...]}` -- declares all available theme names
- `disableTransitionOnChange={false}` -- allows View Transitions API to animate theme changes (the CSS handles the actual animation, this just prevents next-themes from adding a style tag that blocks transitions)

**2. Extract Toaster into a themed client component:**
The `<Toaster>` component needs to receive the resolved theme to properly style toasts. Since layout.tsx is a Server Component, create a small inline or nearby client wrapper.

Option A (simplest): Create a `ThemedToaster` component in the same file or import from a separate file. Since layout.tsx already imports from client providers, add `ThemedToaster` as a new client component file:

Create `apps/web/src/components/providers/themed-toaster.tsx`:
```tsx
"use client"

import { useTheme } from "next-themes"
import { Toaster } from "sonner"

export function ThemedToaster() {
  const { resolvedTheme, theme } = useTheme()

  // Determine if current theme is dark for Sonner
  // resolvedTheme may be "light" or "dark" for system, or our custom theme names
  const isDark =
    theme === "midnight" ||
    theme === "slate" ||
    theme === "carbon" ||
    resolvedTheme === "dark"

  return (
    <Toaster
      position="top-right"
      richColors
      duration={5000}
      closeButton
      theme={isDark ? "dark" : "light"}
    />
  )
}
```

Then in layout.tsx, replace:
```tsx
<Toaster position="top-right" richColors duration={5000} closeButton />
```
With:
```tsx
<ThemedToaster />
```

And add the import:
```tsx
import { ThemedToaster } from "@/components/providers/themed-toaster"
```

Remove the direct `Toaster` import from sonner since it's now handled by ThemedToaster.

**Note:** `files_modified` includes layout.tsx and theme-provider.tsx, but this task also creates themed-toaster.tsx. That's acceptable as it's a small supporting file.
  </action>
  <verify>
1. Confirm ThemeProvider in layout.tsx has `themes` prop with 5 values
2. Confirm `defaultTheme="system"` and `enableSystem={true}`
3. Confirm ThemedToaster replaces direct Toaster usage
4. Confirm `disableTransitionOnChange={false}` (or removed, since false is default)
5. Run `npx next build` or `npx next lint` to verify no import errors
  </verify>
  <done>
layout.tsx configures ThemeProvider with all 5 themes, system as default, and system detection enabled. ThemedToaster component passes resolved dark/light mode to Sonner for proper toast styling (SWITCH-04). FOUC prevention maintained via next-themes' blocking script.
  </done>
</task>

</tasks>

<verification>
1. ThemeProvider declares all 5 theme options
2. System preference detection is enabled
3. SystemThemeMapper correctly maps OS dark -> Carbon, OS light -> Dawn
4. Sonner toasts receive correct theme (dark/light) based on active theme
5. No flash on page load (next-themes blocking script still active)
6. localStorage persistence works automatically (next-themes default behavior)
</verification>

<success_criteria>
- PRESET-05 (system preference detection) implemented via SystemThemeMapper + enableSystem
- PRESET-06 (localStorage persistence) maintained via next-themes default behavior
- SWITCH-04 (Sonner toast theming) implemented via ThemedToaster
- Theme switching foundation ready for UI components in Plan 03
</success_criteria>

<output>
After completion, create `.planning/phases/23-theme-presets-switching/23-02-SUMMARY.md`
</output>
