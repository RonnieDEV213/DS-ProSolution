---
phase: 16-transport-layer
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - apps/api/src/app/routers/sync.py
  - apps/api/src/app/routers/__init__.py
  - apps/api/src/app/main.py
  - apps/api/src/app/models.py
autonomous: true

must_haves:
  truths:
    - "GET /sync/records returns cursor-paginated records with next_cursor"
    - "GET /sync/accounts returns cursor-paginated accounts with next_cursor"
    - "GET /sync/sellers returns cursor-paginated sellers with next_cursor"
    - "Passing cursor continues pagination from last position"
    - "has_more is false on final page"
    - "updated_since filter returns only records updated after timestamp"
    - "status filter returns only records with matching status"
    - "Invalid cursor returns 400 with INVALID_CURSOR error"
  artifacts:
    - path: "apps/api/src/app/routers/sync.py"
      provides: "Sync endpoints with cursor pagination"
      exports: ["router"]
    - path: "apps/api/src/app/models.py"
      provides: "Sync response models"
      contains: ["RecordSyncResponse", "AccountSyncResponse", "SellerSyncResponse"]
  key_links:
    - from: "apps/api/src/app/routers/sync.py"
      to: "apps/api/src/app/pagination.py"
      via: "import"
      pattern: "from app\\.pagination import"
    - from: "apps/api/src/app/routers/sync.py"
      to: "supabase.table"
      via: "database query"
      pattern: "supabase\\.table\\("
    - from: "apps/api/src/app/main.py"
      to: "sync_router"
      via: "router registration"
      pattern: "app\\.include_router\\(sync_router\\)"
---

<objective>
Create sync router with cursor-paginated endpoints for bookkeeping_records, accounts, and sellers.

Purpose: Provide transport layer endpoints that support efficient cursor-based pagination for client sync. These endpoints use the composite indexes created in Phase 15 to achieve O(log n) query performance regardless of page depth.

Output: /sync/records, /sync/accounts, /sync/sellers endpoints with cursor pagination, filtering, and sorting
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-transport-layer/16-RESEARCH.md
@.planning/phases/16-transport-layer/16-01-SUMMARY.md
@apps/api/src/app/routers/records.py
@apps/api/src/app/models.py
@apps/api/src/app/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sync response models to models.py</name>
  <files>apps/api/src/app/models.py</files>
  <action>
Add specialized sync response models to `apps/api/src/app/models.py`.

Add these models after the CursorPage definition (from Plan 16-01):

```python
class RecordSyncItem(BaseModel):
    """Record data for sync (subset of RecordResponse for efficiency)."""
    id: str
    account_id: str
    ebay_order_id: str
    sale_date: date
    item_name: str
    qty: int
    sale_price_cents: int
    ebay_fees_cents: Optional[int] = None
    amazon_price_cents: Optional[int] = None
    amazon_tax_cents: Optional[int] = None
    amazon_shipping_cents: Optional[int] = None
    amazon_order_id: Optional[str] = None
    status: BookkeepingStatus
    return_label_cost_cents: Optional[int] = None
    updated_at: datetime
    deleted_at: Optional[datetime] = None  # For sync: null = active, set = deleted

    @classmethod
    def from_db(cls, data: dict) -> "RecordSyncItem":
        """Create RecordSyncItem from database row."""
        return cls(
            id=data["id"],
            account_id=data["account_id"],
            ebay_order_id=data["ebay_order_id"],
            sale_date=data["sale_date"],
            item_name=data["item_name"],
            qty=data["qty"],
            sale_price_cents=data["sale_price_cents"],
            ebay_fees_cents=data.get("ebay_fees_cents"),
            amazon_price_cents=data.get("amazon_price_cents"),
            amazon_tax_cents=data.get("amazon_tax_cents"),
            amazon_shipping_cents=data.get("amazon_shipping_cents"),
            amazon_order_id=data.get("amazon_order_id"),
            status=data["status"],
            return_label_cost_cents=data.get("return_label_cost_cents"),
            updated_at=data["updated_at"],
            deleted_at=data.get("deleted_at"),
        )


class RecordSyncResponse(CursorPage[RecordSyncItem]):
    """Paginated records for sync."""
    pass


class AccountSyncItem(BaseModel):
    """Account data for sync."""
    id: str
    account_code: str
    name: Optional[str] = None
    updated_at: datetime
    deleted_at: Optional[datetime] = None

    @classmethod
    def from_db(cls, data: dict) -> "AccountSyncItem":
        """Create AccountSyncItem from database row."""
        return cls(
            id=data["id"],
            account_code=data["account_code"],
            name=data.get("name"),
            updated_at=data["updated_at"],
            deleted_at=data.get("deleted_at"),
        )


class AccountSyncResponse(CursorPage[AccountSyncItem]):
    """Paginated accounts for sync."""
    pass


class SellerSyncItem(BaseModel):
    """Seller data for sync."""
    id: str
    display_name: str
    normalized_name: str
    platform: str
    platform_id: Optional[str] = None
    times_seen: int
    flagged: bool = False
    updated_at: datetime
    deleted_at: Optional[datetime] = None

    @classmethod
    def from_db(cls, data: dict) -> "SellerSyncItem":
        """Create SellerSyncItem from database row."""
        return cls(
            id=data["id"],
            display_name=data["display_name"],
            normalized_name=data["normalized_name"],
            platform=data["platform"],
            platform_id=data.get("platform_id"),
            times_seen=data["times_seen"],
            flagged=data.get("flagged", False),
            updated_at=data["updated_at"],
            deleted_at=data.get("deleted_at"),
        )


class SellerSyncResponse(CursorPage[SellerSyncItem]):
    """Paginated sellers for sync."""
    pass
```

Key decisions:
- Include updated_at and deleted_at for sync tracking
- Lightweight items (no computed fields like profit_cents)
- from_db class methods for consistent mapping
  </action>
  <verify>
Run Python syntax check:
```bash
cd apps/api && python -c "from app.models import RecordSyncResponse, AccountSyncResponse, SellerSyncResponse; print('Sync models imported OK')"
```
  </verify>
  <done>RecordSyncItem/Response, AccountSyncItem/Response, SellerSyncItem/Response models added to models.py</done>
</task>

<task type="auto">
  <name>Task 2: Create sync router with cursor-paginated endpoints</name>
  <files>apps/api/src/app/routers/sync.py</files>
  <action>
Create `apps/api/src/app/routers/sync.py` with cursor-paginated endpoints:

```python
"""Sync endpoints with cursor-based pagination for client sync."""

import logging
from datetime import datetime
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Query

from app.auth import require_permission_key
from app.database import get_supabase_for_user
from app.models import (
    BookkeepingStatus,
    RecordSyncItem,
    RecordSyncResponse,
    AccountSyncItem,
    AccountSyncResponse,
    SellerSyncItem,
    SellerSyncResponse,
)
from app.pagination import encode_cursor, decode_cursor

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/sync", tags=["sync"])


def _apply_cursor_filter(query, cursor: Optional[str], table_has_account_scope: bool = False):
    """
    Apply cursor filter for DESC ordering pagination.

    For ORDER BY updated_at DESC, id DESC, we want records where:
    (updated_at, id) < (cursor_updated_at, cursor_id)

    Supabase-py doesn't support tuple comparison, so we use OR pattern:
    updated_at < cursor_updated_at OR (updated_at = cursor_updated_at AND id < cursor_id)
    """
    if not cursor:
        return query

    try:
        cursor_updated_at, cursor_id = decode_cursor(cursor)
    except ValueError:
        raise HTTPException(
            status_code=400,
            detail={"code": "INVALID_CURSOR", "message": "The provided cursor is invalid or malformed"},
        )

    # Compound cursor comparison for DESC ordering
    # Format: updated_at.lt.{value},and(updated_at.eq.{value},id.lt.{id})
    cursor_filter = (
        f"updated_at.lt.{cursor_updated_at.isoformat()},"
        f"and(updated_at.eq.{cursor_updated_at.isoformat()},id.lt.{cursor_id})"
    )
    return query.or_(cursor_filter)


def _build_response(items: list, limit: int, item_class):
    """Build paginated response with has_more detection."""
    has_more = len(items) > limit
    if has_more:
        items = items[:limit]

    # Build next cursor from last item
    next_cursor = None
    if has_more and items:
        last = items[-1]
        # Handle both dict and model instances
        if isinstance(last, dict):
            updated_at = last["updated_at"]
            if isinstance(updated_at, str):
                updated_at = datetime.fromisoformat(updated_at)
            next_cursor = encode_cursor(updated_at, last["id"])
        else:
            next_cursor = encode_cursor(last.updated_at, last.id)

    return {
        "items": [item_class.from_db(i) if isinstance(i, dict) else i for i in items],
        "next_cursor": next_cursor,
        "has_more": has_more,
        "total_estimate": None,  # Can add pg_class estimate later if needed
    }


# =============================================================================
# Records Sync
# =============================================================================


@router.get("/records", response_model=RecordSyncResponse)
async def sync_records(
    account_id: str = Query(..., description="Account ID to fetch records for"),
    cursor: Optional[str] = Query(None, description="Pagination cursor from previous response"),
    limit: int = Query(50, ge=1, le=100, description="Page size (1-100)"),
    # Filters
    status: Optional[BookkeepingStatus] = Query(None, description="Filter by status"),
    updated_since: Optional[datetime] = Query(None, description="Only records updated after this time (ISO 8601)"),
    include_deleted: bool = Query(False, description="Include soft-deleted records (for full sync)"),
    user: dict = Depends(require_permission_key("order_tracking.read")),
):
    """
    Fetch records for sync with cursor-based pagination.

    **Pagination:**
    - First request: omit cursor
    - Subsequent requests: pass next_cursor from previous response
    - Stop when has_more is false

    **Filters:**
    - updated_since: Only return records updated after this timestamp (for incremental sync)
    - status: Filter by booking status
    - include_deleted: Include soft-deleted records (needed for sync to detect deletions)

    **Sort order:** updated_at DESC, id DESC (newest updates first)
    """
    try:
        supabase = get_supabase_for_user(user["token"])

        # Build base query with sync columns
        query = (
            supabase.table("bookkeeping_records")
            .select("*")
            .eq("account_id", account_id)
            .order("updated_at", desc=True)
            .order("id", desc=True)
            .limit(limit + 1)  # Extra for has_more detection
        )

        # Apply soft-delete filter (unless sync needs deletions)
        if not include_deleted:
            query = query.is_("deleted_at", "null")

        # Apply cursor filter
        query = _apply_cursor_filter(query, cursor)

        # Apply filters
        if status:
            query = query.eq("status", status.value)
        if updated_since:
            query = query.gte("updated_at", updated_since.isoformat())

        result = query.execute()
        records = result.data or []

        return _build_response(records, limit, RecordSyncItem)

    except HTTPException:
        raise
    except Exception as e:
        logger.exception("Failed to sync records")
        raise HTTPException(status_code=500, detail="Failed to fetch records")


# =============================================================================
# Accounts Sync
# =============================================================================


@router.get("/accounts", response_model=AccountSyncResponse)
async def sync_accounts(
    cursor: Optional[str] = Query(None, description="Pagination cursor from previous response"),
    limit: int = Query(50, ge=1, le=100, description="Page size (1-100)"),
    updated_since: Optional[datetime] = Query(None, description="Only accounts updated after this time"),
    include_deleted: bool = Query(False, description="Include soft-deleted accounts"),
    user: dict = Depends(require_permission_key("order_tracking.read")),
):
    """
    Fetch accounts for sync with cursor-based pagination.

    Accounts are organization-scoped via RLS (user sees accounts for their org).
    """
    try:
        supabase = get_supabase_for_user(user["token"])

        query = (
            supabase.table("accounts")
            .select("id, account_code, name, updated_at, deleted_at")
            .order("updated_at", desc=True)
            .order("id", desc=True)
            .limit(limit + 1)
        )

        if not include_deleted:
            query = query.is_("deleted_at", "null")

        query = _apply_cursor_filter(query, cursor)

        if updated_since:
            query = query.gte("updated_at", updated_since.isoformat())

        result = query.execute()
        accounts = result.data or []

        return _build_response(accounts, limit, AccountSyncItem)

    except HTTPException:
        raise
    except Exception as e:
        logger.exception("Failed to sync accounts")
        raise HTTPException(status_code=500, detail="Failed to fetch accounts")


# =============================================================================
# Sellers Sync
# =============================================================================


@router.get("/sellers", response_model=SellerSyncResponse)
async def sync_sellers(
    cursor: Optional[str] = Query(None, description="Pagination cursor from previous response"),
    limit: int = Query(50, ge=1, le=100, description="Page size (1-100)"),
    updated_since: Optional[datetime] = Query(None, description="Only sellers updated after this time"),
    include_deleted: bool = Query(False, description="Include soft-deleted sellers"),
    flagged: Optional[bool] = Query(None, description="Filter by flagged status"),
    user: dict = Depends(require_permission_key("seller_collection.read")),
):
    """
    Fetch sellers for sync with cursor-based pagination.

    Sellers are organization-scoped via RLS.
    """
    try:
        supabase = get_supabase_for_user(user["token"])

        query = (
            supabase.table("sellers")
            .select("id, display_name, normalized_name, platform, platform_id, times_seen, flagged, updated_at, deleted_at")
            .order("updated_at", desc=True)
            .order("id", desc=True)
            .limit(limit + 1)
        )

        if not include_deleted:
            query = query.is_("deleted_at", "null")

        query = _apply_cursor_filter(query, cursor)

        if updated_since:
            query = query.gte("updated_at", updated_since.isoformat())

        if flagged is not None:
            query = query.eq("flagged", flagged)

        result = query.execute()
        sellers = result.data or []

        return _build_response(sellers, limit, SellerSyncItem)

    except HTTPException:
        raise
    except Exception as e:
        logger.exception("Failed to sync sellers")
        raise HTTPException(status_code=500, detail="Failed to fetch sellers")
```

Key implementation decisions:
1. **Cursor filter:** Uses OR pattern for compound cursor comparison (Supabase limitation)
2. **has_more detection:** Fetches limit+1 records, trims to limit
3. **include_deleted:** For full sync, client needs to see deletions
4. **Permissions:** Uses existing permission keys (order_tracking.read, seller_collection.read)
5. **Error handling:** Returns structured error for invalid cursor (400 with code)
  </action>
  <verify>
Run Python syntax check:
```bash
cd apps/api && python -c "from app.routers.sync import router; print('Sync router imported OK')"
```
  </verify>
  <done>sync.py router created with /sync/records, /sync/accounts, /sync/sellers endpoints</done>
</task>

<task type="auto">
  <name>Task 3: Register sync router in main.py</name>
  <files>apps/api/src/app/routers/__init__.py, apps/api/src/app/main.py</files>
  <action>
1. Update `apps/api/src/app/routers/__init__.py` to export sync_router:

Add import:
```python
from .sync import router as sync_router
```

Add to __all__:
```python
__all__ = [
    # ... existing exports ...
    "sync_router",
]
```

2. Update `apps/api/src/app/main.py` to register sync_router:

Add import:
```python
from app.routers import (
    # ... existing imports ...
    sync_router,
)
```

Add router registration after existing routers:
```python
app.include_router(sync_router)
```
  </action>
  <verify>
Start the API and check routes:
```bash
cd apps/api && timeout 5 uvicorn app.main:app --port 8001 2>&1 | head -20 || true
```

Or check OpenAPI schema:
```bash
cd apps/api && python -c "
from app.main import app
routes = [r.path for r in app.routes if hasattr(r, 'path')]
sync_routes = [r for r in routes if '/sync' in r]
print('Sync routes:', sync_routes)
assert '/sync/records' in sync_routes, 'Missing /sync/records'
assert '/sync/accounts' in sync_routes, 'Missing /sync/accounts'
assert '/sync/sellers' in sync_routes, 'Missing /sync/sellers'
print('All sync routes registered OK')
"
```
  </verify>
  <done>sync_router registered in main.py, /sync/* routes visible in OpenAPI</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. All sync models importable:
```bash
cd apps/api && python -c "
from app.models import (
    RecordSyncItem, RecordSyncResponse,
    AccountSyncItem, AccountSyncResponse,
    SellerSyncItem, SellerSyncResponse,
)
print('All sync models imported OK')
"
```

2. Sync router importable:
```bash
cd apps/api && python -c "
from app.routers.sync import router
print('Sync router imported OK')
print('Routes:', [r.path for r in router.routes])
"
```

3. Routes registered in app:
```bash
cd apps/api && python -c "
from app.main import app
routes = [r.path for r in app.routes if hasattr(r, 'path')]
sync_routes = [r for r in routes if '/sync' in r]
print('Sync routes:', sync_routes)
assert len(sync_routes) >= 3
print('OK')
"
```

4. API starts without errors:
```bash
cd apps/api && timeout 3 uvicorn app.main:app --port 8001 2>&1 | grep -E "(Uvicorn running|error)" || echo "Started OK"
```
</verification>

<success_criteria>
- RecordSyncItem/Response, AccountSyncItem/Response, SellerSyncItem/Response models in models.py
- sync.py router with /sync/records, /sync/accounts, /sync/sellers endpoints
- Router registered in main.py
- All endpoints support cursor, limit, updated_since parameters
- /sync/records supports status filter and account_id (required)
- /sync/sellers supports flagged filter
- Invalid cursor returns 400 with INVALID_CURSOR code
- API starts without import errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-transport-layer/16-02-SUMMARY.md`
</output>
