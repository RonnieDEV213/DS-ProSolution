---
phase: 16-transport-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/app/pagination.py
  - apps/api/src/app/models.py
autonomous: true

must_haves:
  truths:
    - "Cursor encodes (updated_at, id) as opaque base64 string"
    - "Invalid cursor returns 400 with INVALID_CURSOR error code"
    - "Cursor decode handles timezone-aware ISO datetimes"
  artifacts:
    - path: "apps/api/src/app/pagination.py"
      provides: "Cursor encode/decode utilities"
      exports: ["encode_cursor", "decode_cursor"]
    - path: "apps/api/src/app/models.py"
      provides: "CursorPage generic response model"
      contains: "class CursorPage"
  key_links:
    - from: "apps/api/src/app/pagination.py"
      to: "datetime.fromisoformat"
      via: "cursor decode"
      pattern: "datetime\\.fromisoformat"
---

<objective>
Create cursor pagination utilities and generic response models for sync endpoints.

Purpose: Foundation for cursor-based pagination that enables efficient O(log n) queries regardless of page depth. The cursor encodes the last-seen (updated_at, id) tuple as an opaque base64 string.

Output: pagination.py module with encode/decode functions, CursorPage generic model in models.py
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-transport-layer/16-RESEARCH.md
@apps/api/src/app/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pagination utilities module</name>
  <files>apps/api/src/app/pagination.py</files>
  <action>
Create `apps/api/src/app/pagination.py` with cursor encode/decode utilities:

```python
"""Cursor-based pagination utilities for sync endpoints."""

import base64
import json
from datetime import datetime, timezone


def encode_cursor(updated_at: datetime, id: str) -> str:
    """
    Encode pagination position as opaque cursor.

    Args:
        updated_at: Timestamp of last record (must be timezone-aware)
        id: UUID of last record

    Returns:
        URL-safe base64 encoded cursor string (no padding)
    """
    # Ensure timezone-aware for consistency
    if updated_at.tzinfo is None:
        updated_at = updated_at.replace(tzinfo=timezone.utc)

    payload = {
        "u": updated_at.isoformat(),  # updated_at
        "i": id,                       # id
    }
    return base64.urlsafe_b64encode(
        json.dumps(payload).encode()
    ).decode().rstrip("=")


def decode_cursor(cursor: str) -> tuple[datetime, str]:
    """
    Decode cursor to pagination position.

    Args:
        cursor: Opaque cursor string from previous response

    Returns:
        Tuple of (updated_at datetime, id string)

    Raises:
        ValueError: If cursor is invalid or malformed
    """
    # Add back base64 padding
    padding = 4 - (len(cursor) % 4)
    if padding != 4:
        cursor += "=" * padding

    try:
        payload = json.loads(base64.urlsafe_b64decode(cursor))
        updated_at = datetime.fromisoformat(payload["u"])
        id = payload["i"]
        return updated_at, id
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        raise ValueError("Invalid cursor") from e
```

Key decisions:
- Use URL-safe base64 (urlsafe_b64encode) for query parameter safety
- Strip padding for shorter URLs (restore on decode)
- Short keys ("u", "i") to minimize cursor length
- Always ensure timezone-aware datetimes for consistency
  </action>
  <verify>
Run Python syntax check:
```bash
cd apps/api && python -c "from app.pagination import encode_cursor, decode_cursor; print('Import OK')"
```
  </verify>
  <done>pagination.py exists with encode_cursor and decode_cursor functions that handle timezone-aware datetimes</done>
</task>

<task type="auto">
  <name>Task 2: Add CursorPage generic model to models.py</name>
  <files>apps/api/src/app/models.py</files>
  <action>
Add generic cursor pagination response model to `apps/api/src/app/models.py`.

At the top of the file, add Generic/TypeVar imports if not present:
```python
from typing import Generic, TypeVar, Optional, Literal
# ... existing imports
```

Add TypeVar for generic pagination (after imports, before first class):
```python
T = TypeVar("T")
```

Add CursorPage model (add near the end of file, before any model_rebuild() calls):
```python
# ============================================================
# Cursor Pagination Models
# ============================================================


class CursorPage(BaseModel, Generic[T]):
    """
    Standard cursor-based pagination response.

    Usage:
        class RecordSyncResponse(CursorPage[RecordResponse]):
            pass
    """
    items: list[T]
    next_cursor: Optional[str] = None  # None when no more pages
    has_more: bool
    total_estimate: Optional[int] = None  # Approximate count for UI display
```

This generic model will be specialized for each sync endpoint (records, accounts, sellers).
  </action>
  <verify>
Run Python syntax check:
```bash
cd apps/api && python -c "from app.models import CursorPage; print('CursorPage imported OK')"
```
  </verify>
  <done>CursorPage generic model added to models.py with items, next_cursor, has_more, and total_estimate fields</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for cursor encode/decode</name>
  <files>apps/api/tests/test_pagination.py</files>
  <action>
Create `apps/api/tests/test_pagination.py` with tests for cursor utilities:

```python
"""Tests for cursor pagination utilities."""

import pytest
from datetime import datetime, timezone

from app.pagination import encode_cursor, decode_cursor


class TestCursorEncodeDecode:
    """Test cursor encoding and decoding."""

    def test_roundtrip_timezone_aware(self):
        """Cursor roundtrips with timezone-aware datetime."""
        dt = datetime(2024, 1, 15, 10, 30, 0, tzinfo=timezone.utc)
        id = "550e8400-e29b-41d4-a716-446655440000"

        cursor = encode_cursor(dt, id)
        decoded_dt, decoded_id = decode_cursor(cursor)

        assert decoded_dt == dt
        assert decoded_id == id

    def test_roundtrip_naive_datetime_becomes_utc(self):
        """Naive datetime is treated as UTC."""
        dt = datetime(2024, 1, 15, 10, 30, 0)  # Naive
        id = "550e8400-e29b-41d4-a716-446655440000"

        cursor = encode_cursor(dt, id)
        decoded_dt, decoded_id = decode_cursor(cursor)

        # Should have UTC timezone after roundtrip
        assert decoded_dt.tzinfo is not None
        assert decoded_id == id

    def test_cursor_is_url_safe(self):
        """Cursor uses URL-safe characters only."""
        dt = datetime(2024, 1, 15, 10, 30, 0, tzinfo=timezone.utc)
        id = "550e8400-e29b-41d4-a716-446655440000"

        cursor = encode_cursor(dt, id)

        # URL-safe base64 uses - and _ instead of + and /
        assert "+" not in cursor
        assert "/" not in cursor
        # Should not have padding (stripped)
        assert not cursor.endswith("=")

    def test_invalid_cursor_raises_valueerror(self):
        """Invalid cursor string raises ValueError."""
        with pytest.raises(ValueError, match="Invalid cursor"):
            decode_cursor("not-a-valid-cursor!!!")

    def test_malformed_json_raises_valueerror(self):
        """Malformed JSON in cursor raises ValueError."""
        import base64
        bad_cursor = base64.urlsafe_b64encode(b"not json").decode().rstrip("=")

        with pytest.raises(ValueError, match="Invalid cursor"):
            decode_cursor(bad_cursor)

    def test_missing_keys_raises_valueerror(self):
        """Cursor missing required keys raises ValueError."""
        import base64
        import json
        bad_cursor = base64.urlsafe_b64encode(
            json.dumps({"x": "y"}).encode()
        ).decode().rstrip("=")

        with pytest.raises(ValueError, match="Invalid cursor"):
            decode_cursor(bad_cursor)
```

Create tests directory if needed:
```bash
mkdir -p apps/api/tests
touch apps/api/tests/__init__.py
```
  </action>
  <verify>
Run tests:
```bash
cd apps/api && python -m pytest tests/test_pagination.py -v
```
  </verify>
  <done>Unit tests pass for cursor encode/decode including roundtrip, URL-safety, and error handling</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Cursor utilities work:
```bash
cd apps/api && python -c "
from datetime import datetime, timezone
from app.pagination import encode_cursor, decode_cursor

dt = datetime.now(timezone.utc)
id = 'test-id-123'
cursor = encode_cursor(dt, id)
print(f'Encoded: {cursor}')
decoded_dt, decoded_id = decode_cursor(cursor)
print(f'Decoded: {decoded_dt}, {decoded_id}')
assert decoded_id == id
print('OK')
"
```

2. CursorPage model is importable:
```bash
cd apps/api && python -c "
from app.models import CursorPage, RecordResponse
print('CursorPage imported OK')
"
```

3. Tests pass:
```bash
cd apps/api && python -m pytest tests/test_pagination.py -v
```
</verification>

<success_criteria>
- pagination.py exists with encode_cursor and decode_cursor functions
- CursorPage generic model added to models.py
- All unit tests pass
- Cursor roundtrip works with timezone-aware datetimes
- Invalid cursors raise ValueError with "Invalid cursor" message
</success_criteria>

<output>
After completion, create `.planning/phases/16-transport-layer/16-01-SUMMARY.md`
</output>
