---
phase: 19-sync-protocol
plan: 03
type: execute
wave: 2
depends_on: [19-01, 19-02]
files_modified:
  - apps/web/src/lib/db/schema.ts
  - apps/web/src/lib/db/index.ts
  - apps/web/src/lib/db/pending-mutations.ts
  - apps/web/src/hooks/sync/use-pending-mutations.ts
  - apps/web/src/components/sync/sync-row-badge.tsx
  - apps/web/src/components/bookkeeping/records-table.tsx
autonomous: true

must_haves:
  truths:
    - "Mutations queue in IndexedDB when offline"
    - "Queued mutations process automatically when back online"
    - "Queue processes in order (by timestamp)"
    - "Row shows pending badge when mutation queued"
    - "Row shows error badge with tooltip when mutation failed"
    - "Error badge includes retry button"
  artifacts:
    - path: "apps/web/src/lib/db/schema.ts"
      provides: "PendingMutation interface for offline queue"
      exports: ["PendingMutation"]
    - path: "apps/web/src/lib/db/index.ts"
      provides: "IndexedDB schema with _pending_mutations table"
      contains: "_pending_mutations"
    - path: "apps/web/src/lib/db/pending-mutations.ts"
      provides: "Queue management functions"
      exports: ["queueMutation", "processQueue", "getPendingForRecord"]
    - path: "apps/web/src/hooks/sync/use-pending-mutations.ts"
      provides: "Hook for tracking pending mutations per record"
      exports: ["usePendingMutations"]
    - path: "apps/web/src/components/sync/sync-row-badge.tsx"
      provides: "Row-level sync status badge component"
      exports: ["SyncRowBadge"]
  key_links:
    - from: "apps/web/src/components/sync/sync-row-badge.tsx"
      to: "apps/web/src/hooks/sync/use-pending-mutations.ts"
      via: "usePendingMutations for record status lookup"
      pattern: "usePendingMutations"
    - from: "apps/web/src/components/bookkeeping/records-table.tsx"
      to: "apps/web/src/components/sync/sync-row-badge.tsx"
      via: "SyncRowBadge rendered per row"
      pattern: "<SyncRowBadge"
    - from: "apps/web/src/lib/db/pending-mutations.ts"
      to: "apps/web/src/lib/db/index.ts"
      via: "db._pending_mutations table access"
      pattern: "db\\._pending_mutations"
---

<objective>
Implement offline mutation queue with row-level sync status badges for visual feedback.

Purpose: Users can make changes while offline (SYNC-07) and see per-row sync status (SYNC-08).

Output:
- `_pending_mutations` IndexedDB table for queuing offline changes
- Queue processing logic with sequential execution
- `SyncRowBadge` component showing pending/error states per row
- Integration with RecordsTable
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-sync-protocol/19-CONTEXT.md
@.planning/phases/19-sync-protocol/19-RESEARCH.md
@apps/web/src/lib/db/schema.ts
@apps/web/src/lib/db/index.ts
@apps/web/src/components/bookkeeping/records-table.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend IndexedDB schema with pending mutations table</name>
  <files>
    apps/web/src/lib/db/schema.ts
    apps/web/src/lib/db/index.ts
  </files>
  <action>
Add to `schema.ts`:
```typescript
export interface PendingMutation {
  id: string;              // UUID for the mutation
  record_id: string;       // ID of the record being mutated
  table: 'records' | 'accounts' | 'sellers';
  operation: 'create' | 'update' | 'delete';
  data: Record<string, unknown>;
  timestamp: string;       // ISO timestamp for ordering
  retry_count: number;
  last_error: string | null;
  status: 'pending' | 'in-flight' | 'failed';
}
```

Update `index.ts`:
1. Import `PendingMutation` from schema
2. Add to db type: `_pending_mutations: EntityTable<PendingMutation, 'id'>`
3. Increment `SCHEMA_VERSION` to 2
4. Add table to stores: `_pending_mutations: 'id, record_id, table, status, timestamp'`

NOTE: Incrementing schema version will clear existing data per 18-01 decision. This is acceptable as users should resync anyway after schema change.
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- PendingMutation interface exported from schema.ts
- _pending_mutations table added to Dexie schema
- Schema version incremented to 2
- Indexes on id, record_id, table, status, timestamp
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pending mutations queue manager</name>
  <files>
    apps/web/src/lib/db/pending-mutations.ts
  </files>
  <action>
Create `pending-mutations.ts` with queue management functions:

```typescript
import { db, type PendingMutation } from './index';
import { api } from '@/lib/api';

/**
 * Add a mutation to the offline queue.
 * Called when mutation attempted while offline.
 */
export async function queueMutation(
  mutation: Omit<PendingMutation, 'id' | 'timestamp' | 'retry_count' | 'last_error' | 'status'>
): Promise<string> {
  const id = crypto.randomUUID();
  await db._pending_mutations.add({
    ...mutation,
    id,
    timestamp: new Date().toISOString(),
    retry_count: 0,
    last_error: null,
    status: 'pending',
  });
  return id;
}

/**
 * Get pending mutation for a specific record.
 * Returns most recent pending/failed mutation if exists.
 */
export async function getPendingForRecord(
  recordId: string
): Promise<PendingMutation | null> {
  const mutations = await db._pending_mutations
    .where('record_id')
    .equals(recordId)
    .filter(m => m.status === 'pending' || m.status === 'failed')
    .sortBy('timestamp');
  return mutations[mutations.length - 1] ?? null;
}

/**
 * Process the offline queue sequentially.
 * Called when network comes back online.
 */
export async function processQueue(): Promise<{ processed: number; failed: number }> {
  let processed = 0;
  let failed = 0;

  // Get all pending mutations in timestamp order
  const pending = await db._pending_mutations
    .where('status')
    .equals('pending')
    .sortBy('timestamp');

  for (const mutation of pending) {
    // Mark as in-flight
    await db._pending_mutations.update(mutation.id, { status: 'in-flight' });

    try {
      await executeMutation(mutation);
      // Success - remove from queue
      await db._pending_mutations.delete(mutation.id);
      processed++;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      const newRetryCount = mutation.retry_count + 1;

      if (newRetryCount >= 3) {
        // Max retries reached - mark as failed
        await db._pending_mutations.update(mutation.id, {
          status: 'failed',
          retry_count: newRetryCount,
          last_error: errorMessage,
        });
        failed++;
      } else {
        // Will retry later
        await db._pending_mutations.update(mutation.id, {
          status: 'pending',
          retry_count: newRetryCount,
          last_error: errorMessage,
        });
      }
    }

    // Small delay between operations to avoid overwhelming server
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  return { processed, failed };
}

/**
 * Execute a single mutation against the API.
 */
async function executeMutation(mutation: PendingMutation): Promise<void> {
  switch (mutation.operation) {
    case 'create':
      await api.createRecord(mutation.data as Parameters<typeof api.createRecord>[0]);
      break;
    case 'update':
      await api.updateRecord(mutation.record_id, mutation.data);
      break;
    case 'delete':
      await api.deleteRecord(mutation.record_id);
      break;
  }
}

/**
 * Retry a failed mutation manually.
 */
export async function retryMutation(mutationId: string): Promise<boolean> {
  const mutation = await db._pending_mutations.get(mutationId);
  if (!mutation || mutation.status !== 'failed') return false;

  await db._pending_mutations.update(mutationId, { status: 'pending' });
  const result = await processQueue();
  return result.processed > 0;
}

/**
 * Remove a failed mutation (user chose to discard).
 */
export async function discardMutation(mutationId: string): Promise<void> {
  await db._pending_mutations.delete(mutationId);
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- queueMutation adds mutation to IndexedDB queue
- processQueue executes pending mutations in order
- getPendingForRecord returns status for specific record
- retryMutation allows manual retry of failed mutation
  </done>
</task>

<task type="auto">
  <name>Task 3: Create row-level sync status badge and wire to RecordsTable</name>
  <files>
    apps/web/src/hooks/sync/use-pending-mutations.ts
    apps/web/src/components/sync/sync-row-badge.tsx
    apps/web/src/components/bookkeeping/records-table.tsx
  </files>
  <action>
Create `use-pending-mutations.ts`:
```typescript
import { useLiveQuery } from 'dexie-react-hooks';
import { db, type PendingMutation } from '@/lib/db';

/**
 * Get all pending/failed mutations for records in the current view.
 * Returns a Map of recordId -> PendingMutation for quick lookup.
 */
export function usePendingMutations(table: 'records' | 'accounts' | 'sellers' = 'records') {
  return useLiveQuery(async () => {
    const mutations = await db._pending_mutations
      .where('table')
      .equals(table)
      .filter(m => m.status === 'pending' || m.status === 'failed' || m.status === 'in-flight')
      .toArray();

    return new Map(mutations.map(m => [m.record_id, m]));
  }, [table], new Map<string, PendingMutation>());
}
```

Create `sync-row-badge.tsx`:
```typescript
import { Loader2, AlertCircle, RefreshCw } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { Button } from '@/components/ui/button';
import { retryMutation } from '@/lib/db/pending-mutations';
import type { PendingMutation } from '@/lib/db';

interface SyncRowBadgeProps {
  mutation: PendingMutation | undefined;
}

export function SyncRowBadge({ mutation }: SyncRowBadgeProps) {
  // Per CONTEXT.md: only show pending and error states, no badge when synced
  if (!mutation) return null;

  if (mutation.status === 'pending' || mutation.status === 'in-flight') {
    // Pending: small spinning dot per CONTEXT.md
    return (
      <Tooltip>
        <TooltipTrigger asChild>
          <span className="inline-flex items-center">
            <Loader2 className="h-3 w-3 animate-spin text-blue-400" />
          </span>
        </TooltipTrigger>
        <TooltipContent>
          <p>Syncing changes...</p>
        </TooltipContent>
      </Tooltip>
    );
  }

  if (mutation.status === 'failed') {
    // Error: hover tooltip with error message + retry button per CONTEXT.md
    const handleRetry = async (e: React.MouseEvent) => {
      e.stopPropagation();
      await retryMutation(mutation.id);
    };

    return (
      <Tooltip>
        <TooltipTrigger asChild>
          <span className="inline-flex items-center">
            <AlertCircle className="h-3 w-3 text-red-400" />
          </span>
        </TooltipTrigger>
        <TooltipContent className="flex flex-col gap-2 max-w-xs">
          <p className="text-red-300">{mutation.last_error || 'Sync failed'}</p>
          <Button
            size="sm"
            variant="outline"
            className="h-6 text-xs"
            onClick={handleRetry}
          >
            <RefreshCw className="h-3 w-3 mr-1" />
            Retry
          </Button>
        </TooltipContent>
      </Tooltip>
    );
  }

  return null;
}
```

Update `records-table.tsx`:
1. Import `usePendingMutations` from `@/hooks/sync/use-pending-mutations`
2. Import `SyncRowBadge` from `@/components/sync/sync-row-badge`
3. In component body, call: `const pendingMutations = usePendingMutations('records');`
4. In the expand toggle cell (first cell), add SyncRowBadge next to the expand button:

```tsx
<TableCell className="p-2">
  <div className="flex items-center gap-1">
    <SyncRowBadge mutation={pendingMutations.get(record.id)} />
    <Button variant="ghost" size="sm" ...>
      {/* expand icon */}
    </Button>
  </div>
</TableCell>
```
  </action>
  <verify>
1. TypeScript compiles: `cd apps/web && npx tsc --noEmit`
2. App runs: `cd apps/web && npm run dev`
3. Navigate to /admin/order-tracking - no badges visible (nothing pending)
4. Go offline, make an edit - pending badge appears on that row
5. Go online - badge spins briefly, then disappears
  </verify>
  <done>
- usePendingMutations returns Map of record_id -> mutation status
- SyncRowBadge shows spinner for pending, error icon for failed
- Error badge has tooltip with message and retry button
- No badge shown when synced (per CONTEXT.md)
- Badge visible in RecordsTable first column
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/web && npx tsc --noEmit`
2. App runs: `cd apps/web && npm run dev`
3. Open DevTools > Application > IndexedDB - verify _pending_mutations table exists
4. Go offline (DevTools > Network > Offline)
5. Edit a record - change appears in UI, pending badge shows
6. Go online - queue processes, badge disappears
7. Simulate failure (edit while offline, then disconnect API) - error badge with retry button
</verification>

<success_criteria>
- SYNC-07: Mutations queue when offline, sync when back online
- SYNC-08: Each row displays its sync status (pending spinner, error icon)
- Queue processes in timestamp order
- Failed mutations show error message with retry option
</success_criteria>

<output>
After completion, create `.planning/phases/19-sync-protocol/19-03-SUMMARY.md`
</output>
