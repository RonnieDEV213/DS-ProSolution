---
phase: 19-sync-protocol
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/hooks/mutations/use-update-record.ts
  - apps/web/src/hooks/mutations/use-create-record.ts
  - apps/web/src/hooks/mutations/use-delete-record.ts
  - apps/web/src/lib/db/index.ts
autonomous: true

must_haves:
  truths:
    - "User sees immediate feedback when editing records"
    - "User does not lose changes when network fails briefly"
    - "User does not need to manually retry on temporary network issues"
    - "Failed validation shows error immediately without retry delay"
    - "User changes persist across page refresh"
  artifacts:
    - path: "apps/web/src/hooks/mutations/use-update-record.ts"
      provides: "Optimistic update mutation with retry logic"
      exports: ["useUpdateRecord"]
    - path: "apps/web/src/hooks/mutations/use-create-record.ts"
      provides: "Optimistic create mutation with retry logic"
      exports: ["useCreateRecord"]
    - path: "apps/web/src/hooks/mutations/use-delete-record.ts"
      provides: "Optimistic delete mutation with retry (already has optimistic)"
      exports: ["useDeleteRecord"]
  key_links:
    - from: "apps/web/src/hooks/mutations/use-update-record.ts"
      to: "apps/web/src/lib/db/index.ts"
      via: "db.records.update for local persistence"
      pattern: "db\\.records\\.update"
    - from: "apps/web/src/hooks/mutations/use-update-record.ts"
      to: "@tanstack/react-query"
      via: "retryDelay for exponential backoff"
      pattern: "retryDelay.*2\\s*\\*\\*"
---

<objective>
Add optimistic updates and automatic retry with exponential backoff to all mutation hooks.

Purpose: Users see instant feedback when editing records (SYNC-05), and transient failures auto-recover (SYNC-03).

Output:
- All mutation hooks use optimistic updates with rollback
- All mutations retry 3 times with exponential backoff on network/500 errors
- Local IndexedDB updated alongside cache for persistence
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-sync-protocol/19-CONTEXT.md
@.planning/phases/19-sync-protocol/19-RESEARCH.md
@apps/web/src/hooks/mutations/use-update-record.ts
@apps/web/src/hooks/mutations/use-create-record.ts
@apps/web/src/hooks/mutations/use-delete-record.ts
@apps/web/src/lib/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add retry logic and optimistic updates to useUpdateRecord</name>
  <files>
    apps/web/src/hooks/mutations/use-update-record.ts
  </files>
  <action>
Enhance `use-update-record.ts` with:

1. **Optimistic update pattern** (see RESEARCH.md Pattern 4):
```typescript
onMutate: async ({ id, data }) => {
  // Cancel in-flight queries to prevent overwrite
  await queryClient.cancelQueries({ queryKey });

  // Snapshot previous cache state for rollback
  const previousData = queryClient.getQueryData<InfiniteRecordsData>(queryKey);

  // Optimistically update cache
  if (previousData) {
    queryClient.setQueryData<InfiniteRecordsData>(queryKey, {
      ...previousData,
      pages: previousData.pages.map((page) => ({
        ...page,
        items: page.items.map((item) =>
          item.id === id ? { ...item, ...data } : item
        ),
      })),
    });
  }

  // Also update IndexedDB for persistence
  await db.records.update(id, data);

  return { previousData };
},
```

2. **Rollback on error**:
```typescript
onError: (_error, { id, data }, context) => {
  // Rollback cache
  if (context?.previousData) {
    queryClient.setQueryData(queryKey, context.previousData);
  }
  // Rollback IndexedDB (refetch from server will fix, but immediate rollback is cleaner)
  // Note: Complex rollback deferred - server sync will correct
},
```

3. **Retry logic** (see RESEARCH.md exponential backoff example):
```typescript
retry: (failureCount, error) => {
  // Only retry on network/server errors (5xx), not validation errors (4xx)
  if (error instanceof Error) {
    const statusMatch = error.message.match(/\\b(4\\d{2}|5\\d{2})\\b/);
    if (statusMatch) {
      const status = parseInt(statusMatch[1], 10);
      if (status >= 400 && status < 500) return false; // Don't retry 4xx
    }
  }
  return failureCount < 3; // Max 3 retries per CONTEXT.md
},
retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
```

4. Import `db` from `@/lib/db` for IndexedDB access.

5. Define `InfiniteRecordsData` interface (copy from use-delete-record.ts).
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- useUpdateRecord has onMutate with optimistic cache + IndexedDB update
- useUpdateRecord has onError with rollback
- useUpdateRecord has retry + retryDelay configured
- 4xx errors do not trigger retry
  </done>
</task>

<task type="auto">
  <name>Task 2: Add retry logic and optimistic updates to useCreateRecord</name>
  <files>
    apps/web/src/hooks/mutations/use-create-record.ts
  </files>
  <action>
Enhance `use-create-record.ts` with:

1. **Optimistic create** - Generate temporary ID for new record:
```typescript
onMutate: async (newRecord) => {
  await queryClient.cancelQueries({ queryKey });
  const previousData = queryClient.getQueryData<InfiniteRecordsData>(queryKey);

  // Create optimistic record with temp ID
  const tempId = `temp-${crypto.randomUUID()}`;
  const optimisticRecord = {
    ...newRecord,
    id: tempId,
    // Add computed fields that server normally provides
    profit_cents: 0,
    earnings_net_cents: 0,
    cogs_total_cents: 0,
    updated_at: new Date().toISOString(),
    deleted_at: null,
  };

  if (previousData) {
    queryClient.setQueryData<InfiniteRecordsData>(queryKey, {
      ...previousData,
      pages: previousData.pages.map((page, i) =>
        i === 0
          ? { ...page, items: [optimisticRecord, ...page.items] }
          : page
      ),
    });
  }

  // Also add to IndexedDB with temp ID
  await db.records.add(optimisticRecord);

  return { previousData, tempId };
},
```

2. **Replace temp with real ID on success**:
```typescript
onSuccess: async (serverRecord, _vars, context) => {
  // Remove temp record from IndexedDB, add real one
  if (context?.tempId) {
    await db.records.delete(context.tempId);
  }
  await db.records.put(serverRecord);
},
```

3. **Rollback on error**:
```typescript
onError: async (_error, _vars, context) => {
  if (context?.previousData) {
    queryClient.setQueryData(queryKey, context.previousData);
  }
  // Remove temp record from IndexedDB
  if (context?.tempId) {
    await db.records.delete(context.tempId);
  }
},
```

4. **Same retry logic as Task 1**.

5. Import `db` and define interfaces.
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- useCreateRecord optimistically adds record with temp ID
- On success, temp replaced with server record
- On error, temp record removed
- Retry logic configured
  </done>
</task>

<task type="auto">
  <name>Task 3: Add IndexedDB sync and retry to useDeleteRecord</name>
  <files>
    apps/web/src/hooks/mutations/use-delete-record.ts
  </files>
  <action>
Enhance existing `use-delete-record.ts`:

1. **Add IndexedDB delete in onMutate** (already has optimistic cache update):
```typescript
onMutate: async (recordId: string) => {
  await queryClient.cancelQueries({ queryKey });
  const previousData = queryClient.getQueryData<InfiniteRecordsData>(queryKey);

  // Get record before delete for potential rollback
  const deletedRecord = await db.records.get(recordId);

  // Optimistic cache update (existing code)
  if (previousData) {
    queryClient.setQueryData<InfiniteRecordsData>(queryKey, {...});
  }

  // Also delete from IndexedDB
  await db.records.delete(recordId);

  return { previousData, deletedRecord };
},
```

2. **Rollback IndexedDB on error**:
```typescript
onError: async (_error, _recordId, context) => {
  if (context?.previousData) {
    queryClient.setQueryData(queryKey, context.previousData);
  }
  // Restore deleted record to IndexedDB
  if (context?.deletedRecord) {
    await db.records.put(context.deletedRecord);
  }
},
```

3. **Add retry logic** (same pattern as Tasks 1-2).

4. Import `db` from `@/lib/db`.
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- useDeleteRecord removes from IndexedDB optimistically
- On error, record restored to IndexedDB
- Retry logic with exponential backoff
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/web && npx tsc --noEmit`
2. App runs: `cd apps/web && npm run dev`
3. Edit a record field - change appears instantly, persists after refresh
4. Delete a record - removed instantly, stays removed after refresh
5. Create a record - appears instantly at top, replaced with server version after save
6. Network offline during edit - change visible, syncs when online (tested in 19-03)
</verification>

<success_criteria>
- SYNC-03: Mutations retry up to 3 times with 1s/2s/4s backoff
- SYNC-05: UI updates optimistically before server response
- All changes persist to IndexedDB for offline resilience
- Validation errors (4xx) do not trigger retry
</success_criteria>

<output>
After completion, create `.planning/phases/19-sync-protocol/19-02-SUMMARY.md`
</output>
