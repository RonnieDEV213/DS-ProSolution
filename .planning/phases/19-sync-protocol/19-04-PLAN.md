---
phase: 19-sync-protocol
plan: 04
type: execute
wave: 2
depends_on: [19-01, 19-02, 19-03]
files_modified:
  - apps/web/src/lib/db/conflicts.ts
  - apps/web/src/components/sync/conflict-resolution-modal.tsx
  - apps/web/src/hooks/sync/use-sync-status.ts
  - apps/web/src/components/providers/sync-provider.tsx
  - apps/web/src/app/admin/layout.tsx
autonomous: true

must_haves:
  truths:
    - "User is prompted to resolve conflicts when both local and server data changed"
    - "Conflict modal shows field-by-field diff of conflicting values"
    - "User can choose 'Keep mine', 'Keep theirs', or 'Merge'"
    - "Merge option allows field-level selection"
    - "'Apply to all' option available for batch conflicts"
    - "Modal blocks until conflict resolved"
  artifacts:
    - path: "apps/web/src/lib/db/conflicts.ts"
      provides: "Conflict detection and resolution logic"
      exports: ["detectConflict", "resolveConflict", "Conflict"]
    - path: "apps/web/src/components/sync/conflict-resolution-modal.tsx"
      provides: "Modal UI for conflict resolution"
      exports: ["ConflictResolutionModal"]
    - path: "apps/web/src/components/providers/sync-provider.tsx"
      provides: "Context provider for conflict queue"
      exports: ["SyncProvider", "useSyncConflicts"]
  key_links:
    - from: "apps/web/src/components/sync/conflict-resolution-modal.tsx"
      to: "apps/web/src/components/providers/sync-provider.tsx"
      via: "useSyncConflicts for pending conflicts"
      pattern: "useSyncConflicts\\(\\)"
    - from: "apps/web/src/lib/db/conflicts.ts"
      to: "apps/web/src/lib/db/index.ts"
      via: "db.records access for local/server comparison"
      pattern: "db\\.records"
    - from: "apps/web/src/app/admin/layout.tsx"
      to: "apps/web/src/components/providers/sync-provider.tsx"
      via: "SyncProvider wraps admin layout"
      pattern: "<SyncProvider"
    - from: "apps/web/src/components/providers/sync-provider.tsx"
      to: "apps/web/src/lib/db/pending-mutations.ts"
      via: "processQueue called with addConflict callback"
      pattern: "processQueue.*addConflict"
---

<objective>
Implement conflict detection and resolution UI for when server data changed while user had pending local changes.

Purpose: Conflicts surface for user resolution instead of silent overwrite (SYNC-06).

Output:
- Conflict detection logic comparing local vs server versions
- Modal UI showing field-by-field diff
- Resolution options: keep mine, keep theirs, merge (field selection)
- Apply-to-all for batch conflict handling
- SyncProvider wiring that connects processQueue to conflict UI
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-sync-protocol/19-CONTEXT.md
@.planning/phases/19-sync-protocol/19-RESEARCH.md
@apps/web/src/lib/db/index.ts
@apps/web/src/lib/db/schema.ts
@apps/web/src/components/ui/dialog.tsx
@apps/web/src/app/admin/layout.tsx
@.planning/phases/19-sync-protocol/19-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conflict detection and resolution logic</name>
  <files>
    apps/web/src/lib/db/conflicts.ts
  </files>
  <action>
Create `conflicts.ts` with conflict detection and resolution:

```typescript
import { db, type BookkeepingRecord, type PendingMutation } from './index';

export interface Conflict {
  id: string;                    // Unique conflict ID
  record_id: string;
  mutation_id: string;           // Reference to pending mutation
  local_values: Record<string, unknown>;
  server_values: Record<string, unknown>;
  conflicting_fields: string[];  // Only fields that actually differ
  created_at: string;
}

/**
 * Detect if a conflict exists between local pending mutation and server state.
 * Called from processQueue (pending-mutations.ts) when server returns record
 * with updated_at > mutation timestamp.
 */
export function detectConflict(
  pendingMutation: PendingMutation,
  serverRecord: BookkeepingRecord
): Conflict | null {
  // Only updates can conflict (creates are new, deletes are binary)
  if (pendingMutation.operation !== 'update') return null;

  // Check if server was updated after our local change
  if (new Date(serverRecord.updated_at) <= new Date(pendingMutation.timestamp)) {
    return null; // No conflict - our change is newer
  }

  // Find fields that actually conflict (both changed, different values)
  const mutatedFields = Object.keys(pendingMutation.data);
  const conflictingFields: string[] = [];
  const localValues: Record<string, unknown> = {};
  const serverValues: Record<string, unknown> = {};

  for (const field of mutatedFields) {
    const localValue = pendingMutation.data[field];
    const serverValue = serverRecord[field as keyof BookkeepingRecord];

    // Only conflict if values actually differ
    if (!deepEqual(localValue, serverValue)) {
      conflictingFields.push(field);
      localValues[field] = localValue;
      serverValues[field] = serverValue;
    }
  }

  if (conflictingFields.length === 0) {
    return null; // Same values - no real conflict
  }

  return {
    id: crypto.randomUUID(),
    record_id: pendingMutation.record_id,
    mutation_id: pendingMutation.id,
    local_values: localValues,
    server_values: serverValues,
    conflicting_fields: conflictingFields,
    created_at: new Date().toISOString(),
  };
}

export type Resolution = 'keep-mine' | 'keep-theirs' | 'merge';

export interface MergeSelection {
  [field: string]: 'local' | 'server';
}

/**
 * Resolve a conflict by applying the chosen resolution.
 */
export async function resolveConflict(
  conflict: Conflict,
  resolution: Resolution,
  mergeSelection?: MergeSelection
): Promise<void> {
  const record = await db.records.get(conflict.record_id);
  if (!record) return;

  let resolvedData: Partial<BookkeepingRecord>;

  switch (resolution) {
    case 'keep-mine':
      // Apply local values to IndexedDB (will sync to server)
      resolvedData = conflict.local_values as Partial<BookkeepingRecord>;
      break;

    case 'keep-theirs':
      // Apply server values to IndexedDB
      resolvedData = conflict.server_values as Partial<BookkeepingRecord>;
      break;

    case 'merge':
      // Apply field-by-field selection
      if (!mergeSelection) {
        throw new Error('Merge selection required for merge resolution');
      }
      resolvedData = {};
      for (const field of conflict.conflicting_fields) {
        const choice = mergeSelection[field] ?? 'server';
        resolvedData[field as keyof BookkeepingRecord] =
          choice === 'local'
            ? conflict.local_values[field]
            : conflict.server_values[field];
      }
      break;
  }

  // Update local record
  await db.records.update(conflict.record_id, {
    ...resolvedData,
    updated_at: new Date().toISOString(),
  });

  // Remove the pending mutation that caused conflict
  await db._pending_mutations.delete(conflict.mutation_id);
}

/**
 * Deep equality check for conflict detection.
 */
function deepEqual(a: unknown, b: unknown): boolean {
  if (a === b) return true;
  if (a === null || b === null) return a === b;
  if (typeof a !== typeof b) return false;
  if (typeof a !== 'object') return false;

  const aObj = a as Record<string, unknown>;
  const bObj = b as Record<string, unknown>;
  const aKeys = Object.keys(aObj);
  const bKeys = Object.keys(bObj);

  if (aKeys.length !== bKeys.length) return false;
  return aKeys.every(key => deepEqual(aObj[key], bObj[key]));
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- Conflict interface defines structure with field-level detail
- detectConflict compares mutation timestamp vs server updated_at
- Only reports fields that actually differ
- resolveConflict handles all three resolution types
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SyncProvider with queue processing integration</name>
  <files>
    apps/web/src/components/providers/sync-provider.tsx
  </files>
  <action>
Create `sync-provider.tsx`:

```typescript
'use client';

import {
  createContext,
  useContext,
  useState,
  useCallback,
  useEffect,
  type ReactNode,
} from 'react';
import type { Conflict, Resolution, MergeSelection } from '@/lib/db/conflicts';
import { resolveConflict as resolveConflictDb } from '@/lib/db/conflicts';
import { processQueue } from '@/lib/db/pending-mutations';
import { useOnlineStatus } from '@/hooks/sync/use-online-status';

interface SyncContextValue {
  conflicts: Conflict[];
  currentConflict: Conflict | null;
  addConflict: (conflict: Conflict) => void;
  resolveCurrentConflict: (
    resolution: Resolution,
    mergeSelection?: MergeSelection,
    applyToAll?: boolean
  ) => Promise<void>;
  hasConflicts: boolean;
}

const SyncContext = createContext<SyncContextValue | null>(null);

export function SyncProvider({ children }: { children: ReactNode }) {
  const [conflicts, setConflicts] = useState<Conflict[]>([]);
  const isOnline = useOnlineStatus();

  const currentConflict = conflicts[0] ?? null;
  const hasConflicts = conflicts.length > 0;

  const addConflict = useCallback((conflict: Conflict) => {
    setConflicts((prev) => [...prev, conflict]);
  }, []);

  const resolveCurrentConflict = useCallback(
    async (
      resolution: Resolution,
      mergeSelection?: MergeSelection,
      applyToAll?: boolean
    ) => {
      if (!currentConflict) return;

      if (applyToAll && resolution !== 'merge') {
        // Apply same resolution to all remaining conflicts
        for (const conflict of conflicts) {
          await resolveConflictDb(conflict, resolution);
        }
        setConflicts([]);
      } else {
        // Resolve just the current conflict
        await resolveConflictDb(currentConflict, resolution, mergeSelection);
        setConflicts((prev) => prev.slice(1));
      }
    },
    [currentConflict, conflicts]
  );

  // CRITICAL WIRING: Process queue when coming back online
  // Pass addConflict as the onConflict callback so detectConflict results
  // flow into the conflict queue and trigger the modal.
  useEffect(() => {
    if (isOnline && !hasConflicts) {
      // When online and no unresolved conflicts, process the queue
      processQueue(addConflict).then((result) => {
        if (result.conflicts > 0) {
          console.log(`[Sync] ${result.conflicts} conflict(s) detected, awaiting resolution`);
        }
        if (result.processed > 0) {
          console.log(`[Sync] Processed ${result.processed} queued mutation(s)`);
        }
        if (result.failed > 0) {
          console.warn(`[Sync] ${result.failed} mutation(s) failed after retries`);
        }
      });
    }
  }, [isOnline, hasConflicts, addConflict]);

  return (
    <SyncContext.Provider
      value={{
        conflicts,
        currentConflict,
        addConflict,
        resolveCurrentConflict,
        hasConflicts,
      }}
    >
      {children}
    </SyncContext.Provider>
  );
}

export function useSyncConflicts() {
  const context = useContext(SyncContext);
  if (!context) {
    throw new Error('useSyncConflicts must be used within SyncProvider');
  }
  return context;
}
```

IMPORTANT: The `useEffect` hook that calls `processQueue(addConflict)` is the critical wiring that connects:
1. `processQueue` (from Plan 19-03) executes pending mutations
2. `detectConflict` (Task 1) is called inside processQueue for update operations
3. When a conflict is found, `addConflict` (the callback) adds it to the conflict queue
4. The conflict queue triggers the modal (Task 3)

This completes the chain: offline edit -> queue -> come online -> processQueue -> detectConflict -> addConflict -> modal appears.
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- SyncProvider manages conflict queue in state
- addConflict appends to queue
- resolveCurrentConflict processes front of queue
- applyToAll option resolves all with same resolution
- useEffect calls processQueue with addConflict when coming online
- Conflict detection is now wired to the UI
  </done>
</task>

<task type="auto">
  <name>Task 3: Create conflict resolution modal and wire to layout</name>
  <files>
    apps/web/src/components/sync/conflict-resolution-modal.tsx
    apps/web/src/app/admin/layout.tsx
  </files>
  <action>
Create `conflict-resolution-modal.tsx`:

```typescript
'use client';

import { useState } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { useSyncConflicts } from '@/components/providers/sync-provider';
import type { MergeSelection } from '@/lib/db/conflicts';
import { formatCents, displayValue, STATUS_LABELS } from '@/lib/api';

// Human-readable field labels
const FIELD_LABELS: Record<string, string> = {
  sale_date: 'Sale Date',
  item_name: 'Item Name',
  qty: 'Quantity',
  sale_price_cents: 'Sale Price',
  ebay_fees_cents: 'eBay Fees',
  amazon_price_cents: 'Amazon Price',
  amazon_tax_cents: 'Amazon Tax',
  amazon_shipping_cents: 'Amazon Shipping',
  amazon_order_id: 'Amazon Order',
  status: 'Status',
  return_label_cost_cents: 'Return Label Cost',
  order_remark: 'Order Remark',
  service_remark: 'Service Remark',
};

export function ConflictResolutionModal() {
  const { currentConflict, hasConflicts, conflicts, resolveCurrentConflict } =
    useSyncConflicts();
  const [mergeSelection, setMergeSelection] = useState<MergeSelection>({});
  const [applyToAll, setApplyToAll] = useState(false);
  const [resolving, setResolving] = useState(false);

  if (!hasConflicts || !currentConflict) return null;

  const formatValue = (field: string, value: unknown): string => {
    if (value === null || value === undefined) return '-';
    if (field.endsWith('_cents')) return formatCents(value as number);
    if (field === 'status') return STATUS_LABELS[value as string] ?? String(value);
    return displayValue(value);
  };

  const handleResolve = async (resolution: 'keep-mine' | 'keep-theirs' | 'merge') => {
    setResolving(true);
    try {
      await resolveCurrentConflict(
        resolution,
        resolution === 'merge' ? mergeSelection : undefined,
        applyToAll
      );
      setMergeSelection({});
      setApplyToAll(false);
    } finally {
      setResolving(false);
    }
  };

  const toggleMergeField = (field: string, choice: 'local' | 'server') => {
    setMergeSelection((prev) => ({ ...prev, [field]: choice }));
  };

  const remainingCount = conflicts.length - 1;

  return (
    <Dialog open={hasConflicts} onOpenChange={() => {}}>
      <DialogContent className="max-w-lg" onPointerDownOutside={(e) => e.preventDefault()}>
        <DialogHeader>
          <DialogTitle>Sync Conflict Detected</DialogTitle>
          <DialogDescription>
            This record was modified on both your device and the server.
            Choose how to resolve the conflict.
            {remainingCount > 0 && (
              <span className="block mt-1 text-yellow-400">
                {remainingCount} more conflict{remainingCount > 1 ? 's' : ''} remaining
              </span>
            )}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* Field-by-field comparison */}
          <div className="border border-gray-700 rounded-lg overflow-hidden">
            <table className="w-full text-sm">
              <thead className="bg-gray-800">
                <tr>
                  <th className="px-3 py-2 text-left text-gray-400">Field</th>
                  <th className="px-3 py-2 text-left text-blue-400">Your Value</th>
                  <th className="px-3 py-2 text-left text-green-400">Server Value</th>
                </tr>
              </thead>
              <tbody>
                {currentConflict.conflicting_fields.map((field) => (
                  <tr key={field} className="border-t border-gray-700">
                    <td className="px-3 py-2 font-medium text-gray-300">
                      {FIELD_LABELS[field] ?? field}
                    </td>
                    <td className="px-3 py-2 text-blue-300">
                      {formatValue(field, currentConflict.local_values[field])}
                    </td>
                    <td className="px-3 py-2 text-green-300">
                      {formatValue(field, currentConflict.server_values[field])}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          {/* Apply to all checkbox (only show if more conflicts) */}
          {remainingCount > 0 && (
            <div className="flex items-center gap-2">
              <Checkbox
                id="apply-all"
                checked={applyToAll}
                onCheckedChange={(checked) => setApplyToAll(checked === true)}
              />
              <label htmlFor="apply-all" className="text-sm text-gray-400 cursor-pointer">
                Apply this choice to all {remainingCount} remaining conflict{remainingCount > 1 ? 's' : ''}
              </label>
            </div>
          )}
        </div>

        <DialogFooter className="flex-col sm:flex-row gap-2">
          <Button
            variant="outline"
            onClick={() => handleResolve('keep-mine')}
            disabled={resolving}
            className="border-blue-600 text-blue-400 hover:bg-blue-900/20"
          >
            Keep Mine
          </Button>
          <Button
            variant="outline"
            onClick={() => handleResolve('keep-theirs')}
            disabled={resolving}
            className="border-green-600 text-green-400 hover:bg-green-900/20"
          >
            Keep Theirs
          </Button>
          <Button
            variant="default"
            onClick={() => handleResolve('merge')}
            disabled={resolving || Object.keys(mergeSelection).length === 0}
          >
            Merge Selected
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

Update `app/admin/layout.tsx`:
1. Import `SyncProvider` from `@/components/providers/sync-provider`
2. Import `ConflictResolutionModal` from `@/components/sync/conflict-resolution-modal`
3. Wrap children with `SyncProvider`
4. Add `ConflictResolutionModal` inside provider

```tsx
import { SyncProvider } from "@/components/providers/sync-provider";
import { ConflictResolutionModal } from "@/components/sync/conflict-resolution-modal";

export default function AdminLayout({ children }) {
  return (
    <div className="flex min-h-screen bg-gray-950">
      <AdminSidebar />
      <main className="flex-1 p-8">
        <SyncProvider>
          <AdminLayoutClient>{children}</AdminLayoutClient>
          <ConflictResolutionModal />
        </SyncProvider>
      </main>
    </div>
  );
}
```
  </action>
  <verify>
1. TypeScript compiles: `cd apps/web && npx tsc --noEmit`
2. App runs: `cd apps/web && npm run dev`
3. Modal appears when conflict added to queue
4. Modal cannot be dismissed by clicking outside
  </verify>
  <done>
- ConflictResolutionModal shows field-by-field diff
- Three resolution buttons: Keep Mine, Keep Theirs, Merge
- Apply to all checkbox for batch resolution
- Modal blocks interaction until resolved
- SyncProvider wraps admin layout
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/web && npx tsc --noEmit`
2. App runs: `cd apps/web && npm run dev`
3. Full integration test:
   - Go offline (DevTools > Network > Offline)
   - Edit a record field
   - Meanwhile, use another browser/API to change the same record on server
   - Go back online
   - Conflict modal should appear showing both versions
4. Test all three resolution options
5. Test apply-to-all with multiple conflicts
</verification>

<success_criteria>
- SYNC-06: Conflicts show both versions for user resolution
- Modal displays field-by-field comparison
- Keep mine / keep theirs / merge options work
- Apply to all handles batch conflicts
- Modal blocks until resolved (cannot be dismissed)
- detectConflict is called from processQueue (Plan 19-03)
- addConflict callback wires conflicts to the modal
</success_criteria>

<output>
After completion, create `.planning/phases/19-sync-protocol/19-04-SUMMARY.md`
</output>
