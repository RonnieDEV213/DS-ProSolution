---
phase: 19-sync-protocol
plan: 06
type: execute
wave: 3
depends_on: [19-01, 19-02, 19-03, 19-04]
files_modified:
  - apps/web/src/lib/db/pending-mutations.ts
  - apps/web/src/lib/db/conflicts.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Conflict detection compares mutation timestamp against fresh server data"
    - "Server record fetched via sync API before conflict check"
    - "Conflicts only detected when server updated_at > mutation timestamp"
  artifacts:
    - path: "apps/web/src/lib/db/pending-mutations.ts"
      provides: "processQueue fetches server record via syncRecords before detectConflict"
      contains: "api.syncRecords"
    - path: "apps/web/src/lib/db/conflicts.ts"
      provides: "detectConflict accepts RecordSyncItem which has updated_at"
      contains: "RecordSyncItem"
  key_links:
    - from: "apps/web/src/lib/db/pending-mutations.ts"
      to: "apps/web/src/lib/api.ts"
      via: "api.syncRecords call to fetch single record with updated_at"
      pattern: "api\\.syncRecords\\("
    - from: "apps/web/src/lib/db/pending-mutations.ts"
      to: "apps/web/src/lib/db/conflicts.ts"
      via: "detectConflict receives RecordSyncItem (has updated_at)"
      pattern: "detectConflict\\(mutation,\\s*serverRecord"
---

<objective>
Fix conflict detection to fetch current server state instead of using stale IndexedDB data.

Purpose: Close SYNC-06 gap - conflict detection uses correct data source for accurate comparison.

Output:
- processQueue fetches server record via api.syncRecords before conflict check
- detectConflict receives RecordSyncItem (which has updated_at field)
- Conflicts accurately detected when server was modified after mutation was queued
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-sync-protocol/19-VERIFICATION.md
@apps/web/src/lib/db/pending-mutations.ts
@apps/web/src/lib/db/conflicts.ts
@apps/web/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update detectConflict to accept RecordSyncItem</name>
  <files>
    apps/web/src/lib/db/conflicts.ts
  </files>
  <action>
Modify `conflicts.ts` to accept `RecordSyncItem` instead of `BookkeepingRecord` for the server record:

1. Update imports to include RecordSyncItem from api:
```typescript
import { db, type PendingMutation } from './index';
import type { RecordSyncItem } from '@/lib/api';
```

2. Update detectConflict signature:
```typescript
/**
 * Detect if a conflict exists between local pending mutation and server state.
 * Called from processQueue when comparing against fresh server data.
 *
 * @param pendingMutation - The queued local mutation
 * @param serverRecord - Fresh record from api.syncRecords (has updated_at)
 */
export function detectConflict(
  pendingMutation: PendingMutation,
  serverRecord: RecordSyncItem
): Conflict | null {
```

The function body remains the same - RecordSyncItem has `updated_at` field so line 26's comparison works correctly. It also has all the same data fields as BookkeepingRecord (item_name, sale_price_cents, etc.) so field comparison works too.

Note: The `BookkeepingRecord` from db/schema.ts also has `updated_at`, but we're switching to `RecordSyncItem` to be explicit that this must come from the API sync endpoint, not from local IndexedDB.
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- detectConflict accepts RecordSyncItem (which has updated_at)
- Import added for RecordSyncItem from api
- Function signature is explicit about requiring server data
  </done>
</task>

<task type="auto">
  <name>Task 2: Update processQueue to fetch server record via syncRecords</name>
  <files>
    apps/web/src/lib/db/pending-mutations.ts
  </files>
  <action>
Modify `processQueue` in `pending-mutations.ts` to fetch fresh server data via the existing `api.syncRecords` endpoint before conflict detection.

Why syncRecords instead of a hypothetical getRecord endpoint:
1. GET /records/{id} does NOT exist in the backend
2. api.syncRecords already exists and returns RecordSyncItem with updated_at
3. We can filter by record ID by using updated_since with a very old date

1. Add import for RecordSyncItem if not present:
```typescript
import { api, type RecordSyncItem } from '@/lib/api';
```

2. Create helper function to fetch a single record:
```typescript
/**
 * Fetch a single record from server via sync endpoint.
 * Returns the record with updated_at for conflict detection.
 */
async function fetchServerRecord(recordId: string): Promise<RecordSyncItem | null> {
  try {
    // Use syncRecords with a very old updated_since to get all records,
    // then filter client-side. This is not ideal but works without backend changes.
    // A future optimization would be to add GET /records/{id} to the API.
    const response = await api.syncRecords({
      limit: 1000,  // Get a batch that likely contains our record
      include_deleted: false,
    });

    const record = response.items.find(item => item.id === recordId);
    return record ?? null;
  } catch (error) {
    console.warn(`[fetchServerRecord] Failed to fetch record ${recordId}:`, error);
    return null;
  }
}
```

Note: This is a pragmatic solution. For production with many records, consider:
- Adding GET /records/{id} endpoint to backend (future task)
- Using the account_id filter to narrow results
- Caching recent sync results

3. Replace the conflict detection block (lines 71-87) in processQueue:
```typescript
// For updates, check for conflict before applying
if (mutation.operation === 'update') {
  // Fetch CURRENT server state to detect conflicts
  const serverRecord = await fetchServerRecord(mutation.record_id);

  if (serverRecord) {
    // Check if server was modified after our mutation was queued
    const conflict = detectConflict(mutation, serverRecord);
    if (conflict) {
      // Conflict detected - pause this mutation for user resolution
      await db._pending_mutations.update(mutation.id, { status: 'pending' });
      if (onConflict) {
        onConflict(conflict);
      }
      conflicts++;
      continue; // Skip to next mutation, this one awaits resolution
    }
  }
  // If serverRecord is null (fetch failed or record doesn't exist on server),
  // proceed with the mutation - it will either succeed or fail with proper error
}
```

This replaces the problematic code that was comparing against local IndexedDB data (which was stale by definition - it was our own optimistic update, not fresh server state).
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- processQueue fetches server record via api.syncRecords
- detectConflict receives fresh RecordSyncItem with updated_at
- Error handling: if fetch fails, proceed with mutation (let it fail/succeed naturally)
- Conflict detection now compares against actual current server state
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/web && npx tsc --noEmit`
2. App runs: `cd apps/web && npm run dev`
3. Integration test for SYNC-06 conflict detection:
   - Open app in two browser windows
   - In window 1: Go offline, edit a record (e.g., change item_name)
   - In window 2: Edit the SAME record with DIFFERENT value (online)
   - In window 1: Go back online
   - Conflict modal should appear showing both versions
   - Verify "Your Value" is from window 1's edit
   - Verify "Server Value" is from window 2's edit (fresh from server)
4. No conflict case:
   - Go offline, edit a record
   - Go back online (no one else edited)
   - No conflict modal - change syncs directly
</verification>

<success_criteria>
- SYNC-06: Conflict detection uses correct data source
- processQueue fetches server record via api.syncRecords before calling detectConflict
- detectConflict compares mutation.timestamp vs serverRecord.updated_at
- True conflicts (server modified after mutation queued) trigger modal
- False positives avoided (comparing against fresh data, not stale IndexedDB)
</success_criteria>

<output>
After completion, create `.planning/phases/19-sync-protocol/19-06-SUMMARY.md`
</output>
