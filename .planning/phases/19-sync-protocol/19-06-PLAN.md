---
phase: 19-sync-protocol
plan: 06
type: execute
wave: 3
depends_on: [19-01, 19-02, 19-03, 19-04]
files_modified:
  - apps/web/src/lib/db/pending-mutations.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Conflict detection compares mutation timestamp against fresh server data"
    - "Server record fetched via API before conflict check"
    - "Conflicts only detected when server updated_at > mutation timestamp"
  artifacts:
    - path: "apps/web/src/lib/db/pending-mutations.ts"
      provides: "processQueue fetches server record before detectConflict"
      contains: "api.getRecord"
  key_links:
    - from: "apps/web/src/lib/db/pending-mutations.ts"
      to: "apps/web/src/lib/api.ts"
      via: "api.getRecord call before conflict detection"
      pattern: "api\\.getRecord\\(mutation\\.record_id\\)"
    - from: "apps/web/src/lib/db/pending-mutations.ts"
      to: "apps/web/src/lib/db/conflicts.ts"
      via: "detectConflict receives server record not local record"
      pattern: "detectConflict\\(mutation,\\s*serverRecord"
---

<objective>
Fix conflict detection to fetch current server state instead of using stale IndexedDB data.

Purpose: Close SYNC-06 gap - conflict detection uses correct data source for accurate comparison.

Output:
- processQueue fetches server record via API before conflict check
- detectConflict receives fresh server data, not local IndexedDB data
- Conflicts accurately detected when server was modified after mutation was queued
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-sync-protocol/19-VERIFICATION.md
@apps/web/src/lib/db/pending-mutations.ts
@apps/web/src/lib/db/conflicts.ts
@apps/web/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update processQueue to fetch server record before conflict detection</name>
  <files>
    apps/web/src/lib/db/pending-mutations.ts
  </files>
  <action>
Modify `processQueue` in `pending-mutations.ts` to fetch fresh server data before conflict detection:

**Current problematic code (lines 71-87):**
```typescript
// For updates, check for conflict before applying
if (mutation.operation === 'update') {
  // Get the current IndexedDB record to detect conflicts
  const localRecord = await db.records.get(mutation.record_id);  // WRONG - stale data
  if (localRecord) {
    const conflict = detectConflict(mutation, localRecord);  // WRONG - comparing to local
```

**Replace with:**
```typescript
// For updates, check for conflict before applying
if (mutation.operation === 'update') {
  try {
    // Fetch CURRENT server state to detect conflicts
    const serverRecord = await api.getRecord(mutation.record_id);

    // Check if server was modified after our mutation was queued
    const conflict = detectConflict(mutation, serverRecord);
    if (conflict) {
      // Conflict detected - pause this mutation for user resolution
      await db._pending_mutations.update(mutation.id, { status: 'pending' });
      if (onConflict) {
        onConflict(conflict);
      }
      conflicts++;
      continue; // Skip to next mutation, this one awaits resolution
    }
  } catch (fetchError) {
    // If we can't fetch server record (404, network error), skip conflict check
    // The subsequent executeMutation will either succeed or fail with proper error
    console.warn(`[processQueue] Could not fetch server record for conflict check: ${mutation.record_id}`, fetchError);
  }
}
```

**Also add import for api if not present:**
The file already imports `api` from '@/lib/api' (line 2).

**Verify api.getRecord exists:**
Need to check if `api.getRecord` is exported. If not, add it.
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- processQueue fetches server record via api.getRecord before conflict detection
- detectConflict receives fresh server data
- Error handling for fetch failures (skip conflict check, let mutation proceed)
- Conflict detection now accurate - compares against current server state
  </done>
</task>

<task type="auto">
  <name>Task 2: Add api.getRecord if missing</name>
  <files>
    apps/web/src/lib/api.ts
  </files>
  <action>
Check if `api.getRecord` exists. If not, add it to the api object.

**Search for existing getRecord:**
Look for a function like `getRecord(id: string)` in api.ts.

**If missing, add:**
```typescript
async getRecord(id: string): Promise<BookkeepingRecord> {
  const token = await getAccessToken();
  const response = await fetch(`${API_BASE}/records/${id}`, {
    headers: {
      "Content-Type": "application/json",
      ...(token ? { Authorization: `Bearer ${token}` } : {}),
    },
  });

  if (!response.ok) {
    throw new Error(`Failed to fetch record: ${response.status}`);
  }

  return response.json();
},
```

Add this to the `api` object export alongside existing methods like `updateRecord`, `deleteRecord`, etc.

**Note:** The backend likely already has a GET /records/{id} endpoint from the paginated API (Phase 16). If not, this task will fail at runtime and we'll need a backend change.
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- api.getRecord function exists and is callable
- Returns BookkeepingRecord type
- Properly authenticated with Bearer token
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/web && npx tsc --noEmit`
2. App runs: `cd apps/web && npm run dev`
3. Integration test for SYNC-06 conflict detection:
   - Open app in two browser windows
   - In window 1: Go offline, edit a record (e.g., change item_name)
   - In window 2: Edit the SAME record with DIFFERENT value (online)
   - In window 1: Go back online
   - Conflict modal should appear showing both versions
   - Verify "Your Value" is from window 1's edit
   - Verify "Server Value" is from window 2's edit (fresh from server)
4. No conflict case:
   - Go offline, edit a record
   - Go back online (no one else edited)
   - No conflict modal - change syncs directly
</verification>

<success_criteria>
- SYNC-06: Conflict detection uses correct data source
- processQueue fetches server record before calling detectConflict
- detectConflict compares mutation.timestamp vs serverRecord.updated_at
- True conflicts (server modified after mutation queued) trigger modal
- False positives avoided (comparing against fresh data, not stale IndexedDB)
</success_criteria>

<output>
After completion, create `.planning/phases/19-sync-protocol/19-06-SUMMARY.md`
</output>
