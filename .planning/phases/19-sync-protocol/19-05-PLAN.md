---
phase: 19-sync-protocol
plan: 05
type: execute
wave: 3
depends_on: [19-01, 19-02, 19-03, 19-04]
files_modified:
  - apps/web/src/hooks/mutations/use-update-record.ts
  - apps/web/src/hooks/mutations/use-create-record.ts
  - apps/web/src/hooks/mutations/use-delete-record.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Mutations queue to IndexedDB when device is offline"
    - "Mutations execute via API when device is online"
    - "Queued mutations sync automatically when connection restored"
    - "Row-level sync badges show pending state for queued mutations"
  artifacts:
    - path: "apps/web/src/hooks/mutations/use-update-record.ts"
      provides: "Online check + queueMutation call when offline"
      contains: "useOnlineStatus"
    - path: "apps/web/src/hooks/mutations/use-create-record.ts"
      provides: "Online check + queueMutation call when offline"
      contains: "useOnlineStatus"
    - path: "apps/web/src/hooks/mutations/use-delete-record.ts"
      provides: "Online check + queueMutation call when offline"
      contains: "useOnlineStatus"
  key_links:
    - from: "apps/web/src/hooks/mutations/use-update-record.ts"
      to: "apps/web/src/lib/db/pending-mutations.ts"
      via: "queueMutation call in mutationFn when offline"
      pattern: "queueMutation\\("
    - from: "apps/web/src/hooks/mutations/use-update-record.ts"
      to: "apps/web/src/hooks/sync/use-online-status.ts"
      via: "useOnlineStatus hook call"
      pattern: "useOnlineStatus\\(\\)"
    - from: "apps/web/src/hooks/mutations/use-create-record.ts"
      to: "apps/web/src/lib/db/pending-mutations.ts"
      via: "queueMutation call in mutationFn when offline"
      pattern: "queueMutation\\("
    - from: "apps/web/src/hooks/mutations/use-delete-record.ts"
      to: "apps/web/src/lib/db/pending-mutations.ts"
      via: "queueMutation call in mutationFn when offline"
      pattern: "queueMutation\\("
---

<objective>
Wire offline mutation queueing into all mutation hooks so edits work seamlessly offline.

Purpose: Close SYNC-07 gap - mutations queue when offline and sync when back online.

Output:
- All mutation hooks check online status before API call
- When offline, mutations queue to IndexedDB via queueMutation()
- SyncRowBadge already shows pending state (wired in 19-03)
- processQueue already processes when coming online (wired in 19-04 SyncProvider)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-sync-protocol/19-VERIFICATION.md
@apps/web/src/hooks/mutations/use-update-record.ts
@apps/web/src/hooks/mutations/use-create-record.ts
@apps/web/src/hooks/mutations/use-delete-record.ts
@apps/web/src/hooks/sync/use-online-status.ts
@apps/web/src/lib/db/pending-mutations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire offline queueing into useUpdateRecord</name>
  <files>
    apps/web/src/hooks/mutations/use-update-record.ts
  </files>
  <action>
Modify `use-update-record.ts` to queue mutations when offline:

1. Add imports at top:
```typescript
import { useOnlineStatus } from '@/hooks/sync/use-online-status';
import { queueMutation } from '@/lib/db/pending-mutations';
```

2. Inside the hook function, call useOnlineStatus:
```typescript
export function useUpdateRecord(orgId: string, accountId: string) {
  const queryClient = useQueryClient();
  const queryKey = queryKeys.records.infinite(orgId, accountId);
  const isOnline = useOnlineStatus();  // ADD THIS
```

3. Modify the mutationFn to check online status:
```typescript
mutationFn: async ({ id, data }: UpdateRecordVariables) => {
  if (!isOnline) {
    // Queue mutation for later sync
    await queueMutation({
      record_id: id,
      table: 'records',
      operation: 'update',
      data: data as Record<string, unknown>,
    });
    // Return optimistic data shape - onMutate already updated cache/IndexedDB
    return { id, ...data } as BookkeepingRecord;
  }
  // Online: call API directly
  return api.updateRecord(id, data);
},
```

IMPORTANT: The optimistic update in onMutate still runs. When offline, we queue the mutation and return a fake success. The SyncRowBadge will show pending (via usePendingMutations), and processQueue will execute when online.

4. Update the retry logic to skip retries when we detect we're offline at execution time:
```typescript
retry: (failureCount, error) => {
  // If we queued offline, don't retry (it's not a real error)
  if (error.message.includes('queued for offline')) return false;
  // ... rest of existing retry logic
}
```
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- useUpdateRecord imports useOnlineStatus and queueMutation
- mutationFn checks isOnline before API call
- When offline, mutation queued to IndexedDB
- Optimistic cache update still works in both cases
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire offline queueing into useCreateRecord</name>
  <files>
    apps/web/src/hooks/mutations/use-create-record.ts
  </files>
  <action>
Modify `use-create-record.ts` to queue mutations when offline:

1. Add imports at top:
```typescript
import { useOnlineStatus } from '@/hooks/sync/use-online-status';
import { queueMutation } from '@/lib/db/pending-mutations';
```

2. Inside the hook function, call useOnlineStatus:
```typescript
export function useCreateRecord(orgId: string, accountId: string) {
  const queryClient = useQueryClient();
  const queryKey = queryKeys.records.infinite(orgId, accountId);
  const isOnline = useOnlineStatus();  // ADD THIS
```

3. The tricky part: onMutate generates a temp ID. We need to use that temp ID as the record_id in the queued mutation. But mutationFn runs BEFORE onMutate. Solution: Generate temp ID in mutationFn when offline.

Modify mutationFn:
```typescript
mutationFn: async (data: RecordCreate) => {
  if (!isOnline) {
    // Generate temp ID here (same pattern as onMutate)
    const tempId = `temp-${crypto.randomUUID()}`;

    // Queue mutation for later sync
    await queueMutation({
      record_id: tempId,
      table: 'records',
      operation: 'create',
      data: { ...data, _tempId: tempId } as Record<string, unknown>,
    });

    // Return optimistic record shape
    return {
      ...data,
      id: tempId,
      ebay_fees_cents: data.ebay_fees_cents ?? null,
      amazon_price_cents: data.amazon_price_cents ?? null,
      amazon_tax_cents: data.amazon_tax_cents ?? null,
      amazon_shipping_cents: data.amazon_shipping_cents ?? null,
      amazon_order_id: data.amazon_order_id ?? null,
      status: data.status ?? "SUCCESSFUL",
      return_label_cost_cents: null,
      order_remark: data.order_remark ?? null,
      service_remark: null,
      profit_cents: 0,
      earnings_net_cents: 0,
      cogs_total_cents: 0,
    } as BookkeepingRecord;
  }
  // Online: call API directly
  return api.createRecord(data);
},
```

4. Also need to update onMutate to not regenerate tempId when offline (we already created it). Use a ref or check if mutation returned a temp ID:

Actually, simpler approach: Let onMutate run as-is. The mutationFn when offline will also add to IndexedDB, but that's fine - we'll just have a duplicate that gets cleaned up. OR: Skip the IndexedDB add in onMutate when offline by checking isOnline.

Best approach: Pass tempId through context. In mutationFn offline case, we don't add to IndexedDB (onMutate does that). The queueMutation queues the mutation data, and processQueue will handle creating the real record later.
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- useCreateRecord imports useOnlineStatus and queueMutation
- mutationFn checks isOnline before API call
- When offline, mutation queued with temp ID
- Optimistic cache update still works
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire offline queueing into useDeleteRecord</name>
  <files>
    apps/web/src/hooks/mutations/use-delete-record.ts
  </files>
  <action>
Modify `use-delete-record.ts` to queue mutations when offline:

1. Add imports at top:
```typescript
import { useOnlineStatus } from '@/hooks/sync/use-online-status';
import { queueMutation } from '@/lib/db/pending-mutations';
```

2. Inside the hook function, call useOnlineStatus:
```typescript
export function useDeleteRecord(orgId: string, accountId: string) {
  const queryClient = useQueryClient();
  const queryKey = queryKeys.records.infinite(orgId, accountId);
  const isOnline = useOnlineStatus();  // ADD THIS
```

3. Modify mutationFn:
```typescript
mutationFn: async (recordId: string) => {
  if (!isOnline) {
    // Queue mutation for later sync
    await queueMutation({
      record_id: recordId,
      table: 'records',
      operation: 'delete',
      data: {},  // Delete doesn't need data
    });
    // Return void - onMutate already updated cache/IndexedDB
    return;
  }
  // Online: call API directly
  return api.deleteRecord(recordId);
},
```

The delete is simpler - onMutate already removes from cache and IndexedDB optimistically. When back online, processQueue will call api.deleteRecord().
  </action>
  <verify>
TypeScript compiles:
```bash
cd apps/web && npx tsc --noEmit
```
  </verify>
  <done>
- useDeleteRecord imports useOnlineStatus and queueMutation
- mutationFn checks isOnline before API call
- When offline, delete queued to IndexedDB
- Optimistic removal still works
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd apps/web && npx tsc --noEmit`
2. App runs: `cd apps/web && npm run dev`
3. Integration test for SYNC-07:
   - Navigate to /admin/order-tracking
   - Go offline (DevTools > Network > Offline)
   - Edit a record field - UI updates immediately
   - Check IndexedDB > _pending_mutations table - mutation should be queued
   - Check row shows pending badge (blue spinner)
   - Go back online
   - Queue should process (console log from SyncProvider)
   - Row badge should disappear
   - Refresh page - change persists from server
</verification>

<success_criteria>
- SYNC-07: Mutations queue when offline and sync when back online
- All three mutation hooks (update, create, delete) check isOnline
- Offline mutations queued via queueMutation()
- Row-level badges reflect pending state (existing from 19-03)
- Queue processes when coming online (existing from 19-04 SyncProvider)
</success_criteria>

<output>
After completion, create `.planning/phases/19-sync-protocol/19-05-SUMMARY.md`
</output>
