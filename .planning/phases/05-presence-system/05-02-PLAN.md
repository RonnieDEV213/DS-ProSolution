---
phase: 05-presence-system
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/web/src/hooks/use-presence.ts
  - apps/web/src/components/presence/occupancy-badge.tsx
  - apps/web/src/components/bookkeeping/account-selector.tsx
  - apps/web/src/lib/api.ts
  - packages/extension/service-worker.js
autonomous: false

must_haves:
  truths:
    - "Account list shows occupancy indicator for each account"
    - "Admin sees VA name and clock-in time on occupied accounts"
    - "VA sees only 'Occupied' on accounts occupied by others"
    - "VA sees 'You' badge on their own occupied account"
    - "Presence updates in real-time via Supabase Realtime"
    - "Extension clears presence on clock-out"
  artifacts:
    - path: "apps/web/src/hooks/use-presence.ts"
      provides: "Realtime subscription hook for presence"
      exports: ["usePresence"]
    - path: "apps/web/src/components/presence/occupancy-badge.tsx"
      provides: "Badge component with admin/VA view logic"
      exports: ["OccupancyBadge"]
    - path: "apps/web/src/components/bookkeeping/account-selector.tsx"
      provides: "Account dropdown with presence indicators"
      contains: "OccupancyBadge"
  key_links:
    - from: "apps/web/src/components/bookkeeping/account-selector.tsx"
      to: "apps/web/src/hooks/use-presence.ts"
      via: "usePresence hook provides presence map"
      pattern: "usePresence"
    - from: "apps/web/src/components/bookkeeping/account-selector.tsx"
      to: "apps/web/src/components/presence/occupancy-badge.tsx"
      via: "OccupancyBadge renders per account"
      pattern: "OccupancyBadge"
    - from: "packages/extension/service-worker.js"
      to: "POST /access-codes/logout"
      via: "clockOut calls logout endpoint"
      pattern: "access-codes/logout"
---

<objective>
Create frontend presence UI: real-time subscription hook, occupancy badge component, and integration into account selector with role-based display.

Purpose: Show VAs and admins who is working on which account, with privacy-preserving display for VAs.

Output:
- usePresence hook with Supabase Realtime subscription
- OccupancyBadge component with admin/VA view variants
- AccountSelector updated to show presence
- Extension clock-out calls backend to clear presence
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-presence-system/05-CONTEXT.md
@.planning/phases/05-presence-system/05-RESEARCH.md

# Prior plan in this phase
@.planning/phases/05-presence-system/05-01-SUMMARY.md

# Key existing files
@apps/web/src/components/bookkeeping/account-selector.tsx
@apps/web/src/lib/api.ts
@apps/web/src/lib/supabase/client.ts
@packages/extension/service-worker.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePresence hook with Realtime subscription</name>
  <files>apps/web/src/hooks/use-presence.ts</files>
  <action>
Create `apps/web/src/hooks/use-presence.ts`:

```typescript
"use client";

import { useEffect, useState } from "react";
import { createClient } from "@/lib/supabase/client";

export interface PresenceEntry {
  account_id: string;
  user_id: string;
  clocked_in_at: string;
  // Joined from profiles - only available for admins via RLS
  display_name?: string | null;
}

interface UsePresenceOptions {
  orgId: string;
  enabled?: boolean;
}

interface UsePresenceResult {
  presence: Map<string, PresenceEntry>;
  loading: boolean;
  error: Error | null;
}

export function usePresence({ orgId, enabled = true }: UsePresenceOptions): UsePresenceResult {
  const [presence, setPresence] = useState<Map<string, PresenceEntry>>(new Map());
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    if (!enabled || !orgId) {
      setLoading(false);
      return;
    }

    const supabase = createClient();

    // Initial fetch
    const fetchPresence = async () => {
      try {
        // Query presence with profile join for display name
        // RLS will filter rows to user's org
        // Note: display_name may be null for VAs depending on RLS
        const { data, error: fetchError } = await supabase
          .from("account_presence")
          .select(`
            account_id,
            user_id,
            clocked_in_at,
            profiles:user_id (display_name)
          `)
          .eq("org_id", orgId);

        if (fetchError) {
          console.error("[usePresence] Fetch error:", fetchError);
          setError(new Error(fetchError.message));
          return;
        }

        const map = new Map<string, PresenceEntry>();
        for (const row of data || []) {
          map.set(row.account_id, {
            account_id: row.account_id,
            user_id: row.user_id,
            clocked_in_at: row.clocked_in_at,
            display_name: (row.profiles as { display_name?: string } | null)?.display_name,
          });
        }
        setPresence(map);
        setError(null);
      } catch (e) {
        console.error("[usePresence] Error:", e);
        setError(e as Error);
      } finally {
        setLoading(false);
      }
    };

    fetchPresence();

    // Subscribe to realtime changes
    const channel = supabase
      .channel(`presence-${orgId}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "account_presence",
          filter: `org_id=eq.${orgId}`,
        },
        async (payload) => {
          setPresence((prev) => {
            const next = new Map(prev);

            if (payload.eventType === "DELETE") {
              // Remove by account_id from old record
              const oldAccountId = (payload.old as { account_id?: string })?.account_id;
              if (oldAccountId) {
                next.delete(oldAccountId);
              }
            } else if (payload.eventType === "INSERT" || payload.eventType === "UPDATE") {
              const newRecord = payload.new as {
                account_id: string;
                user_id: string;
                clocked_in_at: string;
              };

              // For INSERT/UPDATE, we need to fetch display_name separately
              // since realtime doesn't include joined data
              // For now, set entry without display_name; it will be fetched on next render
              next.set(newRecord.account_id, {
                account_id: newRecord.account_id,
                user_id: newRecord.user_id,
                clocked_in_at: newRecord.clocked_in_at,
                display_name: undefined, // Will be populated on next full fetch
              });

              // Refetch to get display_name
              fetchPresence();
            }

            return next;
          });
        }
      )
      .subscribe();

    // Cleanup
    return () => {
      supabase.removeChannel(channel);
    };
  }, [orgId, enabled]);

  return { presence, loading, error };
}
```

Note: The hook refetches on INSERT/UPDATE to get display_name since Realtime doesn't include joined data. This is acceptable for presence updates which are infrequent.
  </action>
  <verify>
- File exists at apps/web/src/hooks/use-presence.ts
- Exports usePresence function
- Contains Supabase channel subscription for postgres_changes
- Contains cleanup via removeChannel in useEffect return
  </verify>
  <done>
usePresence hook created with Realtime subscription and cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create OccupancyBadge component</name>
  <files>apps/web/src/components/presence/occupancy-badge.tsx</files>
  <action>
Create directory and file `apps/web/src/components/presence/occupancy-badge.tsx`:

```typescript
"use client";

import { Badge } from "@/components/ui/badge";

interface OccupancyBadgeProps {
  /** Whether this account is occupied */
  isOccupied: boolean;
  /** Occupant's display name (only provided for admins) */
  occupantName?: string | null;
  /** When the occupant clocked in */
  clockedInAt?: string | null;
  /** Whether current user is the occupant */
  isCurrentUser?: boolean;
}

/**
 * Displays account occupancy status.
 *
 * - Available accounts: No badge shown (available is default state)
 * - VA view of others: Red "Occupied" badge
 * - Admin view: Red badge with "Name * Time" format
 * - Current user's account: Blue "You" badge
 */
export function OccupancyBadge({
  isOccupied,
  occupantName,
  clockedInAt,
  isCurrentUser,
}: OccupancyBadgeProps) {
  // Available accounts show nothing
  if (!isOccupied) {
    return null;
  }

  // Current user's own account - distinct styling
  if (isCurrentUser) {
    return (
      <Badge variant="secondary" className="ml-2 text-xs bg-blue-600 hover:bg-blue-600 text-white">
        You
      </Badge>
    );
  }

  // Admin view with name and time
  if (occupantName) {
    const timeStr = formatClockInTime(clockedInAt);
    return (
      <Badge variant="destructive" className="ml-2 text-xs">
        {occupantName}{timeStr ? ` \u2022 ${timeStr}` : ""}
      </Badge>
    );
  }

  // VA view - just "Occupied"
  return (
    <Badge variant="destructive" className="ml-2 text-xs">
      Occupied
    </Badge>
  );
}

/**
 * Format clock-in time for display.
 * Shows time in 12-hour format with AM/PM.
 */
function formatClockInTime(clockedInAt?: string | null): string | null {
  if (!clockedInAt) return null;

  try {
    const date = new Date(clockedInAt);
    return new Intl.DateTimeFormat("en-US", {
      hour: "numeric",
      minute: "2-digit",
      hour12: true,
    }).format(date);
  } catch {
    return null;
  }
}
```

Key design decisions:
- Available = no badge (per context: "available is the default state")
- Red/destructive variant for occupied
- Blue secondary variant for "You"
- Unicode bullet (\\u2022) for separator between name and time
  </action>
  <verify>
- Directory apps/web/src/components/presence exists
- File occupancy-badge.tsx exports OccupancyBadge
- Component handles: not occupied, occupied (VA view), occupied (admin view), current user
  </verify>
  <done>
OccupancyBadge component created with all view variants.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate presence into AccountSelector and update extension</name>
  <files>apps/web/src/components/bookkeeping/account-selector.tsx, apps/web/src/lib/api.ts, packages/extension/service-worker.js</files>
  <action>
**Part A: Update AccountSelector**

Modify `apps/web/src/components/bookkeeping/account-selector.tsx`:

1. Accept new props for presence integration:
```typescript
interface AccountSelectorProps {
  accounts: Account[];
  selectedAccountId: string | null;
  onSelect: (accountId: string) => void;
  disabled?: boolean;
  // New props for presence
  presence?: Map<string, { user_id: string; display_name?: string | null; clocked_in_at: string }>;
  currentUserId?: string;
  isAdmin?: boolean;
}
```

2. Update the component to show OccupancyBadge next to each account:
```typescript
import { OccupancyBadge } from "@/components/presence/occupancy-badge";

// Inside the map for SelectItem:
{accounts.map((account) => {
  const presenceEntry = presence?.get(account.id);
  const isOccupied = !!presenceEntry;
  const isCurrentUser = presenceEntry?.user_id === currentUserId;

  return (
    <SelectItem
      key={account.id}
      value={account.id}
      className="text-white hover:bg-gray-700"
    >
      <span className="flex items-center">
        {account.account_code}
        {account.name && ` - ${account.name}`}
        <OccupancyBadge
          isOccupied={isOccupied}
          occupantName={isAdmin ? presenceEntry?.display_name : undefined}
          clockedInAt={presenceEntry?.clocked_in_at}
          isCurrentUser={isCurrentUser}
        />
      </span>
    </SelectItem>
  );
})}
```

3. Also add subtle row highlighting for occupied accounts (optional - per context):
```typescript
className={cn(
  "text-white hover:bg-gray-700",
  presenceEntry && !isCurrentUser && "bg-red-950/30"
)}
```

**Part B: Add logout API function**

Add to `apps/web/src/lib/api.ts`:
```typescript
export async function logoutPresence(): Promise<void> {
  await fetchAPI<{ status: string }>("/access-codes/logout", {
    method: "POST",
  });
}
```

**Part C: Update extension clock-out to call backend**

In `packages/extension/service-worker.js`, update the `clockOut` function to call the logout endpoint:

```javascript
/**
 * Clock out user and clear auth state
 * @param {string} reason - 'manual' | 'inactivity' | 'code_rotated' | 'token_expired' | 'roles_changed' | 'permission_fetch_failed'
 */
async function clockOut(reason) {
  const state = await getState();

  // Clear presence on backend if we have a valid token
  if (state.access_token) {
    try {
      await fetch(`${API_BASE}/access-codes/logout`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${state.access_token}`,
          'Content-Type': 'application/json',
        },
      });
      console.log('[SW] Cleared presence on backend');
    } catch (err) {
      console.warn('[SW] Failed to clear presence:', err.message);
      // Continue with local logout even if backend call fails
    }
  }

  await updateState({
    auth_state: 'clocked_out',
    access_token: null,
    access_token_expires_at: null,
    user_context: null,
    roles: [],
    effective_permission_keys: [],
    session_started_at: null,
    clock_out_reason: reason,
  });

  await chrome.alarms.clear('inactivity_warning');
  await chrome.alarms.clear('inactivity_timeout');
  await chrome.alarms.clear('permission_recheck');

  // Broadcast state change to side panels
  broadcastState();

  console.log('[SW] Clocked out:', reason);
}
```

Also update `handleClockIn` to pass account_id (if available from agent state):

```javascript
async function handleClockIn(code, port) {
  port.postMessage({ type: 'CLOCK_IN_STARTED' });

  const state = await getState();

  // Build validation request with optional account_id
  const validateBody = { code };

  // If we have an agent with an account, include it for presence tracking
  // Note: agent.account_id comes from automation agent assignment
  // For now, we don't have this - presence will be recorded via web UI
  // This is a placeholder for future enhancement

  const result = await validateAccessCode(code, validateBody);
  // ... rest of handleClockIn
}
```

Note: The extension currently doesn't have account context at clock-in time. Presence recording via extension will be a future enhancement - for now, presence is managed through the web UI where users select accounts.
  </action>
  <verify>
- AccountSelector accepts presence, currentUserId, isAdmin props
- AccountSelector renders OccupancyBadge for each account
- OccupancyBadge imported in AccountSelector
- api.ts exports logoutPresence function
- Extension clockOut calls /access-codes/logout before clearing local state
  </verify>
  <done>
- AccountSelector shows presence badges
- Extension clears presence on clock-out
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete presence system: database schema, backend API, real-time frontend hook, and UI integration.
  </what-built>
  <how-to-verify>
**Setup (one-time):**
1. Run migration 036_presence_system.sql in Supabase SQL editor
2. Start API: `cd apps/api && uvicorn app.main:app --reload --app-dir src`
3. Start web: `cd apps/web && npm run dev`

**Test 1: Verify presence recording via API**
1. Open API docs at http://localhost:8000/docs
2. Use POST /access-codes/validate with an access code + account_id
3. Check Supabase dashboard: account_presence table should have new row

**Test 2: Verify real-time updates in web UI**
1. Log in as admin at http://localhost:3000
2. Navigate to Bookkeeping page (or any page with account selector)
3. Note: The AccountSelector needs to be updated in its parent component to pass presence props
4. If presence props are wired up, you should see badges on occupied accounts

**Test 3: Verify admin vs VA view**
1. Admin should see "VA Name * 2:30 PM" format
2. VA should see just "Occupied" (no name)
3. User should see "You" badge on their own account

**Test 4: Verify extension clock-out**
1. Open extension, clock in
2. Click "Clock Out"
3. Check Supabase: presence row should be deleted
  </how-to-verify>
  <resume-signal>
Type "approved" if presence system works correctly, or describe any issues found.
  </resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. usePresence hook exists and exports correctly
2. OccupancyBadge component renders correct variants
3. AccountSelector shows badges (when props wired up)
4. Extension calls logout endpoint on clock-out
5. Real-time updates work (manual test via Supabase table insert)
</verification>

<success_criteria>
- [ ] usePresence hook created with Realtime subscription
- [ ] OccupancyBadge handles all display variants (admin/VA/self)
- [ ] AccountSelector updated with presence props
- [ ] logoutPresence API function added
- [ ] Extension clock-out calls backend logout endpoint
- [ ] Human verification of end-to-end flow
</success_criteria>

<output>
After completion, create `.planning/phases/05-presence-system/05-02-SUMMARY.md`
</output>
