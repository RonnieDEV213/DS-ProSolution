---
phase: 01-access-code-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/api/src/app/services/__init__.py
  - apps/api/src/app/services/access_code.py
  - apps/api/src/app/routers/access_codes.py
  - apps/api/src/app/routers/__init__.py
  - apps/api/src/app/main.py
autonomous: true

must_haves:
  truths:
    - "POST /access-codes generates code with prefix and hashed secret"
    - "POST /access-codes/validate returns JWT and user context on valid code"
    - "Invalid code returns generic error without revealing failure reason"
    - "Rate limiting blocks after 10 failed attempts"
  artifacts:
    - path: "apps/api/src/app/services/access_code.py"
      provides: "Access code business logic"
      exports: ["generate_access_code", "validate_access_code", "hash_secret", "verify_secret"]
    - path: "apps/api/src/app/routers/access_codes.py"
      provides: "Access code API endpoints"
      exports: ["router"]
    - path: "apps/api/src/app/main.py"
      provides: "Router registration"
      contains: "access_codes_router"
  key_links:
    - from: "apps/api/src/app/routers/access_codes.py"
      to: "apps/api/src/app/services/access_code.py"
      via: "import"
      pattern: "from app.services.access_code import"
    - from: "apps/api/src/app/routers/access_codes.py"
      to: "database"
      via: "get_supabase"
      pattern: "supabase\\.table\\(\"access_codes\"\\)"
    - from: "apps/api/src/app/main.py"
      to: "apps/api/src/app/routers/access_codes.py"
      via: "include_router"
      pattern: "app\\.include_router\\(access_codes_router\\)"
---

<objective>
Implement access code service layer and API endpoints.

Purpose: Deliver the actual functionality - generating codes, validating them, and returning user context. This is the core of Phase 1.

Output:
- Service module with Argon2 hashing, code generation, validation logic
- API router with POST /access-codes (generate) and POST /access-codes/validate
- Rate limiting integrated with validation endpoint
- JWT generation for successful validation
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-access-code-foundation/01-CONTEXT.md
@.planning/phases/01-access-code-foundation/01-RESEARCH.md
@.planning/phases/01-access-code-foundation/01-01-SUMMARY.md

Existing patterns to follow:
@apps/api/src/app/routers/automation.py (JWT generation, rate limiting patterns)
@apps/api/src/app/auth.py (user context loading)
@apps/api/src/app/database.py (Supabase client)
@apps/api/src/app/models.py (newly added AccessCode models)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create access code service module</name>
  <files>apps/api/src/app/services/__init__.py, apps/api/src/app/services/access_code.py</files>
  <action>
**1. Create services directory if it doesn't exist:**
Create `apps/api/src/app/services/__init__.py` (empty file or with exports)

**2. Create `apps/api/src/app/services/access_code.py`:**

```python
"""Access code generation, hashing, and validation service.

This module handles:
- Cryptographically secure code generation (prefix + secret)
- Argon2id hashing of secrets
- Validation of access codes
- Custom secret validation
"""

import os
import secrets
import string
from datetime import datetime, timedelta, timezone

import jwt
from argon2 import PasswordHasher
from argon2.exceptions import InvalidHashError, VerificationError, VerifyMismatchError

# Constants
ALPHABET = string.ascii_letters + string.digits  # A-Za-z0-9 (62 chars)
PREFIX_LENGTH = 4
SECRET_LENGTH = 12
CODE_EXPIRY_DAYS = 90
ACCESS_TOKEN_EXPIRY_MINUTES = 15

# Argon2 hasher with default (RFC 9106 LOW_MEMORY profile)
ph = PasswordHasher()

# JWT secret for access code tokens (separate from Supabase JWT secret)
ACCESS_CODE_JWT_SECRET = os.getenv("ACCESS_CODE_JWT_SECRET")


def generate_prefix() -> str:
    """Generate 4-character case-sensitive alphanumeric prefix."""
    return "".join(secrets.choice(ALPHABET) for _ in range(PREFIX_LENGTH))


def generate_secret() -> str:
    """Generate 12-character case-sensitive alphanumeric secret."""
    return "".join(secrets.choice(ALPHABET) for _ in range(SECRET_LENGTH))


def validate_custom_secret(secret: str) -> list[str]:
    """Validate custom secret meets requirements.

    Requirements:
    - At least 12 characters
    - Contains at least one uppercase letter
    - Contains at least one lowercase letter
    - Contains at least one digit

    Returns list of validation errors (empty if valid).
    """
    errors = []
    if len(secret) < SECRET_LENGTH:
        errors.append(f"Secret must be at least {SECRET_LENGTH} characters")
    if not any(c.isupper() for c in secret):
        errors.append("Secret must contain at least one uppercase letter")
    if not any(c.islower() for c in secret):
        errors.append("Secret must contain at least one lowercase letter")
    if not any(c.isdigit() for c in secret):
        errors.append("Secret must contain at least one number")
    return errors


def hash_secret(secret: str) -> str:
    """Hash secret with Argon2id.

    Returns hash string that includes algorithm parameters.
    """
    return ph.hash(secret)


def verify_secret(stored_hash: str, provided_secret: str) -> bool:
    """Verify secret against stored hash.

    Returns True if match, False otherwise.
    Handles all Argon2 verification exceptions internally.
    """
    try:
        ph.verify(stored_hash, provided_secret)
        return True
    except (VerifyMismatchError, VerificationError, InvalidHashError):
        return False


def check_needs_rehash(stored_hash: str) -> bool:
    """Check if hash needs to be updated (after parameter changes)."""
    return ph.check_needs_rehash(stored_hash)


def parse_access_code(full_code: str) -> tuple[str, str] | None:
    """Parse access code into prefix and secret.

    Expected format: XXXX-XXXXXXXXXXXX (4 char prefix, hyphen, 12+ char secret)

    Returns (prefix, secret) tuple or None if invalid format.
    """
    if not full_code or "-" not in full_code:
        return None

    parts = full_code.split("-", 1)
    if len(parts) != 2:
        return None

    prefix, secret = parts
    if len(prefix) != PREFIX_LENGTH:
        return None
    if len(secret) < SECRET_LENGTH:
        return None

    return prefix, secret


def calculate_expiry() -> datetime:
    """Calculate expiry datetime (90 days from now)."""
    return datetime.now(timezone.utc) + timedelta(days=CODE_EXPIRY_DAYS)


def generate_access_token(
    user_id: str,
    membership_id: str,
    org_id: str,
) -> tuple[str, int]:
    """Generate JWT for access code authentication.

    Returns (token, expires_in_seconds) tuple.

    The token includes a 'type' claim to distinguish from Supabase tokens.
    """
    if not ACCESS_CODE_JWT_SECRET:
        raise ValueError("ACCESS_CODE_JWT_SECRET environment variable not set")

    now = datetime.now(timezone.utc)
    expires_in = ACCESS_TOKEN_EXPIRY_MINUTES * 60

    payload = {
        "sub": user_id,
        "membership_id": membership_id,
        "org_id": org_id,
        "type": "access_code",  # Distinguish from Supabase tokens
        "iat": now,
        "exp": now + timedelta(minutes=ACCESS_TOKEN_EXPIRY_MINUTES),
    }

    token = jwt.encode(payload, ACCESS_CODE_JWT_SECRET, algorithm="HS256")
    return token, expires_in
```

**3. Update `apps/api/src/app/services/__init__.py`:**

```python
from .access_code import (
    generate_prefix,
    generate_secret,
    validate_custom_secret,
    hash_secret,
    verify_secret,
    check_needs_rehash,
    parse_access_code,
    calculate_expiry,
    generate_access_token,
    PREFIX_LENGTH,
    SECRET_LENGTH,
    CODE_EXPIRY_DAYS,
)

__all__ = [
    "generate_prefix",
    "generate_secret",
    "validate_custom_secret",
    "hash_secret",
    "verify_secret",
    "check_needs_rehash",
    "parse_access_code",
    "calculate_expiry",
    "generate_access_token",
    "PREFIX_LENGTH",
    "SECRET_LENGTH",
    "CODE_EXPIRY_DAYS",
]
```
  </action>
  <verify>
Run from apps/api/src:
```bash
python -c "from app.services.access_code import generate_prefix, hash_secret, verify_secret; p = generate_prefix(); print(f'Prefix: {p}, len={len(p)}'); h = hash_secret('test123'); print(f'Hash starts with: {h[:20]}'); print(f'Verify: {verify_secret(h, \"test123\")}')"
```
Should output prefix of length 4, hash starting with $argon2id$, and Verify: True
  </verify>
  <done>Service module created with all functions working correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create access codes router</name>
  <files>apps/api/src/app/routers/access_codes.py</files>
  <action>
Create `apps/api/src/app/routers/access_codes.py`:

```python
"""Access code endpoints for extension authentication.

Endpoints:
- POST /access-codes: Generate access code for current user
- POST /access-codes/validate: Validate code and return JWT + user context
- POST /access-codes/rotate: Rotate (regenerate) access code secret
- GET /access-codes/me: Get current user's access code info (without secret)
"""

import logging
from datetime import datetime, timezone

from fastapi import APIRouter, Depends, HTTPException, Request
from postgrest.exceptions import APIError

from app.auth import get_current_user_with_membership
from app.database import get_supabase
from app.models import (
    AccessCodeErrorResponse,
    AccessCodeGenerateRequest,
    AccessCodeGenerateResponse,
    AccessCodeInfoResponse,
    AccessCodeRotateRequest,
    AccessCodeRotateResponse,
    AccessCodeUserContext,
    AccessCodeValidateRequest,
    AccessCodeValidateResponse,
    RoleResponse,
)
from app.services.access_code import (
    calculate_expiry,
    generate_access_token,
    generate_prefix,
    generate_secret,
    hash_secret,
    parse_access_code,
    validate_custom_secret,
    verify_secret,
)

router = APIRouter(prefix="/access-codes", tags=["access-codes"])
logger = logging.getLogger(__name__)

# Maximum retries for prefix collision
MAX_PREFIX_RETRIES = 5


def get_client_ip(request: Request) -> str:
    """Extract client IP from request, handling proxies."""
    # Check X-Forwarded-For header first (for proxied requests)
    forwarded = request.headers.get("X-Forwarded-For")
    if forwarded:
        # First IP in the list is the original client
        return forwarded.split(",")[0].strip()
    # Fall back to direct client IP
    return request.client.host if request.client else "0.0.0.0"


# ============================================================
# Generate Access Code (Authenticated)
# ============================================================


@router.post("", response_model=AccessCodeGenerateResponse)
async def generate_access_code(
    body: AccessCodeGenerateRequest = None,
    user: dict = Depends(get_current_user_with_membership),
):
    """
    Generate an access code for the current user.

    If user already has an access code, this replaces it.
    The full code (prefix-secret) is returned ONLY on generation.

    Requires authenticated user with admin or va role.
    """
    membership = user["membership"]
    role = membership.get("role")

    # Only admin and va can have access codes (not clients)
    if role not in ("admin", "va"):
        raise HTTPException(
            status_code=403,
            detail="Only Admin and VA users can generate access codes",
        )

    supabase = get_supabase()
    user_id = user["user_id"]
    org_id = membership["org_id"]

    # Validate custom secret if provided
    if body and body.custom_secret:
        errors = validate_custom_secret(body.custom_secret)
        if errors:
            raise HTTPException(status_code=400, detail={"errors": errors})
        secret = body.custom_secret
    else:
        secret = generate_secret()

    # Generate unique prefix with retry on collision
    prefix = None
    for _ in range(MAX_PREFIX_RETRIES):
        candidate = generate_prefix()
        # Check if prefix exists
        existing = (
            supabase.table("access_codes")
            .select("id")
            .eq("prefix", candidate)
            .execute()
        )
        if not existing.data:
            prefix = candidate
            break

    if prefix is None:
        logger.error("Failed to generate unique prefix after retries")
        raise HTTPException(
            status_code=500,
            detail="Failed to generate access code. Please try again.",
        )

    # Hash the secret
    hashed_secret = hash_secret(secret)
    expires_at = calculate_expiry()

    # Delete existing code for this user (one code per user per org)
    supabase.table("access_codes").delete().eq("user_id", user_id).eq(
        "org_id", org_id
    ).execute()

    # Insert new code
    try:
        result = (
            supabase.table("access_codes")
            .insert(
                {
                    "user_id": user_id,
                    "org_id": org_id,
                    "prefix": prefix,
                    "hashed_secret": hashed_secret,
                    "expires_at": expires_at.isoformat(),
                }
            )
            .execute()
        )
    except APIError as e:
        logger.error(f"Failed to create access code: {e}")
        raise HTTPException(status_code=500, detail="Failed to create access code")

    if not result.data:
        raise HTTPException(status_code=500, detail="Failed to create access code")

    # Return full code (only time user sees the secret)
    full_code = f"{prefix}-{secret}"

    logger.info(f"Generated access code for user {user_id}, prefix: {prefix}")

    return AccessCodeGenerateResponse(
        prefix=prefix,
        full_code=full_code,
        expires_at=expires_at,
    )


# ============================================================
# Rotate Access Code (Authenticated)
# ============================================================


@router.post("/rotate", response_model=AccessCodeRotateResponse)
async def rotate_access_code(
    body: AccessCodeRotateRequest = None,
    user: dict = Depends(get_current_user_with_membership),
):
    """
    Rotate (regenerate) the secret portion of the access code.

    The prefix remains the same. Only the secret is replaced.
    Returns the new full code.
    """
    supabase = get_supabase()
    user_id = user["user_id"]
    org_id = user["membership"]["org_id"]

    # Find existing code
    result = (
        supabase.table("access_codes")
        .select("*")
        .eq("user_id", user_id)
        .eq("org_id", org_id)
        .execute()
    )

    if not result.data:
        raise HTTPException(
            status_code=404,
            detail="No access code found. Generate one first.",
        )

    existing = result.data[0]
    prefix = existing["prefix"]

    # Validate custom secret if provided
    if body and body.custom_secret:
        errors = validate_custom_secret(body.custom_secret)
        if errors:
            raise HTTPException(status_code=400, detail={"errors": errors})
        secret = body.custom_secret
    else:
        secret = generate_secret()

    # Hash new secret
    hashed_secret = hash_secret(secret)
    now = datetime.now(timezone.utc)
    expires_at = calculate_expiry()

    # Update with new secret
    supabase.table("access_codes").update(
        {
            "hashed_secret": hashed_secret,
            "rotated_at": now.isoformat(),
            "expires_at": expires_at.isoformat(),
        }
    ).eq("id", existing["id"]).execute()

    full_code = f"{prefix}-{secret}"

    logger.info(f"Rotated access code for user {user_id}, prefix: {prefix}")

    return AccessCodeRotateResponse(
        prefix=prefix,
        full_code=full_code,
        rotated_at=now,
        expires_at=expires_at,
    )


# ============================================================
# Get Access Code Info (Authenticated)
# ============================================================


@router.get("/me", response_model=AccessCodeInfoResponse)
async def get_my_access_code(
    user: dict = Depends(get_current_user_with_membership),
):
    """
    Get the current user's access code info (without the secret).

    Returns prefix and timestamps. Does not return the secret.
    """
    supabase = get_supabase()
    user_id = user["user_id"]
    org_id = user["membership"]["org_id"]

    result = (
        supabase.table("access_codes")
        .select("prefix, created_at, expires_at, rotated_at")
        .eq("user_id", user_id)
        .eq("org_id", org_id)
        .execute()
    )

    if not result.data:
        raise HTTPException(
            status_code=404,
            detail="No access code found",
        )

    code = result.data[0]

    return AccessCodeInfoResponse(
        prefix=code["prefix"],
        created_at=code["created_at"],
        expires_at=code["expires_at"],
        rotated_at=code.get("rotated_at"),
    )


# ============================================================
# Validate Access Code (Public with Rate Limiting)
# ============================================================


@router.post("/validate", response_model=AccessCodeValidateResponse)
async def validate_access_code(
    body: AccessCodeValidateRequest,
    request: Request,
):
    """
    Validate an access code and return JWT + user context.

    Public endpoint with rate limiting:
    - 10 failed attempts triggers progressive lockout
    - Rate limited by both IP and prefix

    On success:
    - Returns short-lived JWT for extension API calls
    - Returns full user context and RBAC permissions
    """
    supabase = get_supabase()
    client_ip = get_client_ip(request)

    # Parse the code
    parsed = parse_access_code(body.code)
    if parsed is None:
        # Don't reveal that format was wrong
        logger.warning(f"Invalid code format from IP {client_ip}")
        raise HTTPException(
            status_code=401,
            detail=AccessCodeErrorResponse(
                error_code="INVALID_CODE",
                message="Invalid access code",
            ).model_dump(),
        )

    prefix, provided_secret = parsed

    # Check rate limit BEFORE validation (defense in depth)
    try:
        rate_result = supabase.rpc(
            "check_access_code_rate_limit",
            {"p_prefix": prefix, "p_ip": client_ip},
        ).execute()
    except APIError as e:
        logger.error(f"Rate limit check failed: {e}")
        # On error, allow the request (fail open for availability)
        rate_result = None

    if rate_result and rate_result.data:
        rate_data = rate_result.data[0]
        if not rate_data["allowed"]:
            logger.warning(
                f"Rate limited: prefix={prefix}, IP={client_ip}, "
                f"retry_after={rate_data['retry_after_seconds']}"
            )
            raise HTTPException(
                status_code=429,
                detail=AccessCodeErrorResponse(
                    error_code="RATE_LIMITED",
                    message="Too many failed attempts. Please try again later.",
                    retry_after=rate_data["retry_after_seconds"],
                ).model_dump(),
            )

    # Look up the code by prefix
    code_result = (
        supabase.table("access_codes")
        .select("*")
        .eq("prefix", prefix)
        .execute()
    )

    def record_failure():
        """Record failed attempt."""
        try:
            supabase.rpc(
                "record_access_code_attempt",
                {"p_prefix": prefix, "p_ip": client_ip, "p_success": False},
            ).execute()
        except APIError:
            pass  # Don't fail the request if recording fails

    # Check if code exists
    if not code_result.data:
        record_failure()
        logger.warning(f"Code not found: prefix={prefix}, IP={client_ip}")
        raise HTTPException(
            status_code=401,
            detail=AccessCodeErrorResponse(
                error_code="INVALID_CODE",
                message="Invalid access code",
            ).model_dump(),
        )

    code_record = code_result.data[0]

    # Check expiration
    expires_at = datetime.fromisoformat(code_record["expires_at"].replace("Z", "+00:00"))
    if expires_at < datetime.now(timezone.utc):
        record_failure()
        logger.warning(f"Code expired: prefix={prefix}")
        raise HTTPException(
            status_code=401,
            detail=AccessCodeErrorResponse(
                error_code="CODE_EXPIRED",
                message="Access code has expired. Please generate a new one.",
            ).model_dump(),
        )

    # Verify secret (timing-safe via Argon2)
    if not verify_secret(code_record["hashed_secret"], provided_secret):
        record_failure()
        logger.warning(f"Invalid secret for prefix={prefix}, IP={client_ip}")
        raise HTTPException(
            status_code=401,
            detail=AccessCodeErrorResponse(
                error_code="INVALID_CODE",
                message="Invalid access code",
            ).model_dump(),
        )

    # Code is valid! Record success (clears lockouts)
    try:
        supabase.rpc(
            "record_access_code_attempt",
            {"p_prefix": prefix, "p_ip": client_ip, "p_success": True},
        ).execute()
    except APIError:
        pass

    # Load user and membership
    user_id = code_record["user_id"]
    org_id = code_record["org_id"]

    # Get membership
    membership_result = (
        supabase.table("memberships")
        .select("id, role, status, org_id")
        .eq("user_id", user_id)
        .eq("org_id", org_id)
        .execute()
    )

    if not membership_result.data:
        logger.error(f"No membership found for user {user_id}")
        raise HTTPException(
            status_code=401,
            detail=AccessCodeErrorResponse(
                error_code="ACCOUNT_DISABLED",
                message="Account not found or disabled.",
            ).model_dump(),
        )

    membership = membership_result.data[0]

    # Check if suspended
    if membership.get("status") == "suspended":
        logger.warning(f"Suspended user attempted validation: {user_id}")
        raise HTTPException(
            status_code=401,
            detail=AccessCodeErrorResponse(
                error_code="ACCOUNT_DISABLED",
                message="Account is suspended. Contact an administrator.",
            ).model_dump(),
        )

    # Get user profile
    profile_result = (
        supabase.table("profiles")
        .select("display_name, email")
        .eq("user_id", user_id)
        .execute()
    )

    profile = profile_result.data[0] if profile_result.data else {}

    # Build user context
    is_admin = membership["role"] == "admin"
    user_context = AccessCodeUserContext(
        id=user_id,
        name=profile.get("display_name"),
        email=profile.get("email", ""),
        user_type=membership["role"],
        org_id=org_id,
        is_admin=is_admin,
    )

    # Get roles and permissions
    roles = []
    permission_keys = set()

    if is_admin:
        # Admins have all permissions - no need to fetch roles
        # Get all permission keys from department_roles for the org
        all_perms_result = (
            supabase.table("department_roles")
            .select("permissions")
            .eq("org_id", org_id)
            .execute()
        )
        for row in all_perms_result.data or []:
            permission_keys.update(row.get("permissions", []))
    else:
        # Get VA's assigned roles
        assigned_result = supabase.rpc(
            "get_membership_permission_keys",
            {"p_membership_id": membership["id"]},
        ).execute()

        for row in assigned_result.data or []:
            permission_keys.add(row["permission_key"])

        # Get role details
        roles_result = (
            supabase.table("membership_dept_roles")
            .select("department_roles(id, name, position, permissions)")
            .eq("membership_id", membership["id"])
            .execute()
        )

        for row in roles_result.data or []:
            dept_role = row.get("department_roles", {})
            if dept_role:
                roles.append(
                    RoleResponse(
                        id=dept_role["id"],
                        name=dept_role["name"],
                        priority=dept_role.get("position", 0),
                        permission_keys=dept_role.get("permissions", []),
                    )
                )

    # Get RBAC version (most recent department_role update)
    rbac_result = (
        supabase.table("department_roles")
        .select("updated_at")
        .eq("org_id", org_id)
        .order("updated_at", desc=True)
        .limit(1)
        .execute()
    )

    rbac_version = (
        rbac_result.data[0]["updated_at"]
        if rbac_result.data
        else datetime.now(timezone.utc).isoformat()
    )

    # Generate JWT
    access_token, expires_in = generate_access_token(
        user_id=user_id,
        membership_id=membership["id"],
        org_id=org_id,
    )

    logger.info(f"Access code validated for user {user_id}, prefix={prefix}")

    return AccessCodeValidateResponse(
        access_token=access_token,
        expires_in=expires_in,
        user=user_context,
        roles=roles,
        effective_permission_keys=sorted(permission_keys),
        rbac_version=rbac_version,
    )
```
  </action>
  <verify>
From apps/api/src directory:
```bash
python -c "from app.routers.access_codes import router; print(f'Routes: {[r.path for r in router.routes]}')"
```
Should show routes: ['', '/rotate', '/me', '/validate']
  </verify>
  <done>Router created with all endpoints (generate, rotate, me, validate)</done>
</task>

<task type="auto">
  <name>Task 3: Register router in main.py</name>
  <files>apps/api/src/app/routers/__init__.py, apps/api/src/app/main.py</files>
  <action>
**1. Update `apps/api/src/app/routers/__init__.py`:**
Add the access_codes router export:

```python
from .accounts import router as accounts_router
from .access_codes import router as access_codes_router
from .admin import router as admin_router
from .auth import router as auth_router
from .automation import router as automation_router
from .records import router as records_router

__all__ = [
    "accounts_router",
    "access_codes_router",
    "admin_router",
    "auth_router",
    "automation_router",
    "records_router",
]
```

**2. Update `apps/api/src/app/main.py`:**
Add the import and include_router call:

```python
# In imports section, update:
from app.routers import (
    accounts_router,
    access_codes_router,
    admin_router,
    auth_router,
    automation_router,
    records_router,
)

# In router registration section, add:
app.include_router(access_codes_router)
```

The full include_router section should look like:
```python
# Include routers
app.include_router(accounts_router)
app.include_router(access_codes_router)
app.include_router(admin_router)
app.include_router(auth_router)
app.include_router(automation_router)
app.include_router(records_router)
```
  </action>
  <verify>
Start the API server and check routes:
```bash
cd apps/api
uvicorn app.main:app --reload --app-dir src &
sleep 3
curl http://localhost:8000/docs 2>/dev/null | grep -o "access-codes" | head -1
```
Or visit http://localhost:8000/docs in browser and verify /access-codes endpoints appear
  </verify>
  <done>Access codes router registered and visible in API docs at /docs</done>
</task>

</tasks>

<verification>
1. Service: All functions work (generate, hash, verify)
2. Router: All endpoints defined and importable
3. Integration: Router appears in /docs
4. End-to-end test flow (manual):
   - Generate code as authenticated user
   - Validate code and receive JWT
   - Invalid code returns generic error
   - Multiple failures trigger rate limit
</verification>

<success_criteria>
- POST /access-codes generates code with prefix-secret format
- POST /access-codes/validate returns JWT + user context on valid code
- Invalid codes return generic "Invalid access code" message
- 10+ failed attempts triggers rate limiting with retry_after
- All endpoints visible in /docs
</success_criteria>

<output>
After completion, create `.planning/phases/01-access-code-foundation/01-02-SUMMARY.md`
</output>
