---
phase: 13-worker-status-dashboard-metrics
plan: 04
type: execute
wave: 3
depends_on: ["13-02", "13-03"]
files_modified:
  - apps/web/src/components/admin/collection/progress-detail-modal.tsx
autonomous: true

must_haves:
  truths:
    - "Modal has 2-panel layout: workers (left) + metrics/pipeline (right)"
    - "All 5 worker cards visible without scrolling on left panel"
    - "Clicking worker card replaces left panel with worker detail view"
    - "Back button returns from worker detail to worker cards"
    - "Client-side metrics aggregation updates on each SSE event"
    - "Minimized state still shows floating indicator"
  artifacts:
    - path: "apps/web/src/components/admin/collection/progress-detail-modal.tsx"
      provides: "Rewritten modal with 2-panel layout and state management"
      contains: "expandedWorkerId"
  key_links:
    - from: "progress-detail-modal.tsx"
      to: "worker-status-panel.tsx"
      via: "renders when expandedWorkerId is null"
      pattern: "expandedWorkerId === null.*WorkerStatusPanel"
    - from: "progress-detail-modal.tsx"
      to: "worker-detail-view.tsx"
      via: "renders when expandedWorkerId is set"
      pattern: "expandedWorkerId !== null.*WorkerDetailView"
    - from: "progress-detail-modal.tsx"
      to: "metrics-panel.tsx"
      via: "always rendered in right panel"
      pattern: "MetricsPanel"
---

<objective>
Rewrite progress-detail-modal with 2-panel layout and client-side metrics aggregation

Purpose: Complete the worker status dashboard per CONTEXT.md with full worker transparency and click-to-expand
Output: Fully functional 2-panel modal with worker cards, expanded detail view, and metrics panel
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-worker-status-dashboard-metrics/13-CONTEXT.md
@.planning/phases/13-worker-status-dashboard-metrics/13-RESEARCH.md
@.planning/phases/13-worker-status-dashboard-metrics/13-02-SUMMARY.md
@.planning/phases/13-worker-status-dashboard-metrics/13-03-SUMMARY.md
@apps/web/src/components/admin/collection/progress-detail-modal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite Modal with 2-Panel Layout and State Management</name>
  <files>apps/web/src/components/admin/collection/progress-detail-modal.tsx</files>
  <action>
Rewrite `progress-detail-modal.tsx` to implement the 2-panel layout with all new components.

**Key changes:**
1. Import new components (WorkerStatusPanel, WorkerDetailView, MetricsPanel)
2. Add state for expandedWorkerId and workerMetrics
3. Implement client-side metrics aggregation in SSE handler
4. Create 2-panel grid layout
5. Conditionally render worker cards vs expanded detail view

```typescript
"use client";

import { useState, useEffect, useCallback } from "react";
import { createClient } from "@/lib/supabase/client";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Minimize2, ShoppingCart, Search, Clock } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { ActivityEntry, WorkerMetrics } from "./activity-feed";
import { WorkerStatusPanel } from "./worker-status-panel";
import { WorkerDetailView } from "./worker-detail-view";
import { MetricsPanel } from "./metrics-panel";

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || "http://localhost:8000";

interface ProgressDetailModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  progress: {
    run_id?: string;
    phase: "amazon" | "ebay";
    departments_total: number;
    departments_completed: number;
    categories_total: number;
    categories_completed: number;
    products_found: number;
    products_total: number;
    products_searched: number;
    sellers_found: number;
    sellers_new: number;
    started_at?: string;
  } | null;
  isMinimized: boolean;
  onMinimizeChange: (minimized: boolean) => void;
  onCancel: () => void;
}

function formatDuration(startedAt: string): string {
  const start = new Date(startedAt);
  const now = new Date();
  const diffMs = now.getTime() - start.getTime();
  const diffSeconds = Math.floor(diffMs / 1000);
  const minutes = Math.floor(diffSeconds / 60);
  const seconds = diffSeconds % 60;

  if (minutes === 0) {
    return `${seconds}s`;
  }
  return `${minutes}m ${seconds}s`;
}

// Initialize empty metrics for a worker
function createEmptyMetrics(workerId: number): WorkerMetrics {
  return {
    worker_id: workerId,
    api_requests_total: 0,
    api_requests_success: 0,
    api_requests_failed: 0,
    api_retries: 0,
    total_duration_ms: 0,
    products_found: 0,
    sellers_found: 0,
    sellers_new: 0,
    errors_by_type: {},
    last_activity: undefined,
  };
}

export function ProgressDetailModal({
  open,
  onOpenChange,
  progress,
  isMinimized,
  onMinimizeChange,
  onCancel,
}: ProgressDetailModalProps) {
  const [duration, setDuration] = useState<string>("");
  const [activities, setActivities] = useState<ActivityEntry[]>([]);
  const [expandedWorkerId, setExpandedWorkerId] = useState<number | null>(null);
  const [workerMetrics, setWorkerMetrics] = useState<Map<number, WorkerMetrics>>(
    () => new Map([1, 2, 3, 4, 5].map((id) => [id, createEmptyMetrics(id)]))
  );
  const supabase = createClient();

  // Update duration timer every second
  useEffect(() => {
    if (!progress?.started_at) {
      setDuration("");
      return;
    }

    setDuration(formatDuration(progress.started_at));
    const interval = setInterval(() => {
      setDuration(formatDuration(progress.started_at!));
    }, 1000);

    return () => clearInterval(interval);
  }, [progress?.started_at]);

  // Client-side metrics aggregation from activity events
  const updateMetrics = useCallback((activity: ActivityEntry) => {
    if (activity.worker_id <= 0) return; // Skip system events

    setWorkerMetrics((prev) => {
      const newMap = new Map(prev);
      const metrics = newMap.get(activity.worker_id) || createEmptyMetrics(activity.worker_id);

      // Update last activity
      metrics.last_activity = activity;

      // Count requests
      if (activity.action === "fetching") {
        metrics.api_requests_total += 1;
        if (activity.attempt && activity.attempt > 1) {
          metrics.api_retries += 1;
        }
      }

      // Track success/failure
      if (activity.action === "found") {
        metrics.api_requests_success += 1;
        if (activity.duration_ms) {
          metrics.total_duration_ms += activity.duration_ms;
        }
        // Track output
        if (activity.phase === "amazon") {
          metrics.products_found += activity.new_sellers_count || 0;
        } else {
          metrics.sellers_found += activity.new_sellers_count || 0;
        }
      }

      if (activity.action === "error") {
        metrics.api_requests_failed += 1;
        // Track error type
        const errorType = activity.error_type || "other";
        metrics.errors_by_type[errorType] = (metrics.errors_by_type[errorType] || 0) + 1;
      }

      if (activity.action === "rate_limited") {
        // Rate limited counts as a request attempt
        const rateType = "rate_limit";
        metrics.errors_by_type[rateType] = (metrics.errors_by_type[rateType] || 0) + 1;
      }

      newMap.set(activity.worker_id, metrics);
      return newMap;
    });
  }, []);

  // SSE activity stream subscription
  useEffect(() => {
    if (!open || !progress?.run_id) {
      setActivities([]);
      // Reset metrics when modal closes/reopens
      setWorkerMetrics(new Map([1, 2, 3, 4, 5].map((id) => [id, createEmptyMetrics(id)])));
      setExpandedWorkerId(null);
      return;
    }

    let eventSource: EventSource | null = null;

    const connectSSE = async () => {
      try {
        const { data: { session } } = await supabase.auth.getSession();
        if (!session) return;

        const url = `${API_BASE}/collection/runs/${progress.run_id}/activity?token=${session.access_token}`;
        eventSource = new EventSource(url);

        eventSource.onmessage = (event) => {
          try {
            const activity = JSON.parse(event.data) as ActivityEntry;
            if (activity.action === "connected") {
              console.log("SSE activity stream connected");
              return;
            }

            // Add to activities (newest first)
            setActivities((prev) => [activity, ...prev].slice(0, 100));

            // Update metrics
            updateMetrics(activity);
          } catch (e) {
            console.error("Failed to parse activity:", e);
          }
        };

        eventSource.onerror = () => {
          console.log("SSE connection error, auto-reconnecting...");
        };
      } catch (e) {
        console.error("Failed to connect SSE:", e);
      }
    };

    connectSSE();

    return () => {
      if (eventSource) {
        eventSource.close();
      }
    };
  }, [open, progress?.run_id, supabase.auth, updateMetrics]);

  if (!progress) return null;

  const phase = progress.phase || "amazon";

  const getProgressPercent = () => {
    if (phase === "amazon") {
      return progress.categories_total > 0
        ? Math.round((progress.categories_completed / progress.categories_total) * 100)
        : 0;
    } else {
      return progress.products_total > 0
        ? Math.round((progress.products_searched / progress.products_total) * 100)
        : 0;
    }
  };

  const progressPercent = getProgressPercent();

  // Calculate total metrics for detail view
  const totalMetrics = {
    total_requests: Array.from(workerMetrics.values()).reduce(
      (sum, m) => sum + m.api_requests_total, 0
    ),
    total_errors: Array.from(workerMetrics.values()).reduce(
      (sum, m) => sum + m.api_requests_failed, 0
    ),
    total_sellers: progress.sellers_found,
  };

  // Minimized floating indicator (unchanged from before)
  if (isMinimized) {
    return (
      <div
        onClick={() => onMinimizeChange(false)}
        className="fixed bottom-4 right-4 bg-gray-800 border border-gray-700 rounded-lg p-3 cursor-pointer shadow-lg z-50 min-w-[200px] hover:bg-gray-750"
      >
        <div className="flex items-center justify-between mb-2">
          <span className="text-sm font-medium text-white">Collection Running</span>
          <Badge
            className={`text-xs ${
              phase === "amazon"
                ? "bg-orange-500/20 text-orange-400"
                : "bg-blue-500/20 text-blue-400"
            }`}
          >
            {phase === "amazon" ? "Amazon" : "eBay"}: {progressPercent}%
          </Badge>
        </div>
        <div className="h-1.5 bg-gray-700 rounded overflow-hidden">
          <div
            className={`h-full transition-all ${
              phase === "amazon" ? "bg-orange-500" : "bg-blue-500"
            }`}
            style={{ width: `${progressPercent}%` }}
          />
        </div>
        <div className="text-xs text-gray-400 mt-1">
          {phase === "amazon"
            ? `${progress.categories_completed}/${progress.categories_total} categories`
            : `${progress.products_searched}/${progress.products_total} products`}
        </div>
      </div>
    );
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="bg-gray-900 border-gray-800 max-w-5xl max-h-[85vh]">
        <DialogHeader>
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <DialogTitle className="text-white">Collection Progress</DialogTitle>
              {/* Phase badge */}
              <Badge
                className={
                  phase === "amazon"
                    ? "bg-orange-500/20 text-orange-400"
                    : "bg-blue-500/20 text-blue-400"
                }
              >
                {phase === "amazon" ? (
                  <>
                    <ShoppingCart className="h-3 w-3 mr-1" />
                    Amazon: {progressPercent}%
                  </>
                ) : (
                  <>
                    <Search className="h-3 w-3 mr-1" />
                    eBay: {progressPercent}%
                  </>
                )}
              </Badge>
              {/* Duration */}
              {progress.started_at && duration && (
                <span className="text-sm text-gray-500 flex items-center gap-1">
                  <Clock className="h-3 w-3" />
                  {duration}
                </span>
              )}
            </div>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onMinimizeChange(true)}
              className="text-gray-400 hover:text-white"
            >
              <Minimize2 className="h-4 w-4" />
            </Button>
          </div>
        </DialogHeader>

        {/* 2-Panel Layout */}
        <div className="grid grid-cols-[1fr_320px] gap-6 h-[calc(85vh-120px)]">
          {/* Left Panel: Workers */}
          <div className="overflow-hidden">
            {expandedWorkerId === null ? (
              <WorkerStatusPanel
                activities={activities}
                workerMetrics={workerMetrics}
                onExpandWorker={setExpandedWorkerId}
              />
            ) : (
              <WorkerDetailView
                workerId={expandedWorkerId}
                activities={activities}
                metrics={workerMetrics.get(expandedWorkerId)}
                totalMetrics={totalMetrics}
                onBack={() => setExpandedWorkerId(null)}
              />
            )}
          </div>

          {/* Right Panel: Metrics + Pipeline */}
          <div className="border-l border-gray-800 pl-6 overflow-hidden">
            <MetricsPanel
              activities={activities}
              workerMetrics={workerMetrics}
              progress={{
                phase,
                sellers_found: progress.sellers_found,
                sellers_new: progress.sellers_new,
                products_found: progress.products_found,
              }}
              expandedWorkerId={expandedWorkerId}
              onExpandWorker={setExpandedWorkerId}
            />
          </div>
        </div>

        {/* Footer: Cancel button */}
        <div className="flex justify-end pt-4 border-t border-gray-800">
          <Button
            variant="destructive"
            onClick={onCancel}
            className="bg-red-600 hover:bg-red-700"
          >
            Cancel Collection
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

**Key implementation details:**

1. **State management:**
   - `expandedWorkerId: number | null` - which worker is expanded (null = show all cards)
   - `workerMetrics: Map<number, WorkerMetrics>` - aggregated metrics per worker

2. **Client-side metrics aggregation:**
   - `updateMetrics()` callback processes each SSE event
   - Tracks: requests total, success, failed, retries, duration, output counts
   - Tracks errors by type (rate_limit, timeout, http_error, parse_error)
   - Updates on each event, not polled

3. **Layout:**
   - `grid-cols-[1fr_320px]` - left panel flexible, right panel fixed 320px
   - `max-w-5xl` instead of `max-w-2xl` - wider modal for 2-panel layout
   - `max-h-[85vh]` - constrain height to viewport

4. **Panel switching:**
   - `expandedWorkerId === null` renders WorkerStatusPanel
   - `expandedWorkerId !== null` renders WorkerDetailView
   - Back button in WorkerDetailView calls `setExpandedWorkerId(null)`

5. **Minimized state:**
   - Unchanged from current implementation - floating indicator in corner
  </action>
  <verify>
1. TypeScript compiles: `cd apps/web && npm run build`
2. Modal renders with 2-panel layout
3. Clicking worker card switches to expanded view
4. Back button returns to worker cards
5. Metrics update in real-time as SSE events arrive
  </verify>
  <done>
- Modal has 2-panel layout (workers left, metrics right)
- All 5 worker cards visible on left panel
- Click worker card expands to detail view with back button
- Client-side metrics aggregation via updateMetrics callback
- MetricsPanel shows pipeline feed and error breakdown
- Minimized state unchanged - floating indicator works
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify Integration and Test End-to-End</name>
  <files>apps/web/src/components/admin/collection/progress-detail-modal.tsx</files>
  <action>
Verify all imports are correct and perform final integration checks.

1. **Verify imports at top of file:**
```typescript
import { ActivityEntry, WorkerMetrics } from "./activity-feed";
import { WorkerStatusPanel } from "./worker-status-panel";
import { WorkerDetailView } from "./worker-detail-view";
import { MetricsPanel } from "./metrics-panel";
```

2. **Check component file existence:**
   - `activity-feed.tsx` - should export ActivityEntry, WorkerMetrics, deriveWorkerState
   - `worker-card.tsx` - should export WorkerCard
   - `worker-status-panel.tsx` - should export WorkerStatusPanel
   - `worker-detail-view.tsx` - should export WorkerDetailView
   - `pipeline-feed.tsx` - should export PipelineFeed
   - `metrics-summary.tsx` - should export MetricsSummary
   - `metrics-panel.tsx` - should export MetricsPanel

3. **Build and verify no errors:**
```bash
cd apps/web && npm run build
```

4. **Manual testing checklist (for user verification):**
   - [ ] Start a collection run
   - [ ] Open progress detail modal
   - [ ] Verify 5 worker cards visible on left
   - [ ] Click a worker card - should show expanded view
   - [ ] Verify back button returns to cards
   - [ ] Verify metrics update in real-time
   - [ ] Verify pipeline feed shows system events
   - [ ] Verify error breakdown appears when errors occur
   - [ ] Verify minimize button works
   - [ ] Verify cancel button works
  </action>
  <verify>
1. `npm run build` succeeds with no errors
2. All component imports resolve correctly
3. TypeScript types match between components
  </verify>
  <done>
- All imports verified and working
- Build succeeds
- Components integrate correctly
- Ready for user testing
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds in apps/web
2. Modal renders with 2-panel layout
3. Worker cards show real-time status from SSE events
4. Click-to-expand works with back button
5. Metrics panel updates as events arrive
6. Pipeline feed shows system events (worker_id=0)
7. Error breakdown appears when errors exist
8. Minimize/cancel buttons work
</verification>

<success_criteria>
- 2-panel layout: workers (left 1fr) + metrics (right 320px)
- All 5 worker cards visible without scrolling
- Click worker card -> expanded detail view with metrics + log
- Back button returns to worker cards view
- Client-side metrics aggregation on each SSE event
- Pipeline feed shows uploading, deduped, inserted, updated events
- Error breakdown distinguishes API errors from parse errors
- Minimized floating indicator unchanged
- Cancel button works
</success_criteria>

<output>
After completion, create `.planning/phases/13-worker-status-dashboard-metrics/13-04-SUMMARY.md`
</output>
