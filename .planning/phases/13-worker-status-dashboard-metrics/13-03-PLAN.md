---
phase: 13-worker-status-dashboard-metrics
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - apps/web/src/components/admin/collection/pipeline-feed.tsx
  - apps/web/src/components/admin/collection/metrics-summary.tsx
  - apps/web/src/components/admin/collection/metrics-panel.tsx
autonomous: true

must_haves:
  truths:
    - "Pipeline feed shows scrolling activity feed of system operations"
    - "Pipeline events display: uploading products, deduped sellers, inserted sellers, updated sellers"
    - "Metrics summary shows total failure counts with breakdown by type"
    - "Error breakdown distinguishes API errors from parse errors"
    - "Mini worker status icons show other workers when one is expanded"
  artifacts:
    - path: "apps/web/src/components/admin/collection/pipeline-feed.tsx"
      provides: "Scrolling feed of data pipeline operations"
      exports: ["PipelineFeed"]
    - path: "apps/web/src/components/admin/collection/metrics-summary.tsx"
      provides: "Aggregated metrics with error breakdown"
      exports: ["MetricsSummary"]
    - path: "apps/web/src/components/admin/collection/metrics-panel.tsx"
      provides: "Right panel container combining feed, summary, mini status"
      exports: ["MetricsPanel"]
  key_links:
    - from: "metrics-panel.tsx"
      to: "pipeline-feed.tsx"
      via: "renders PipelineFeed with pipeline events"
      pattern: "PipelineFeed.*activities="
    - from: "metrics-panel.tsx"
      to: "metrics-summary.tsx"
      via: "renders MetricsSummary with aggregated metrics"
      pattern: "MetricsSummary.*metrics="
---

<objective>
Create metrics panel components for right side of 2-panel layout

Purpose: Display data pipeline operations and aggregated metrics with error breakdown per CONTEXT.md decisions
Output: PipelineFeed, MetricsSummary, MetricsPanel components
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-worker-status-dashboard-metrics/13-CONTEXT.md
@.planning/phases/13-worker-status-dashboard-metrics/13-RESEARCH.md
@.planning/phases/13-worker-status-dashboard-metrics/13-01-SUMMARY.md
@apps/web/src/components/admin/collection/activity-feed.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PipelineFeed and MetricsSummary Components</name>
  <files>
    apps/web/src/components/admin/collection/pipeline-feed.tsx
    apps/web/src/components/admin/collection/metrics-summary.tsx
  </files>
  <action>
Create `pipeline-feed.tsx` - scrolling feed of data pipeline operations:

```typescript
"use client";

import { useRef, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Badge } from "@/components/ui/badge";
import {
  Upload,
  Copy,
  Plus,
  RefreshCw,
  Database,
  User,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { formatDistanceToNow } from "date-fns";
import { ActivityEntry } from "./activity-feed";

interface PipelineFeedProps {
  activities: ActivityEntry[];
  maxEntries?: number;
}

// Filter to only pipeline actions (worker_id=0 system events)
const PIPELINE_ACTIONS = ["uploading", "deduped", "inserted", "updated"];

const pipelineIcons: Record<string, React.ReactNode> = {
  uploading: <Upload className="h-3.5 w-3.5" />,
  deduped: <Copy className="h-3.5 w-3.5" />,
  inserted: <Plus className="h-3.5 w-3.5" />,
  updated: <RefreshCw className="h-3.5 w-3.5" />,
};

const pipelineColors: Record<string, string> = {
  uploading: "border-l-purple-400 bg-purple-900/20",
  deduped: "border-l-gray-400 bg-gray-800/50",
  inserted: "border-l-green-400 bg-green-900/20",
  updated: "border-l-blue-400 bg-blue-900/20",
};

function formatPipelineMessage(entry: ActivityEntry): string {
  const count = entry.items_count || 0;

  switch (entry.action) {
    case "uploading":
      return `Uploading ${count} products to database`;
    case "deduped":
      return `Deduped ${count} duplicate sellers`;
    case "inserted":
      const source = entry.source_worker_id
        ? ` from Worker ${entry.source_worker_id}`
        : "";
      return `Inserted ${count} new sellers${source}`;
    case "updated":
      return `Updated ${count} existing sellers`;
    default:
      return entry.action;
  }
}

function PipelineCard({ entry }: { entry: ActivityEntry }) {
  return (
    <motion.div
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: -20 }}
      transition={{ duration: 0.2 }}
      className={cn(
        "p-2 rounded border-l-4",
        pipelineColors[entry.action] || "border-l-gray-400 bg-gray-800/50"
      )}
    >
      <div className="flex items-center gap-2">
        <div className="text-gray-400">
          {pipelineIcons[entry.action] || <Database className="h-3.5 w-3.5" />}
        </div>
        <div className="flex-1 min-w-0">
          <div className="text-sm text-gray-200">
            {formatPipelineMessage(entry)}
          </div>
          {entry.source_worker_id && entry.source_worker_id > 0 && (
            <Badge className="text-[9px] mt-1 bg-gray-700/50 text-gray-400">
              <User className="h-2 w-2 mr-0.5" />
              W{entry.source_worker_id}
            </Badge>
          )}
        </div>
        <div className="text-[10px] text-gray-500">
          {formatDistanceToNow(new Date(entry.timestamp), { addSuffix: true })}
        </div>
      </div>
    </motion.div>
  );
}

export function PipelineFeed({ activities, maxEntries = 30 }: PipelineFeedProps) {
  const containerRef = useRef<HTMLDivElement>(null);

  // Filter to pipeline-only events
  const pipelineActivities = activities.filter(
    (a) => a.worker_id === 0 && PIPELINE_ACTIONS.includes(a.action)
  );

  // Auto-scroll to top on new entries
  useEffect(() => {
    if (containerRef.current) {
      containerRef.current.scrollTop = 0;
    }
  }, [pipelineActivities.length]);

  const displayedActivities = pipelineActivities.slice(0, maxEntries);

  if (displayedActivities.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-24 text-gray-500 text-sm">
        <Database className="h-5 w-5 mb-2 opacity-50" />
        <span>Waiting for pipeline activity...</span>
      </div>
    );
  }

  return (
    <div
      ref={containerRef}
      className="space-y-1.5 max-h-[200px] overflow-y-auto pr-1"
    >
      <AnimatePresence mode="popLayout">
        {displayedActivities.map((entry) => (
          <PipelineCard key={entry.id} entry={entry} />
        ))}
      </AnimatePresence>
    </div>
  );
}
```

Create `metrics-summary.tsx` - aggregated metrics with error breakdown:

```typescript
"use client";

import { Badge } from "@/components/ui/badge";
import {
  Activity,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Clock,
  Users,
  ShoppingCart,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { WorkerMetrics } from "./activity-feed";

interface MetricsSummaryProps {
  workerMetrics: Map<number, WorkerMetrics>;
  sellersFound: number;
  sellersNew: number;
  productsFound: number;
  phase: "amazon" | "ebay";
}

interface ErrorBreakdown {
  rate_limit: number;
  timeout: number;
  http_error: number;
  parse_error: number;
  other: number;
}

function aggregateMetrics(workerMetrics: Map<number, WorkerMetrics>): {
  totalRequests: number;
  totalSuccess: number;
  totalFailed: number;
  totalRetries: number;
  avgResponseTime: number;
  errorBreakdown: ErrorBreakdown;
} {
  let totalRequests = 0;
  let totalSuccess = 0;
  let totalFailed = 0;
  let totalRetries = 0;
  let totalDuration = 0;

  const errorBreakdown: ErrorBreakdown = {
    rate_limit: 0,
    timeout: 0,
    http_error: 0,
    parse_error: 0,
    other: 0,
  };

  workerMetrics.forEach((metrics) => {
    totalRequests += metrics.api_requests_total;
    totalSuccess += metrics.api_requests_success;
    totalFailed += metrics.api_requests_failed;
    totalRetries += metrics.api_retries;
    totalDuration += metrics.total_duration_ms;

    // Aggregate error breakdown
    Object.entries(metrics.errors_by_type).forEach(([type, count]) => {
      if (type.includes("rate_limit") || type === "rate_limited") {
        errorBreakdown.rate_limit += count;
      } else if (type.includes("timeout")) {
        errorBreakdown.timeout += count;
      } else if (type.includes("http")) {
        errorBreakdown.http_error += count;
      } else if (type.includes("parse")) {
        errorBreakdown.parse_error += count;
      } else {
        errorBreakdown.other += count;
      }
    });
  });

  const avgResponseTime = totalRequests > 0
    ? Math.round(totalDuration / totalRequests)
    : 0;

  return {
    totalRequests,
    totalSuccess,
    totalFailed,
    totalRetries,
    avgResponseTime,
    errorBreakdown,
  };
}

function StatCard({
  icon,
  label,
  value,
  color = "text-white",
}: {
  icon: React.ReactNode;
  label: string;
  value: string | number;
  color?: string;
}) {
  return (
    <div className="bg-gray-800/50 rounded p-2">
      <div className="flex items-center gap-1.5 text-gray-400 text-[10px] uppercase mb-1">
        {icon}
        {label}
      </div>
      <div className={cn("text-lg font-bold", color)}>{value}</div>
    </div>
  );
}

export function MetricsSummary({
  workerMetrics,
  sellersFound,
  sellersNew,
  productsFound,
  phase,
}: MetricsSummaryProps) {
  const aggregated = aggregateMetrics(workerMetrics);
  const hasErrors = aggregated.totalFailed > 0;
  const totalErrors = Object.values(aggregated.errorBreakdown).reduce((a, b) => a + b, 0);

  return (
    <div className="space-y-3">
      {/* Primary stats */}
      <div className="grid grid-cols-2 gap-2">
        <StatCard
          icon={<Activity className="h-3 w-3" />}
          label="API Requests"
          value={aggregated.totalRequests}
        />
        <StatCard
          icon={<Clock className="h-3 w-3" />}
          label="Avg Response"
          value={`${aggregated.avgResponseTime}ms`}
        />
        <StatCard
          icon={<CheckCircle className="h-3 w-3" />}
          label="Success"
          value={aggregated.totalSuccess}
          color="text-green-400"
        />
        <StatCard
          icon={<XCircle className="h-3 w-3" />}
          label="Failed"
          value={aggregated.totalFailed}
          color={hasErrors ? "text-red-400" : "text-gray-400"}
        />
      </div>

      {/* Output stats */}
      <div className="grid grid-cols-2 gap-2">
        {phase === "amazon" ? (
          <StatCard
            icon={<ShoppingCart className="h-3 w-3" />}
            label="Products Found"
            value={productsFound}
            color="text-orange-400"
          />
        ) : (
          <>
            <StatCard
              icon={<Users className="h-3 w-3" />}
              label="Sellers Found"
              value={sellersFound}
              color="text-blue-400"
            />
            <StatCard
              icon={<Users className="h-3 w-3" />}
              label="New Sellers"
              value={`+${sellersNew}`}
              color="text-green-400"
            />
          </>
        )}
      </div>

      {/* Error breakdown (only if errors exist) */}
      {hasErrors && (
        <div className="p-3 rounded bg-red-900/20 border border-red-800/30">
          <div className="flex items-center gap-2 text-xs text-red-400 mb-2">
            <AlertTriangle className="h-3.5 w-3.5" />
            <span className="font-medium">Error Breakdown ({totalErrors} total)</span>
          </div>
          <div className="grid grid-cols-2 gap-2 text-xs">
            {aggregated.errorBreakdown.rate_limit > 0 && (
              <div className="flex justify-between">
                <span className="text-gray-400">Rate Limit</span>
                <Badge variant="outline" className="text-yellow-400 border-yellow-700">
                  {aggregated.errorBreakdown.rate_limit}
                </Badge>
              </div>
            )}
            {aggregated.errorBreakdown.timeout > 0 && (
              <div className="flex justify-between">
                <span className="text-gray-400">Timeout</span>
                <Badge variant="outline" className="text-orange-400 border-orange-700">
                  {aggregated.errorBreakdown.timeout}
                </Badge>
              </div>
            )}
            {aggregated.errorBreakdown.http_error > 0 && (
              <div className="flex justify-between">
                <span className="text-gray-400">HTTP Error</span>
                <Badge variant="outline" className="text-red-400 border-red-700">
                  {aggregated.errorBreakdown.http_error}
                </Badge>
              </div>
            )}
            {aggregated.errorBreakdown.parse_error > 0 && (
              <div className="flex justify-between">
                <span className="text-gray-400">Parse Error</span>
                <Badge variant="outline" className="text-purple-400 border-purple-700">
                  {aggregated.errorBreakdown.parse_error}
                </Badge>
              </div>
            )}
            {aggregated.errorBreakdown.other > 0 && (
              <div className="flex justify-between">
                <span className="text-gray-400">Other</span>
                <Badge variant="outline" className="text-gray-400 border-gray-700">
                  {aggregated.errorBreakdown.other}
                </Badge>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
```
  </action>
  <verify>
1. Both files exist and export components
2. TypeScript compiles: `cd apps/web && npm run build`
3. PipelineFeed filters to worker_id=0 events only
4. MetricsSummary aggregates from WorkerMetrics map
  </verify>
  <done>
- PipelineFeed shows uploading, deduped, inserted, updated events
- Each pipeline card shows count, source worker, timestamp
- MetricsSummary aggregates API stats across all workers
- Error breakdown distinguishes rate_limit, timeout, http_error, parse_error
- Phase-appropriate output stats (products for Amazon, sellers for eBay)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MetricsPanel Container with Mini Worker Status</name>
  <files>apps/web/src/components/admin/collection/metrics-panel.tsx</files>
  <action>
Create `metrics-panel.tsx` - right panel container that combines pipeline feed, metrics, and mini worker status:

```typescript
"use client";

import { Badge } from "@/components/ui/badge";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  User,
  Loader2,
  CheckCircle,
  AlertCircle,
  Clock,
  ShoppingCart,
  Search,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { ActivityEntry, WorkerMetrics, WorkerState, deriveWorkerState } from "./activity-feed";
import { PipelineFeed } from "./pipeline-feed";
import { MetricsSummary } from "./metrics-summary";

interface MetricsPanelProps {
  activities: ActivityEntry[];
  workerMetrics: Map<number, WorkerMetrics>;
  progress: {
    phase: "amazon" | "ebay";
    sellers_found: number;
    sellers_new: number;
    products_found: number;
  };
  expandedWorkerId: number | null;
  onExpandWorker: (workerId: number) => void;
}

// Mini worker status icons for awareness when viewing expanded worker
const workerColors = [
  "bg-blue-500",
  "bg-green-500",
  "bg-purple-500",
  "bg-orange-500",
  "bg-pink-500",
];

function MiniWorkerIcon({
  workerId,
  state,
  phase,
  isExpanded,
  onClick,
}: {
  workerId: number;
  state: WorkerState;
  phase?: "amazon" | "ebay";
  isExpanded: boolean;
  onClick: () => void;
}) {
  const colorIdx = (workerId - 1) % workerColors.length;

  const getStateIcon = () => {
    switch (state) {
      case "searching_products":
      case "searching_sellers":
        return <Loader2 className="h-2.5 w-2.5 animate-spin" />;
      case "returning_products":
      case "returning_sellers":
        return <CheckCircle className="h-2.5 w-2.5" />;
      case "rate_limited":
        return <Clock className="h-2.5 w-2.5 text-yellow-400" />;
      case "error":
        return <AlertCircle className="h-2.5 w-2.5 text-red-400" />;
      case "complete":
        return <CheckCircle className="h-2.5 w-2.5 text-emerald-400" />;
      default:
        return null;
    }
  };

  const getPhaseIcon = () => {
    if (!phase) return null;
    return phase === "amazon"
      ? <ShoppingCart className="h-2 w-2" />
      : <Search className="h-2 w-2" />;
  };

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <button
            onClick={onClick}
            className={cn(
              "relative w-8 h-8 rounded-full flex items-center justify-center transition-all",
              isExpanded ? "ring-2 ring-white" : "hover:ring-1 hover:ring-gray-500",
              state === "idle" ? "bg-gray-700" : workerColors[colorIdx]
            )}
          >
            <span className="text-[10px] font-bold text-white">W{workerId}</span>
            {/* State indicator */}
            {state !== "idle" && (
              <span className="absolute -bottom-0.5 -right-0.5 bg-gray-900 rounded-full p-0.5">
                {getStateIcon()}
              </span>
            )}
          </button>
        </TooltipTrigger>
        <TooltipContent side="bottom" className="text-xs">
          <div className="flex items-center gap-1.5">
            <span>Worker {workerId}</span>
            {phase && (
              <Badge className={cn(
                "text-[9px] px-1",
                phase === "amazon" ? "bg-orange-500/20" : "bg-blue-500/20"
              )}>
                {getPhaseIcon()}
              </Badge>
            )}
          </div>
          <div className="text-gray-400 capitalize">{state.replace(/_/g, " ")}</div>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}

export function MetricsPanel({
  activities,
  workerMetrics,
  progress,
  expandedWorkerId,
  onExpandWorker,
}: MetricsPanelProps) {
  // Get last activity per worker for mini status
  const lastActivityByWorker = new Map<number, ActivityEntry>();
  for (const activity of activities) {
    if (activity.worker_id > 0 && !lastActivityByWorker.has(activity.worker_id)) {
      lastActivityByWorker.set(activity.worker_id, activity);
    }
  }

  return (
    <div className="h-full flex flex-col">
      {/* Mini worker status (shown when a worker is expanded) */}
      {expandedWorkerId !== null && (
        <div className="mb-4 pb-3 border-b border-gray-800">
          <div className="text-xs text-gray-500 uppercase mb-2">Other Workers</div>
          <div className="flex gap-2">
            {[1, 2, 3, 4, 5]
              .filter((id) => id !== expandedWorkerId)
              .map((workerId) => {
                const lastActivity = lastActivityByWorker.get(workerId);
                return (
                  <MiniWorkerIcon
                    key={workerId}
                    workerId={workerId}
                    state={deriveWorkerState(lastActivity)}
                    phase={lastActivity?.phase}
                    isExpanded={false}
                    onClick={() => onExpandWorker(workerId)}
                  />
                );
              })}
          </div>
        </div>
      )}

      {/* Metrics Summary */}
      <div className="mb-4">
        <div className="text-sm font-medium text-gray-300 mb-2">Metrics</div>
        <MetricsSummary
          workerMetrics={workerMetrics}
          sellersFound={progress.sellers_found}
          sellersNew={progress.sellers_new}
          productsFound={progress.products_found}
          phase={progress.phase}
        />
      </div>

      {/* Pipeline Feed */}
      <div className="flex-1 min-h-0">
        <div className="text-sm font-medium text-gray-300 mb-2">Data Pipeline</div>
        <PipelineFeed activities={activities} />
      </div>
    </div>
  );
}
```
  </action>
  <verify>
1. File exists and exports MetricsPanel
2. TypeScript compiles: `cd apps/web && npm run build`
3. Mini worker icons show for workers 1-5 except expanded one
4. MetricsSummary and PipelineFeed integrated correctly
  </verify>
  <done>
- MetricsPanel combines MetricsSummary and PipelineFeed
- Mini worker icons shown when a worker is expanded (for awareness of other workers)
- Clicking mini icon switches to that worker's expanded view
- State-appropriate icons: spinner for searching, check for found, warning for error
- Tooltip shows worker state on hover
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds in apps/web
2. PipelineFeed component exports correctly
3. MetricsSummary component exports correctly
4. MetricsPanel component exports correctly
5. Error breakdown distinguishes parse errors from API errors
</verification>

<success_criteria>
- PipelineFeed shows pipeline operations (worker_id=0 events only)
- MetricsSummary aggregates metrics across all workers
- Error breakdown shows rate_limit, timeout, http_error, parse_error counts
- MetricsPanel shows mini worker icons when viewing expanded worker
- All components use consistent styling with existing activity-feed
</success_criteria>

<output>
After completion, create `.planning/phases/13-worker-status-dashboard-metrics/13-03-SUMMARY.md`
</output>
