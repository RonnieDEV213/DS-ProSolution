---
phase: 09-storage-export-collection-ui
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/src/app/routers/collection.py
  - apps/api/src/app/services/collection.py
  - apps/api/src/app/models.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Admin can view list of past collection runs with timestamps"
    - "Admin can see run statistics (sellers found, sellers new, cost, duration)"
    - "Admin can see run status (completed, failed, cancelled)"
  artifacts:
    - path: "apps/api/src/app/routers/collection.py"
      provides: "/collection/runs/history endpoint"
      exports: ["get_collection_history"]
    - path: "apps/api/src/app/services/collection.py"
      provides: "get_history method"
      contains: "def get_history"
    - path: "apps/api/src/app/models.py"
      provides: "CollectionHistoryEntry and CollectionHistoryResponse models"
      contains: "class CollectionHistoryEntry"
  key_links:
    - from: "apps/api/src/app/routers/collection.py"
      to: "apps/api/src/app/services/collection.py"
      via: "service.get_history call"
      pattern: "get_history"
---

<objective>
Create a dedicated history endpoint that returns completed collection runs with full statistics for display in the collection history UI component.

Purpose: Users need to see past collection runs with their outcomes (how many sellers found, cost incurred, duration) to understand collection performance and re-run successful configurations.

Output: GET /collection/runs/history endpoint returning paginated history with stats.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-storage-export-collection-ui/09-CONTEXT.md
@.planning/phases/09-storage-export-collection-ui/09-RESEARCH.md

@apps/api/src/app/routers/collection.py
@apps/api/src/app/services/collection.py
@apps/api/src/app/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Pydantic models for collection history</name>
  <files>apps/api/src/app/models.py</files>
  <action>
Add new models after the existing CollectionRunListResponse class:

```python
# ============================================================
# Collection History Models
# ============================================================


class CollectionHistoryEntry(BaseModel):
    """Single entry in collection history with full statistics."""

    id: str
    name: str
    status: CollectionRunStatus
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    duration_seconds: Optional[int] = None
    categories_count: int
    products_total: int
    products_searched: int
    sellers_found: int
    sellers_new: int
    cost_cents: int
    failed_items: int
    created_by: str


class CollectionHistoryResponse(BaseModel):
    """Paginated collection history response."""

    runs: list[CollectionHistoryEntry]
    total: int
```
  </action>
  <verify>Grep for "CollectionHistoryEntry" in models.py confirms model exists</verify>
  <done>models.py has CollectionHistoryEntry and CollectionHistoryResponse Pydantic models with all required fields</done>
</task>

<task type="auto">
  <name>Task 2: Add get_history method to CollectionService</name>
  <files>apps/api/src/app/services/collection.py</files>
  <action>
Add a new method to CollectionService that retrieves completed/failed/cancelled runs with statistics:

```python
async def get_history(
    self,
    org_id: str,
    limit: int = 50,
    offset: int = 0,
) -> tuple[list[dict], int]:
    """
    Get collection history (completed/failed/cancelled runs) with statistics.

    Returns runs sorted by completed_at descending.
    """
    result = (
        self.supabase.table("collection_runs")
        .select(
            "id, name, status, category_ids, "
            "started_at, completed_at, "
            "products_total, products_searched, "
            "sellers_found, sellers_new, "
            "actual_cost_cents, failed_items, created_by",
            count="exact"
        )
        .eq("org_id", org_id)
        .in_("status", ["completed", "failed", "cancelled"])
        .order("completed_at", desc=True)
        .range(offset, offset + limit - 1)
        .execute()
    )

    # Compute duration for each run
    runs = []
    for r in result.data or []:
        duration = None
        if r.get("started_at") and r.get("completed_at"):
            from datetime import datetime
            started = datetime.fromisoformat(r["started_at"].replace("Z", "+00:00"))
            completed = datetime.fromisoformat(r["completed_at"].replace("Z", "+00:00"))
            duration = int((completed - started).total_seconds())

        runs.append({
            "id": r["id"],
            "name": r["name"],
            "status": r["status"],
            "started_at": r.get("started_at"),
            "completed_at": r.get("completed_at"),
            "duration_seconds": duration,
            "categories_count": len(r.get("category_ids") or []),
            "products_total": r.get("products_total") or 0,
            "products_searched": r.get("products_searched") or 0,
            "sellers_found": r.get("sellers_found") or 0,
            "sellers_new": r.get("sellers_new") or 0,
            "cost_cents": r.get("actual_cost_cents") or 0,
            "failed_items": r.get("failed_items") or 0,
            "created_by": r["created_by"],
        })

    return runs, result.count or 0
```

Place this method after the existing list_runs method.
  </action>
  <verify>Grep for "def get_history" in collection.py confirms method exists</verify>
  <done>CollectionService has get_history method that returns completed runs with computed duration</done>
</task>

<task type="auto">
  <name>Task 3: Add /collection/runs/history endpoint</name>
  <files>apps/api/src/app/routers/collection.py</files>
  <action>
1. Add imports at top of file:
```python
from app.models import (
    # ... existing imports ...
    CollectionHistoryEntry,
    CollectionHistoryResponse,
)
```

2. Add the history endpoint after the list_runs endpoint:

```python
@router.get("/runs/history", response_model=CollectionHistoryResponse)
async def get_collection_history(
    limit: int = 50,
    offset: int = 0,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Get collection run history with full statistics.

    Returns completed, failed, and cancelled runs sorted by completion time.
    Includes duration calculation, seller counts, and cost tracking.

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    runs, total = await service.get_history(org_id, limit=limit, offset=offset)

    return CollectionHistoryResponse(
        runs=[
            CollectionHistoryEntry(
                id=r["id"],
                name=r["name"],
                status=r["status"],
                started_at=r.get("started_at"),
                completed_at=r.get("completed_at"),
                duration_seconds=r.get("duration_seconds"),
                categories_count=r["categories_count"],
                products_total=r["products_total"],
                products_searched=r["products_searched"],
                sellers_found=r["sellers_found"],
                sellers_new=r["sellers_new"],
                cost_cents=r["cost_cents"],
                failed_items=r["failed_items"],
                created_by=r["created_by"],
            )
            for r in runs
        ],
        total=total,
    )
```
  </action>
  <verify>
1. curl -X GET "http://localhost:8000/collection/runs/history" with auth returns JSON with runs array containing full stats
2. Response includes duration_seconds, sellers_found, sellers_new, cost_cents fields
  </verify>
  <done>
- GET /collection/runs/history endpoint exists
- Returns completed/failed/cancelled runs only
- Each entry includes duration_seconds (computed), categories_count, sellers_found, sellers_new, cost_cents
- Sorted by completed_at descending (most recent first)
  </done>
</task>

</tasks>

<verification>
1. Start API server: `cd apps/api && uvicorn app.main:app --reload --app-dir src`
2. Authenticate and get token
3. Test history endpoint: `curl -H "Authorization: Bearer TOKEN" "http://localhost:8000/collection/runs/history"`
4. Verify response structure includes: id, name, status, started_at, completed_at, duration_seconds, categories_count, products_total, products_searched, sellers_found, sellers_new, cost_cents, failed_items
5. Test pagination: `curl -H "Authorization: Bearer TOKEN" "http://localhost:8000/collection/runs/history?limit=5&offset=0"`
</verification>

<success_criteria>
- GET /collection/runs/history returns paginated list of completed runs
- Each run entry includes duration_seconds (or null if timestamps missing)
- Each run entry includes seller stats (sellers_found, sellers_new)
- Each run entry includes cost tracking (cost_cents)
- Response sorted by completed_at descending
</success_criteria>

<output>
After completion, create `.planning/phases/09-storage-export-collection-ui/09-02-SUMMARY.md`
</output>
