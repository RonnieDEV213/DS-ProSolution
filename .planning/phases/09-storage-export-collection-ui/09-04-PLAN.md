---
phase: 09-storage-export-collection-ui
plan: 04
type: execute
wave: 3
depends_on: ["09-03"]
files_modified:
  - apps/api/pyproject.toml
  - apps/api/src/app/services/scheduler.py
  - apps/api/src/app/routers/collection.py
  - apps/api/src/app/models.py
  - apps/api/src/app/background.py
  - apps/api/src/app/main.py
  - apps/api/migrations/042_collection_schedules.sql
  - apps/web/src/components/admin/collection/schedule-config.tsx
  - apps/web/src/app/admin/automation/page.tsx
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Admin can configure a cron schedule for monthly collection"
    - "Admin can enable/disable scheduled collection"
    - "Admin can select a category preset for scheduled runs"
    - "Scheduled collection runs automatically at configured time"
    - "Scheduled runs are queued if a collection is already running"
  artifacts:
    - path: "apps/api/src/app/services/scheduler.py"
      provides: "APScheduler integration"
      contains: "AsyncIOScheduler"
    - path: "apps/api/src/app/routers/collection.py"
      provides: "Schedule CRUD endpoints"
      exports: ["get_schedule", "update_schedule"]
    - path: "apps/api/migrations/042_collection_schedules.sql"
      provides: "collection_schedules table"
      contains: "CREATE TABLE collection_schedules"
    - path: "apps/web/src/components/admin/collection/schedule-config.tsx"
      provides: "Schedule configuration UI"
      min_lines: 80
  key_links:
    - from: "apps/api/src/app/main.py"
      to: "apps/api/src/app/services/scheduler.py"
      via: "lifespan startup"
      pattern: "scheduler.start"
    - from: "apps/web/src/components/admin/collection/schedule-config.tsx"
      to: "/collection/schedule"
      via: "fetch in useEffect"
      pattern: "collection/schedule"
---

<objective>
Implement cron-based scheduled collection runs using APScheduler, with database persistence and a UI for configuration.

Purpose: Users want monthly automated collection runs without manual intervention. Schedules persist across API restarts.

Output: APScheduler service, schedule CRUD endpoints, schedule config UI, and database table.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-storage-export-collection-ui/09-CONTEXT.md
@.planning/phases/09-storage-export-collection-ui/09-RESEARCH.md

@apps/api/src/app/main.py
@apps/api/src/app/background.py
@apps/api/src/app/routers/collection.py
@apps/api/src/app/services/collection.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add APScheduler dependencies and create scheduler service</name>
  <files>apps/api/pyproject.toml, apps/api/src/app/services/scheduler.py</files>
  <action>
1. Add dependencies to pyproject.toml in the [project] dependencies array:
```toml
"apscheduler>=3.10.0,<4.0.0",
"croniter>=2.0.0,<3.0.0",
```

2. Create new file apps/api/src/app/services/scheduler.py:

```python
"""
Scheduler service for cron-based collection runs.

Uses APScheduler with AsyncIOScheduler for non-blocking scheduled tasks.
Schedules persist in database and are loaded on startup.
"""

import logging
from datetime import datetime, timezone

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from croniter import croniter

from app.database import get_supabase

logger = logging.getLogger(__name__)

# Global scheduler instance
scheduler = AsyncIOScheduler(timezone="UTC")


def validate_cron(expression: str) -> bool:
    """Validate a cron expression."""
    try:
        croniter(expression)
        return True
    except (KeyError, ValueError):
        return False


async def run_scheduled_collection(org_id: str, preset_id: str, schedule_id: str):
    """
    Execute a scheduled collection run.

    Checks for active runs first and queues if one is running.
    """
    from app.services.collection import CollectionService

    supabase = get_supabase()
    service = CollectionService(supabase)

    logger.info(f"Starting scheduled collection for org {org_id}, preset {preset_id}")

    # Check for active runs
    active_runs = (
        supabase.table("collection_runs")
        .select("id", count="exact")
        .eq("org_id", org_id)
        .in_("status", ["pending", "running", "paused"])
        .execute()
    )

    if (active_runs.count or 0) > 0:
        logger.info(f"Collection already running for org {org_id}, skipping scheduled run")
        # Could queue for later, but for now just skip
        return

    # Get preset category IDs
    preset_result = (
        supabase.table("amazon_category_presets")
        .select("category_ids")
        .eq("id", preset_id)
        .eq("org_id", org_id)
        .execute()
    )

    if not preset_result.data:
        logger.error(f"Preset {preset_id} not found for org {org_id}")
        return

    category_ids = preset_result.data[0]["category_ids"]
    if not category_ids:
        logger.warning(f"Preset {preset_id} has no categories, skipping")
        return

    # Create and start the run
    result = await service.create_run(
        org_id=org_id,
        user_id="system",  # System-initiated run
        category_ids=category_ids,
        name=f"Scheduled Run {datetime.now(timezone.utc).strftime('%Y-%m-%d')}",
    )

    if "error" in result:
        logger.error(f"Failed to create scheduled run: {result['message']}")
        return

    run = result["run"]
    run_id = run["id"]

    # Start the run
    await service.start_run(run_id, org_id)

    # Execute the collection pipeline
    # Phase 1: Amazon
    amazon_result = await service.run_amazon_collection(
        run_id=run_id,
        org_id=org_id,
        category_ids=category_ids,
    )

    if amazon_result.get("status") in ("failed", "paused"):
        return

    # Phase 2: eBay
    await service.run_ebay_seller_search(run_id=run_id, org_id=org_id)

    logger.info(f"Scheduled collection completed for org {org_id}")


async def load_schedules():
    """Load all enabled schedules from database and add to scheduler."""
    supabase = get_supabase()

    result = (
        supabase.table("collection_schedules")
        .select("id, org_id, preset_id, cron_expression")
        .eq("enabled", True)
        .execute()
    )

    for schedule in result.data or []:
        try:
            trigger = CronTrigger.from_crontab(schedule["cron_expression"])
            scheduler.add_job(
                run_scheduled_collection,
                trigger,
                args=[schedule["org_id"], schedule["preset_id"], schedule["id"]],
                id=f"collection_{schedule['id']}",
                replace_existing=True,
                misfire_grace_time=3600,  # 1 hour grace for missed runs
            )
            logger.info(f"Loaded schedule {schedule['id']} for org {schedule['org_id']}")
        except Exception as e:
            logger.error(f"Failed to load schedule {schedule['id']}: {e}")


def add_schedule(schedule_id: str, org_id: str, preset_id: str, cron_expression: str):
    """Add a schedule to the scheduler."""
    try:
        trigger = CronTrigger.from_crontab(cron_expression)
        scheduler.add_job(
            run_scheduled_collection,
            trigger,
            args=[org_id, preset_id, schedule_id],
            id=f"collection_{schedule_id}",
            replace_existing=True,
            misfire_grace_time=3600,
        )
        logger.info(f"Added schedule {schedule_id}")
    except Exception as e:
        logger.error(f"Failed to add schedule {schedule_id}: {e}")
        raise


def remove_schedule(schedule_id: str):
    """Remove a schedule from the scheduler."""
    job_id = f"collection_{schedule_id}"
    if scheduler.get_job(job_id):
        scheduler.remove_job(job_id)
        logger.info(f"Removed schedule {schedule_id}")


def get_next_run_time(schedule_id: str) -> datetime | None:
    """Get the next scheduled run time for a schedule."""
    job_id = f"collection_{schedule_id}"
    job = scheduler.get_job(job_id)
    return job.next_run_time if job else None
```
  </action>
  <verify>
1. apps/api/pyproject.toml contains apscheduler and croniter in dependencies
2. apps/api/src/app/services/scheduler.py exists with AsyncIOScheduler and validate_cron function
  </verify>
  <done>
- APScheduler and croniter dependencies added to pyproject.toml
- scheduler.py service created with load_schedules, add_schedule, remove_schedule functions
- run_scheduled_collection checks for active runs before starting
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database migration for collection_schedules</name>
  <files>apps/api/migrations/042_collection_schedules.sql</files>
  <action>
Create migration file:

```sql
-- Migration: 042_collection_schedules.sql
-- Collection schedule configuration for cron-based automated runs

-- Collection schedules table (one per org for now)
CREATE TABLE IF NOT EXISTS collection_schedules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    preset_id UUID REFERENCES amazon_category_presets(id) ON DELETE SET NULL,
    cron_expression TEXT NOT NULL DEFAULT '0 0 1 * *',  -- Default: 1st of month at midnight UTC
    enabled BOOLEAN NOT NULL DEFAULT false,
    notify_email BOOLEAN NOT NULL DEFAULT false,
    last_run_at TIMESTAMPTZ,
    next_run_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE(org_id)  -- One schedule per org for simplicity
);

-- Index for loading enabled schedules
CREATE INDEX IF NOT EXISTS idx_collection_schedules_enabled
ON collection_schedules(enabled) WHERE enabled = true;

-- RLS policies
ALTER TABLE collection_schedules ENABLE ROW LEVEL SECURITY;

-- Admin can manage their org's schedule
CREATE POLICY "admin_manage_schedule" ON collection_schedules
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 FROM memberships m
            WHERE m.org_id = collection_schedules.org_id
            AND m.user_id = auth.uid()
            AND m.role = 'admin'
        )
    );

-- Comment
COMMENT ON TABLE collection_schedules IS 'Cron-based schedule configuration for automated collection runs';
```
  </action>
  <verify>File exists at apps/api/migrations/042_collection_schedules.sql with CREATE TABLE collection_schedules</verify>
  <done>Migration creates collection_schedules table with cron_expression, enabled, preset_id columns and RLS</done>
</task>

<task type="auto">
  <name>Task 3: Add schedule CRUD endpoints and models</name>
  <files>apps/api/src/app/routers/collection.py, apps/api/src/app/models.py</files>
  <action>
1. Add models to models.py after the existing collection models:

```python
# ============================================================
# Collection Schedule Models
# ============================================================


class CollectionScheduleResponse(BaseModel):
    """Collection schedule configuration."""

    id: Optional[str] = None
    preset_id: Optional[str] = None
    preset_name: Optional[str] = None
    cron_expression: str
    enabled: bool
    notify_email: bool
    last_run_at: Optional[datetime] = None
    next_run_at: Optional[datetime] = None


class CollectionScheduleUpdate(BaseModel):
    """Update collection schedule."""

    preset_id: Optional[str] = None
    cron_expression: Optional[str] = None
    enabled: Optional[bool] = None
    notify_email: Optional[bool] = None
```

2. Add endpoints to collection.py after the template endpoints:

```python
from app.services.scheduler import (
    validate_cron,
    add_schedule,
    remove_schedule,
    get_next_run_time,
)
from app.models import (
    # ... existing imports ...
    CollectionScheduleResponse,
    CollectionScheduleUpdate,
)

# ============================================================
# Schedule Endpoints
# ============================================================


@router.get("/schedule", response_model=CollectionScheduleResponse)
async def get_schedule(
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Get collection schedule for the organization.

    Returns current schedule configuration or defaults if none exists.

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    supabase = get_supabase()

    # Get schedule with preset name join
    result = (
        supabase.table("collection_schedules")
        .select("*, amazon_category_presets(name)")
        .eq("org_id", org_id)
        .execute()
    )

    if not result.data:
        # Return defaults (no schedule configured)
        return CollectionScheduleResponse(
            cron_expression="0 0 1 * *",  # 1st of month at midnight
            enabled=False,
            notify_email=False,
        )

    schedule = result.data[0]
    preset_data = schedule.get("amazon_category_presets")

    # Get next run time from scheduler
    next_run = get_next_run_time(schedule["id"]) if schedule.get("enabled") else None

    return CollectionScheduleResponse(
        id=schedule["id"],
        preset_id=schedule.get("preset_id"),
        preset_name=preset_data["name"] if preset_data else None,
        cron_expression=schedule["cron_expression"],
        enabled=schedule["enabled"],
        notify_email=schedule["notify_email"],
        last_run_at=schedule.get("last_run_at"),
        next_run_at=next_run.isoformat() if next_run else None,
    )


@router.patch("/schedule", response_model=CollectionScheduleResponse)
async def update_schedule(
    body: CollectionScheduleUpdate,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Update collection schedule.

    Creates schedule if none exists. Validates cron expression.

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    supabase = get_supabase()

    # Validate cron if provided
    if body.cron_expression and not validate_cron(body.cron_expression):
        raise HTTPException(status_code=400, detail="Invalid cron expression")

    # Check if schedule exists
    existing = (
        supabase.table("collection_schedules")
        .select("id")
        .eq("org_id", org_id)
        .execute()
    )

    update_data = body.model_dump(exclude_unset=True)
    update_data["updated_at"] = datetime.now(timezone.utc).isoformat()

    if existing.data:
        # Update existing
        schedule_id = existing.data[0]["id"]
        result = (
            supabase.table("collection_schedules")
            .update(update_data)
            .eq("id", schedule_id)
            .execute()
        )
        schedule = result.data[0]

        # Update scheduler
        if schedule["enabled"] and schedule.get("preset_id"):
            add_schedule(
                schedule_id,
                org_id,
                schedule["preset_id"],
                schedule["cron_expression"],
            )
        else:
            remove_schedule(schedule_id)
    else:
        # Create new
        insert_data = {
            "org_id": org_id,
            "cron_expression": body.cron_expression or "0 0 1 * *",
            "preset_id": body.preset_id,
            "enabled": body.enabled or False,
            "notify_email": body.notify_email or False,
        }
        result = (
            supabase.table("collection_schedules")
            .insert(insert_data)
            .execute()
        )
        schedule = result.data[0]

        # Add to scheduler if enabled
        if schedule["enabled"] and schedule.get("preset_id"):
            add_schedule(
                schedule["id"],
                org_id,
                schedule["preset_id"],
                schedule["cron_expression"],
            )

    # Get preset name
    preset_name = None
    if schedule.get("preset_id"):
        preset_result = (
            supabase.table("amazon_category_presets")
            .select("name")
            .eq("id", schedule["preset_id"])
            .execute()
        )
        if preset_result.data:
            preset_name = preset_result.data[0]["name"]

    # Get next run time
    next_run = get_next_run_time(schedule["id"]) if schedule.get("enabled") else None

    return CollectionScheduleResponse(
        id=schedule["id"],
        preset_id=schedule.get("preset_id"),
        preset_name=preset_name,
        cron_expression=schedule["cron_expression"],
        enabled=schedule["enabled"],
        notify_email=schedule["notify_email"],
        last_run_at=schedule.get("last_run_at"),
        next_run_at=next_run.isoformat() if next_run else None,
    )
```

Add necessary imports at top:
```python
from datetime import datetime, timezone
from app.database import get_supabase
```
  </action>
  <verify>
1. collection.py has get_schedule and update_schedule endpoints
2. models.py has CollectionScheduleResponse and CollectionScheduleUpdate classes
  </verify>
  <done>
- GET /collection/schedule returns current schedule or defaults
- PATCH /collection/schedule creates or updates schedule
- Cron validation before saving
- Scheduler updated when enabled/disabled
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate scheduler into application lifecycle</name>
  <files>apps/api/src/app/background.py, apps/api/src/app/main.py</files>
  <action>
1. Update background.py to add scheduler startup function:

Add after the existing collection_startup_recovery function:

```python
async def scheduler_startup():
    """
    Start the APScheduler and load schedules from database.

    Called during application startup.
    """
    try:
        from app.services.scheduler import scheduler, load_schedules

        # Start scheduler
        scheduler.start()
        logger.info("APScheduler started")

        # Load schedules from database
        await load_schedules()
    except Exception as e:
        logger.error(f"Scheduler startup failed: {e}")


def scheduler_shutdown():
    """
    Shutdown the APScheduler gracefully.

    Called during application shutdown.
    """
    try:
        from app.services.scheduler import scheduler

        scheduler.shutdown(wait=False)
        logger.info("APScheduler shutdown")
    except Exception as e:
        logger.error(f"Scheduler shutdown failed: {e}")
```

2. Update main.py lifespan to include scheduler:

```python
from app.background import (
    cleanup_worker,
    collection_startup_recovery,
    scheduler_startup,
    scheduler_shutdown,
)

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manage application lifecycle - start/stop background tasks."""
    global _cleanup_task
    # Startup
    _cleanup_task = asyncio.create_task(cleanup_worker())

    # Check for interrupted collection runs
    await collection_startup_recovery()

    # Start scheduler and load schedules
    await scheduler_startup()

    yield

    # Shutdown
    scheduler_shutdown()

    if _cleanup_task:
        _cleanup_task.cancel()
        try:
            await _cleanup_task
        except asyncio.CancelledError:
            pass
```
  </action>
  <verify>
1. background.py has scheduler_startup and scheduler_shutdown functions
2. main.py lifespan calls scheduler_startup on startup and scheduler_shutdown on shutdown
  </verify>
  <done>
- APScheduler starts on API startup
- Schedules loaded from database on startup
- Scheduler shuts down gracefully on API shutdown
  </done>
</task>

<task type="auto">
  <name>Task 5: Create schedule configuration UI component</name>
  <files>apps/web/src/components/admin/collection/schedule-config.tsx</files>
  <action>
Create a new component for schedule configuration:

```typescript
"use client";

import { useState, useEffect, useCallback } from "react";
import { createClient } from "@/lib/supabase/client";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Calendar, Clock, Loader2 } from "lucide-react";

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || "http://localhost:8000";

interface Schedule {
  id?: string;
  preset_id?: string;
  preset_name?: string;
  cron_expression: string;
  enabled: boolean;
  notify_email: boolean;
  last_run_at?: string;
  next_run_at?: string;
}

interface Preset {
  id: string;
  name: string;
  category_ids: string[];
  is_builtin: boolean;
}

// Common cron presets for user-friendly selection
const CRON_PRESETS = [
  { label: "1st of month at midnight", value: "0 0 1 * *" },
  { label: "15th of month at midnight", value: "0 0 15 * *" },
  { label: "Every Sunday at midnight", value: "0 0 * * 0" },
  { label: "Every day at midnight", value: "0 0 * * *" },
  { label: "Custom", value: "custom" },
];

export function ScheduleConfig() {
  const [schedule, setSchedule] = useState<Schedule | null>(null);
  const [presets, setPresets] = useState<Preset[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [cronPreset, setCronPreset] = useState<string>("0 0 1 * *");
  const [customCron, setCustomCron] = useState("");
  const supabase = createClient();

  // Fetch schedule and presets
  const fetchData = useCallback(async () => {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) return;

      const headers = { Authorization: `Bearer ${session.access_token}` };

      // Fetch schedule
      const scheduleRes = await fetch(`${API_BASE}/collection/schedule`, { headers });
      if (scheduleRes.ok) {
        const data = await scheduleRes.json();
        setSchedule(data);

        // Set cron preset dropdown
        const matchingPreset = CRON_PRESETS.find(p => p.value === data.cron_expression);
        if (matchingPreset) {
          setCronPreset(data.cron_expression);
        } else {
          setCronPreset("custom");
          setCustomCron(data.cron_expression);
        }
      }

      // Fetch presets for dropdown
      const presetsRes = await fetch(`${API_BASE}/amazon/presets`, { headers });
      if (presetsRes.ok) {
        const data = await presetsRes.json();
        setPresets(data.presets || []);
      }
    } catch (e) {
      console.error("Failed to fetch schedule:", e);
    } finally {
      setLoading(false);
    }
  }, [supabase.auth]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const handleSave = async () => {
    if (!schedule) return;

    const cronExpression = cronPreset === "custom" ? customCron : cronPreset;

    setSaving(true);
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) return;

      const response = await fetch(`${API_BASE}/collection/schedule`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${session.access_token}`,
        },
        body: JSON.stringify({
          preset_id: schedule.preset_id,
          cron_expression: cronExpression,
          enabled: schedule.enabled,
          notify_email: schedule.notify_email,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.detail || "Failed to save schedule");
      }

      const updated = await response.json();
      setSchedule(updated);
      toast.success("Schedule saved");
    } catch (e) {
      toast.error(e instanceof Error ? e.message : "Failed to save");
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return <div className="text-gray-400">Loading schedule...</div>;
  }

  if (!schedule) {
    return <div className="text-gray-500">Unable to load schedule</div>;
  }

  return (
    <Card className="bg-gray-900 border-gray-800">
      <CardHeader>
        <CardTitle className="text-white flex items-center gap-2">
          <Calendar className="h-5 w-5" />
          Scheduled Collection
        </CardTitle>
        <CardDescription className="text-gray-400">
          Automatically run collection at a scheduled time
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Enable toggle */}
        <div className="flex items-center justify-between">
          <div className="space-y-0.5">
            <Label className="text-gray-200">Enable Schedule</Label>
            <p className="text-sm text-gray-500">
              Automatically run collection at scheduled time
            </p>
          </div>
          <Switch
            checked={schedule.enabled}
            onCheckedChange={(checked) =>
              setSchedule({ ...schedule, enabled: checked })
            }
          />
        </div>

        {/* Preset selection */}
        <div className="space-y-2">
          <Label className="text-gray-200">Category Preset</Label>
          <Select
            value={schedule.preset_id || ""}
            onValueChange={(value) =>
              setSchedule({ ...schedule, preset_id: value })
            }
          >
            <SelectTrigger className="bg-gray-800 border-gray-700 text-white">
              <SelectValue placeholder="Select a preset..." />
            </SelectTrigger>
            <SelectContent className="bg-gray-800 border-gray-700">
              {presets.map((preset) => (
                <SelectItem
                  key={preset.id}
                  value={preset.id}
                  className="text-gray-200"
                >
                  {preset.name} ({preset.category_ids.length} categories)
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          {!schedule.preset_id && (
            <p className="text-sm text-yellow-500">
              Select a preset to enable scheduled runs
            </p>
          )}
        </div>

        {/* Cron schedule */}
        <div className="space-y-2">
          <Label className="text-gray-200">Schedule</Label>
          <Select value={cronPreset} onValueChange={setCronPreset}>
            <SelectTrigger className="bg-gray-800 border-gray-700 text-white">
              <SelectValue />
            </SelectTrigger>
            <SelectContent className="bg-gray-800 border-gray-700">
              {CRON_PRESETS.map((preset) => (
                <SelectItem
                  key={preset.value}
                  value={preset.value}
                  className="text-gray-200"
                >
                  {preset.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>

          {cronPreset === "custom" && (
            <div className="mt-2">
              <Input
                value={customCron}
                onChange={(e) => setCustomCron(e.target.value)}
                placeholder="0 0 1 * *"
                className="bg-gray-800 border-gray-700 text-white font-mono"
              />
              <p className="text-xs text-gray-500 mt-1">
                Cron format: minute hour day month weekday
              </p>
            </div>
          )}
        </div>

        {/* Next run time */}
        {schedule.next_run_at && (
          <div className="flex items-center gap-2 text-sm text-gray-400">
            <Clock className="h-4 w-4" />
            Next run: {new Date(schedule.next_run_at).toLocaleString()}
          </div>
        )}

        {/* Email notification toggle */}
        <div className="flex items-center justify-between">
          <div className="space-y-0.5">
            <Label className="text-gray-200">Email Notification</Label>
            <p className="text-sm text-gray-500">
              Send email when scheduled run completes
            </p>
          </div>
          <Switch
            checked={schedule.notify_email}
            onCheckedChange={(checked) =>
              setSchedule({ ...schedule, notify_email: checked })
            }
          />
        </div>

        {/* Save button */}
        <Button
          onClick={handleSave}
          disabled={saving || !schedule.preset_id}
          className="w-full bg-blue-600 hover:bg-blue-700"
        >
          {saving ? (
            <>
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              Saving...
            </>
          ) : (
            "Save Schedule"
          )}
        </Button>
      </CardContent>
    </Card>
  );
}
```
  </action>
  <verify>File exists at apps/web/src/components/admin/collection/schedule-config.tsx with CRON_PRESETS and handleSave function</verify>
  <done>ScheduleConfig component has preset dropdown, cron selection (presets + custom), enable toggle, and save button</done>
</task>

<task type="auto">
  <name>Task 6: Integrate schedule config into automation page</name>
  <files>apps/web/src/app/admin/automation/page.tsx</files>
  <action>
1. Add import:
```typescript
import { ScheduleConfig } from "@/components/admin/collection/schedule-config";
```

2. Add the ScheduleConfig component to the collections tab, after the CollectionHistory component:

```tsx
{activeTab === "collections" && (
  <div className="space-y-6">
    {/* Progress bar */}
    {/* ... existing progress bar ... */}

    {/* Main content: Grid + Sidebar */}
    {/* ... existing grid ... */}

    {/* Collection History */}
    <CollectionHistory
      refreshTrigger={refreshTrigger}
      onRerun={(categoryIds) => setRunConfigOpen(true)}
    />

    {/* Schedule Configuration */}
    <ScheduleConfig />

    {/* Modals */}
    {/* ... existing modals ... */}
  </div>
)}
```

Place ScheduleConfig after CollectionHistory for logical grouping (history above, schedule config below).
  </action>
  <verify>automation/page.tsx imports ScheduleConfig and renders it in the collections tab</verify>
  <done>Schedule configuration card appears in Collections tab below history</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Cron-based scheduled collection system with APScheduler, database persistence, and UI configuration</what-built>
  <how-to-verify>
1. Install new dependencies: `cd apps/api && pip install -e ".[dev]"`
2. Run migration in Supabase SQL editor: contents of apps/api/migrations/042_collection_schedules.sql
3. Start API and web app
4. Login as admin and navigate to Extension Hub -> Collections tab
5. Verify:
   - "Scheduled Collection" card appears below Collection History
   - Enable toggle switches the schedule on/off
   - Preset dropdown shows saved category presets (create one first if none exist)
   - Schedule dropdown has predefined options (1st of month, 15th, etc.)
   - Selecting "Custom" shows text input for cron expression
   - Click Save -> toast confirms save
   - If enabled with valid preset, "Next run:" shows computed next run time
   - Check API logs on startup to see "APScheduler started" message
   - Check API logs to see "Loaded schedule..." for enabled schedules
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with scheduling</resume-signal>
</task>

</tasks>

<verification>
1. APScheduler starts on API startup (check logs)
2. GET /collection/schedule returns schedule config with defaults
3. PATCH /collection/schedule validates cron and updates database
4. Scheduler loads enabled schedules from database on startup
5. Schedule UI shows preset dropdown, cron selection, enable toggle
6. Saving schedule updates database and scheduler
</verification>

<success_criteria>
- Admin can configure a cron schedule for monthly collection
- Admin can enable/disable scheduled collection
- Admin can select a category preset for scheduled runs
- Schedules persist across API restarts
- Next run time computed and displayed in UI
</success_criteria>

<output>
After completion, create `.planning/phases/09-storage-export-collection-ui/09-04-SUMMARY.md`
</output>
