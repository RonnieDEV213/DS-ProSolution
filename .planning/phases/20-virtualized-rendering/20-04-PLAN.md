---
phase: 20-virtualized-rendering
plan: 04
type: execute
wave: 3
depends_on: ["20-02", "20-03"]
files_modified:
  - apps/web/src/hooks/sync/use-sync-records.ts
  - apps/web/src/components/bookkeeping/bookkeeping-content.tsx
  - apps/web/src/components/bookkeeping/record-row.tsx
  - apps/web/src/components/bookkeeping/virtualized-records-list.tsx
autonomous: true
gap_closure: true
must_haves:
  truths:
    - "Infinite scroll loads additional records when the user scrolls near the bottom of the Order Tracking list"
  artifacts:
    - path: "apps/web/src/hooks/sync/use-sync-records.ts"
      provides: "Pagination window state (visible count, hasMore, loadMore, totalCount) for records"
    - path: "apps/web/src/components/bookkeeping/bookkeeping-content.tsx"
      provides: "VirtualizedRecordsList receives hasMore/loadMore from the paginated records source"
    - path: "apps/web/src/components/bookkeeping/virtualized-records-list.tsx"
      provides: "ResultSummary uses total record count while infinite loader reacts to hasMore"
  key_links:
    - from: "apps/web/src/hooks/sync/use-sync-records.ts"
      to: "apps/web/src/components/bookkeeping/bookkeeping-content.tsx"
      via: "hasMore/loadMore/totalCount return values"
      pattern: "hasMore|loadMore|totalCount"
    - from: "apps/web/src/components/bookkeeping/bookkeeping-content.tsx"
      to: "apps/web/src/components/bookkeeping/virtualized-records-list.tsx"
      via: "hasMore and loadMore props"
      pattern: "hasMore=|loadMore="
    - from: "apps/web/src/components/bookkeeping/virtualized-records-list.tsx"
      to: "react-window-infinite-loader"
      via: "itemCount uses hasMore"
      pattern: "itemCount = hasMore"
---

<objective>
Enable real infinite scrolling for the bookkeeping list by exposing pagination state from the records data source and wiring it into the virtualized list.

Purpose: Close the Phase 20 gap where infinite scroll never loads additional records.
Output: Paginated records hook state + list wiring that triggers loadMore as users scroll.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-virtualized-rendering/20-virtualized-rendering-VERIFICATION.md
@apps/web/src/hooks/sync/use-sync-records.ts
@apps/web/src/components/bookkeeping/bookkeeping-content.tsx
@apps/web/src/components/bookkeeping/virtualized-records-list.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pagination window state to useSyncRecords</name>
  <files>apps/web/src/hooks/sync/use-sync-records.ts</files>
  <action>
Add a PAGE_SIZE constant and track a visible record window inside the hook.

- Reset the visible window when accountId changes.
- Query records using the [account_id+sale_date] index, reverse order, and limit by visibleCount.
- Keep existing in-memory filter behavior and computed-field assumptions intact.
- Add a totalCount query (Dexie count) and derive hasMore when visibleCount < totalCount.
- Expose loadMore to increment visibleCount by PAGE_SIZE without changing syncRecords behavior.

Gap reason: hasMore/loadMore are missing from the data source, so the list is permanently disabled.
  </action>
  <verify>cd apps/web && npx tsc --noEmit</verify>
  <done>useSyncRecords returns hasMore/loadMore/totalCount and limits records by visibleCount in sale_date DESC order.</done>
</task>

<task type="auto">
  <name>Task 2: Wire pagination state into the virtualized list</name>
  <files>apps/web/src/components/bookkeeping/bookkeeping-content.tsx
apps/web/src/components/bookkeeping/record-row.tsx
apps/web/src/components/bookkeeping/virtualized-records-list.tsx</files>
  <action>
Wire the new pagination state into the bookkeeping UI.

- In BookkeepingContent, use hasMore/loadMore/totalCount from useSyncRecords and remove the hardcoded hasMore=false.
- Pass totalCount to VirtualizedRecordsList (use filteredRecords.length when filters are active).
- Update RecordsToolbar recordCount to use totalCount when unfiltered.
- Update VirtualizedRecordsList props to accept totalCount and use it for ResultSummary total (fallback to records.length).
- Render SkeletonRow for the extra loading row when hasMore is true and loadMore is in flight (extend the virtual row type or handle the missing row case in RecordRow).

Gap reason: VirtualizedRecordsList never receives real pagination state, so useInfiniteLoader cannot request more rows.
  </action>
  <verify>cd apps/web && npx tsc --noEmit</verify>
  <done>BookkeepingContent passes hasMore/loadMore/totalCount to VirtualizedRecordsList and the summary uses totalCount when unfiltered.</done>
</task>

</tasks>

<verification>
- cd apps/web && npx tsc --noEmit
- Run the web app, open Order Tracking, scroll near the bottom, and confirm additional rows render while the result summary keeps the full total count.
</verification>

<success_criteria>
- Infinite scroll triggers loadMore and additional records become visible as the user nears the list bottom.
- Result summary and toolbar counts stay accurate for the full unfiltered dataset.
- The bookkeeping list no longer hardcodes hasMore to false.
</success_criteria>

<output>
After completion, create `.planning/phases/20-virtualized-rendering/20-04-SUMMARY.md`
</output>
