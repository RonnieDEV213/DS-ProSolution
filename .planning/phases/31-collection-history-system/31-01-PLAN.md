---
phase: 31-collection-history-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/migrations/054_export_flag_audit.sql
  - apps/api/src/app/services/collection.py
  - apps/api/src/app/routers/sellers.py
  - apps/api/src/app/models.py
autonomous: true

must_haves:
  truths:
    - "Export and flag action types are accepted by the seller_audit_log table"
    - "Backend can log a bulk export event as a single audit entry"
    - "Backend can log a bulk flag event as a single audit entry"
    - "Audit log API returns filtered results by action type and date range"
    - "Audit log API supports cursor-based pagination with total count"
    - "A dedicated log-export endpoint records export events from the frontend"
  artifacts:
    - path: "apps/api/migrations/054_export_flag_audit.sql"
      provides: "Extended check constraint for export+flag actions, action index"
      contains: "export.*flag"
    - path: "apps/api/src/app/services/collection.py"
      provides: "log_export_event, log_flag_event, filtered get_audit_log"
      exports: ["log_export_event", "log_flag_event"]
    - path: "apps/api/src/app/routers/sellers.py"
      provides: "Filtered audit-log endpoint with action_types+date params, log-export POST endpoint, flag-batch POST endpoint"
      exports: ["get_audit_log", "log_export_event", "flag_batch"]
    - path: "apps/api/src/app/models.py"
      provides: "Extended AuditLogEntry action types, new request/response models"
      contains: "export.*flag"
  key_links:
    - from: "apps/api/src/app/routers/sellers.py"
      to: "apps/api/src/app/services/collection.py"
      via: "service.log_export_event(), service.log_flag_event(), service.get_audit_log()"
      pattern: "service\\.(log_export_event|log_flag_event|get_audit_log)"
    - from: "apps/api/src/app/services/collection.py"
      to: "seller_audit_log table"
      via: "INSERT with action='export' or action='flag'"
      pattern: "action.*export|action.*flag"
---

<objective>
Backend foundation for collection history system: extend the seller_audit_log table to accept export and flag action types, add logging methods for bulk export and flag events, create a filtered+paginated audit log API, and add endpoints for recording export events and batch flagging.

Purpose: All subsequent plans (export modal, flag recording, history viewer) depend on these backend capabilities existing.
Output: Migration file, extended collection service methods, extended sellers router endpoints, updated Pydantic models.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/31-collection-history-system/31-CONTEXT.md
@.planning/phases/31-collection-history-system/31-RESEARCH.md
@apps/api/migrations/038_seller_audit_log.sql
@apps/api/src/app/services/collection.py
@apps/api/src/app/routers/sellers.py
@apps/api/src/app/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration and collection service methods</name>
  <files>
    apps/api/migrations/054_export_flag_audit.sql
    apps/api/src/app/services/collection.py
    apps/api/src/app/models.py
  </files>
  <action>
    **Migration (054_export_flag_audit.sql):**
    1. DROP the existing `seller_audit_log_action_check` constraint
    2. ADD new constraint: `CHECK (action IN ('add', 'edit', 'remove', 'export', 'flag'))`
    3. CREATE INDEX `idx_seller_audit_log_action` ON `seller_audit_log(org_id, action, created_at DESC)` for efficient filtering
    4. Also add `source` value `'export'` to the source check constraint if it exists (check the existing constraint first -- current is `('manual', 'collection_run', 'auto_remove')`)

    **Collection service (collection.py):**
    1. Add `log_export_event()` method after `_log_seller_change()`:
       - Params: `org_id, user_id, seller_names: list[str], export_format: str`
       - Gets seller count snapshot via existing `_get_seller_count_snapshot()`
       - Calls `_log_seller_change()` with `action="export"`, `seller_id=None`, `seller_name=f"Exported {len(seller_names)} sellers as {export_format}"`, `new_value={"format": export_format, "sellers": seller_names}`, `source="manual"`, `affected_count=len(seller_names)`
       - Note: `seller_id` column allows NULL for bulk operations (check if it has a NOT NULL constraint -- if so, pass empty string)

    2. Add `log_flag_event()` method:
       - Params: `org_id, user_id, seller_names: list[str], flagged: bool`
       - Gets seller count snapshot
       - `action="flag"`, `seller_name=f"{'Flagged' if flagged else 'Unflagged'} {len(seller_names)} sellers"`, `new_value={"flagged": flagged, "sellers": seller_names}`, `source="manual"`, `affected_count=len(seller_names)`

    3. Extend `get_audit_log()` method signature to add filtering:
       - Add params: `action_types: list[str] | None = None`, `date_from: str | None = None`, `date_to: str | None = None`
       - If `action_types` provided: `query = query.in_("action", action_types)`
       - If `date_from` provided: `query = query.gte("created_at", date_from)`
       - If `date_to` provided: `query = query.lte("created_at", date_to)`
       - Also add `new_value` to the SELECT clause (needed for export/flag event details)
       - Keep existing behavior when no filters passed

    4. Add `batch_toggle_flag()` method:
       - Params: `org_id, user_id, seller_ids: list[str], flagged: bool`
       - Update all sellers in seller_ids to the target flagged state in a single query (use `.in_("id", seller_ids)` on the sellers table)
       - After update, get seller names for audit log
       - Call `log_flag_event()` with the seller names and flag state
       - Return the count of updated sellers

    **Models (models.py):**
    1. Extend `AuditLogEntry.action` Literal to include `"export"` and `"flag"`: `Literal["add", "edit", "remove", "export", "flag"]`
    2. Add `new_value` optional field to `AuditLogEntry`: `new_value: Optional[str] = None` (JSON string)
    3. Add `LogExportRequest` model: `seller_names: list[str]`, `export_format: str` (Literal["csv", "json", "clipboard"])
    4. Add `FlagBatchRequest` model: `seller_ids: list[str]`, `flagged: bool`
    5. Add `FlagBatchResponse` model: `updated_count: int`
  </action>
  <verify>
    - `python -c "from app.models import AuditLogEntry, LogExportRequest, FlagBatchRequest; print('Models OK')"` succeeds from apps/api/src directory
    - Migration file exists at apps/api/migrations/054_export_flag_audit.sql with correct SQL
    - grep confirms `log_export_event`, `log_flag_event`, `batch_toggle_flag` methods exist in collection.py
    - grep confirms `action_types` parameter exists in `get_audit_log` method signature
  </verify>
  <done>
    Migration extends check constraint to accept 'export' and 'flag' actions. Collection service has log_export_event(), log_flag_event(), batch_toggle_flag() methods. get_audit_log() accepts action_types, date_from, date_to filter params. Models include new action Literal values and request/response types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Sellers router endpoint extensions</name>
  <files>
    apps/api/src/app/routers/sellers.py
  </files>
  <action>
    **Extend existing audit-log GET endpoint:**
    1. Add query params to `get_audit_log` route: `action_types: str | None = None` (comma-separated string like "export,flag"), `date_from: str | None = None`, `date_to: str | None = None`
    2. Parse `action_types` from comma-separated string to list: `action_list = action_types.split(",") if action_types else None`
    3. Pass `action_types=action_list, date_from=date_from, date_to=date_to` to `service.get_audit_log()`
    4. Ensure the response includes `new_value` field from each entry (add it to the AuditLogEntry construction)

    **Add POST /sellers/log-export endpoint:**
    1. Route: `@router.post("/log-export", status_code=201)`
    2. Accept `LogExportRequest` body
    3. Call `service.log_export_event(org_id, user_id, body.seller_names, body.export_format)`
    4. Return `{"status": "recorded"}`
    5. Requires `admin.automation` permission (same as other seller endpoints)

    **Add POST /sellers/flag-batch endpoint:**
    1. Route: `@router.post("/flag-batch")`
    2. Accept `FlagBatchRequest` body
    3. Call `service.batch_toggle_flag(org_id, user_id, body.seller_ids, body.flagged)`
    4. Return `FlagBatchResponse(updated_count=count)`
    5. Requires `admin.automation` permission

    **Ensure correct import ordering**: Import new models at the top of sellers.py alongside existing imports.
  </action>
  <verify>
    - grep confirms `log-export` route exists in sellers.py
    - grep confirms `flag-batch` route exists in sellers.py
    - grep confirms `action_types` parameter in the audit-log GET endpoint
    - `cd apps/api && python -c "from app.routers.sellers import router; print('Router OK')"` succeeds (from src directory)
  </verify>
  <done>
    GET /sellers/audit-log accepts action_types, date_from, date_to query params for filtering. POST /sellers/log-export records export events. POST /sellers/flag-batch batch-updates flag state and records audit entry. All three endpoints require admin.automation permission.
  </done>
</task>

</tasks>

<verification>
1. Migration file 054_export_flag_audit.sql contains DROP + ADD constraint with 5 action types and CREATE INDEX
2. collection.py has log_export_event(), log_flag_event(), batch_toggle_flag() methods
3. get_audit_log() accepts action_types, date_from, date_to parameters
4. sellers.py has GET /audit-log with filter params, POST /log-export, POST /flag-batch
5. models.py AuditLogEntry.action includes "export" and "flag"
6. All imports resolve correctly
</verification>

<success_criteria>
- Migration extends seller_audit_log check constraint to accept 'export' and 'flag' action types
- Collection service can log export events, flag events, and batch toggle flags
- Audit log API supports server-side filtering by action type and date range
- Frontend can call POST /sellers/log-export after any export operation
- Frontend can call POST /sellers/flag-batch for bulk flag operations
- All new code follows existing patterns (permission checks, error handling, response models)
</success_criteria>

<output>
After completion, create `.planning/phases/31-collection-history-system/31-01-SUMMARY.md`
</output>
