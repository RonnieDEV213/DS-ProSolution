---
phase: 12-live-activity-feed-concurrency
plan: 04
type: execute
wave: 3
depends_on: ["12-02", "12-03"]
files_modified:
  - apps/api/src/app/routers/collection.py
  - apps/api/src/app/routers/sellers.py
  - apps/api/src/app/models.py
  - apps/api/src/app/auth.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SSE endpoint accepts token via query parameter for EventSource compatibility"
    - "History endpoint returns seller_count_snapshot"
    - "Audit log endpoint returns seller_count_snapshot"
    - "EventSource can connect to SSE endpoint with token query param"
  artifacts:
    - path: "apps/api/src/app/auth.py"
      provides: "Query param auth support for SSE endpoints"
      contains: "get_token_from_request"
    - path: "apps/api/src/app/routers/collection.py"
      provides: "SSE endpoint with query param auth, history with snapshot"
      contains: "seller_count_snapshot"
    - path: "apps/api/src/app/routers/sellers.py"
      provides: "Audit log endpoint returning snapshot"
      contains: "seller_count_snapshot"
  key_links:
    - from: "apps/api/src/app/routers/collection.py"
      to: "apps/api/src/app/auth.py"
      via: "require_permission_flexible dependency"
      pattern: "require_permission_flexible"
---

<objective>
Add query parameter authentication support for SSE endpoints and update history/audit-log responses to include seller_count_snapshot.

Purpose: Enable EventSource connections (which don't support Authorization headers) and complete the seller snapshot feature.
Output: SSE with query param auth, history and audit-log responses with seller snapshots.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-live-activity-feed-concurrency/12-CONTEXT.md
@.planning/phases/12-live-activity-feed-concurrency/12-01-SUMMARY.md
@.planning/phases/12-live-activity-feed-concurrency/12-02-SUMMARY.md
@.planning/phases/12-live-activity-feed-concurrency/12-03-SUMMARY.md
@apps/api/src/app/auth.py
@apps/api/src/app/routers/collection.py
@apps/api/src/app/routers/sellers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add flexible auth support for SSE endpoints</name>
  <files>apps/api/src/app/auth.py</files>
  <action>
Add a function that can extract token from either Authorization header or query parameter. This is needed because EventSource API doesn't support custom headers.

Add to auth.py (after existing auth functions):

```python
from fastapi import Query

def get_token_from_request(
    authorization: str | None = Header(None),
    token: str | None = Query(None),
) -> str | None:
    """
    Extract JWT token from either Authorization header or query parameter.

    Priority:
    1. Authorization header (Bearer token)
    2. Token query parameter

    This supports EventSource connections which cannot set headers.
    """
    if authorization and authorization.startswith("Bearer "):
        return authorization[7:]  # Strip "Bearer " prefix
    if token:
        return token
    return None


async def require_permission_flexible(
    permission_key: str,
    authorization: str | None = Header(None),
    token: str | None = Query(None),
) -> dict:
    """
    Flexible auth dependency that accepts token from header OR query param.

    Use this for SSE endpoints where EventSource cannot set headers.

    Returns user dict on success, raises HTTPException on failure.
    """
    # Get token from either source
    jwt_token = get_token_from_request(authorization, token)

    if not jwt_token:
        raise HTTPException(
            status_code=401,
            detail="Authentication required",
        )

    try:
        # Verify JWT and get user
        supabase = get_supabase()
        user_response = supabase.auth.get_user(jwt_token)

        if not user_response or not user_response.user:
            raise HTTPException(status_code=401, detail="Invalid token")

        user_id = user_response.user.id

        # Get membership and check permission
        membership = get_membership_by_user(supabase, user_id)
        if not membership:
            raise HTTPException(status_code=403, detail="No active membership")

        # Check permission
        has_permission = check_permission(supabase, user_id, membership["org_id"], permission_key)
        if not has_permission:
            raise HTTPException(status_code=403, detail=f"Missing permission: {permission_key}")

        return {
            "user_id": user_id,
            "membership": membership,
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Auth error: {e}")
        raise HTTPException(status_code=401, detail="Authentication failed")


def require_permission_key_flexible(permission_key: str):
    """
    Factory function to create flexible permission dependency.

    Usage:
        @router.get("/sse-endpoint")
        async def sse(user: dict = Depends(require_permission_key_flexible("admin.automation"))):
            ...
    """
    async def dependency(
        authorization: str | None = Header(None),
        token: str | None = Query(None),
    ) -> dict:
        return await require_permission_flexible(permission_key, authorization, token)

    return dependency
```

This provides a drop-in replacement for `require_permission_key` that also accepts query parameter auth.

Note: The existing `require_permission_key` uses `get_supabase()` and `get_membership_by_user()` functions. Make sure these are imported/available. Looking at auth.py, it likely already has these. If `get_membership_by_user` doesn't exist, the pattern might be different - adapt to match existing auth patterns.

Actually, let me look at the existing auth.py pattern more carefully. The implementation should match the existing `require_permission_key` but with query param support. The key insight is:

```python
# Existing pattern:
def require_permission_key(permission_key: str):
    async def _inner(authorization: str = Header(...)):
        # ... validation logic ...
    return _inner
```

New pattern adds `token: str | None = Query(None)` and checks both sources.
  </action>
  <verify>
- auth.py has get_token_from_request function
- auth.py has require_permission_key_flexible function
- Both header and query param token sources are checked
  </verify>
  <done>Flexible auth dependency created that accepts token from header or query param</done>
</task>

<task type="auto">
  <name>Task 2: Update SSE endpoint to use flexible auth and fix history endpoint</name>
  <files>apps/api/src/app/routers/collection.py, apps/api/src/app/models.py</files>
  <action>
1. Update the SSE activity endpoint to use flexible auth:

In collection.py, update the import:

```python
from app.auth import require_permission_key, require_permission_key_flexible
```

Update the SSE endpoint to use flexible auth:

```python
@router.get("/runs/{run_id}/activity")
async def stream_activity(
    run_id: str,
    user: dict = Depends(require_permission_key_flexible("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    # ... rest of implementation unchanged ...
```

2. Update CollectionHistoryEntry model to include seller_count_snapshot:

In models.py, find CollectionHistoryEntry and add the field:

```python
class CollectionHistoryEntry(BaseModel):
    id: str
    name: str
    status: str
    started_at: str | None = None
    completed_at: str | None = None
    duration_seconds: int | None = None
    categories_count: int
    products_total: int
    products_searched: int
    sellers_found: int
    sellers_new: int
    failed_items: int
    created_by: str
    seller_count_snapshot: int | None = None  # ADD THIS
```

3. Update the get_history method in collection.py service to include seller_count_snapshot:

Find the get_history method and update the SELECT to include seller_count_snapshot:

```python
async def get_history(
    self,
    org_id: str,
    limit: int = 50,
    offset: int = 0,
) -> tuple[list[dict], int]:
    result = (
        self.supabase.table("collection_runs")
        .select(
            "id, name, status, category_ids, "
            "started_at, completed_at, "
            "products_total, products_searched, "
            "sellers_found, sellers_new, "
            "failed_items, created_by, seller_count_snapshot",  # ADD seller_count_snapshot
            count="exact"
        )
        # ... rest unchanged ...
    )

    # In the return dict for each run, add:
    runs.append({
        # ... existing fields ...
        "seller_count_snapshot": r.get("seller_count_snapshot"),
    })
```

4. Update the get_collection_history endpoint response mapping:

In the router endpoint `get_collection_history`, ensure seller_count_snapshot is passed:

```python
return CollectionHistoryResponse(
    runs=[
        CollectionHistoryEntry(
            # ... existing fields ...
            seller_count_snapshot=r.get("seller_count_snapshot"),
        )
        for r in runs
    ],
    total=total,
)
```
  </action>
  <verify>
- SSE endpoint uses require_permission_key_flexible
- CollectionHistoryEntry model has seller_count_snapshot field
- get_history SELECT includes seller_count_snapshot
- History endpoint response includes seller_count_snapshot
  </verify>
  <done>SSE endpoint uses flexible auth, history endpoint returns seller snapshots</done>
</task>

<task type="auto">
  <name>Task 3: Update audit-log endpoint to return seller_count_snapshot</name>
  <files>apps/api/src/app/routers/sellers.py, apps/api/src/app/models.py</files>
  <action>
1. Check if there's an AuditLogEntry model in models.py. If not, add one. If there is, add seller_count_snapshot:

Look for audit log related model. If it exists, add:

```python
class AuditLogEntry(BaseModel):
    id: str
    action: str
    seller_name: str
    source: str
    source_run_id: str | None = None
    user_id: str | None = None
    created_at: str
    affected_count: int
    seller_count_snapshot: int | None = None  # ADD THIS
```

2. Update the get_audit_log method in collection.py service to include seller_count_snapshot:

Find get_audit_log and update the SELECT:

```python
async def get_audit_log(
    self,
    org_id: str,
    limit: int = 50,
    offset: int = 0,
) -> tuple[list[dict], int]:
    result = (
        self.supabase.table("seller_audit_log")
        .select(
            "id, action, seller_name, source, source_run_id, user_id, created_at, affected_count, seller_count_snapshot",  # ADD seller_count_snapshot
            count="exact"
        )
        .eq("org_id", org_id)
        .order("created_at", desc=True)
        .range(offset, offset + limit - 1)
        .execute()
    )
    return result.data or [], result.count or 0
```

3. Update the audit-log endpoint in sellers.py to return seller_count_snapshot:

Find the audit-log endpoint (likely GET /sellers/audit-log) and ensure the response includes seller_count_snapshot:

```python
@router.get("/audit-log")
async def get_audit_log(
    limit: int = 50,
    offset: int = 0,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    org_id = user["membership"]["org_id"]
    entries, total = await service.get_audit_log(org_id, limit=limit, offset=offset)

    return {
        "entries": [
            {
                "id": e["id"],
                "action": e["action"],
                "seller_name": e["seller_name"],
                "source": e["source"],
                "source_run_id": e.get("source_run_id"),
                "user_id": e.get("user_id"),
                "created_at": e["created_at"],
                "affected_count": e.get("affected_count", 1),
                "seller_count_snapshot": e.get("seller_count_snapshot"),  # ADD THIS
            }
            for e in entries
        ],
        "total": total,
    }
```

The audit-log endpoint may be in sellers.py or collection.py - find it and update accordingly.
  </action>
  <verify>
- AuditLogEntry model (if exists) has seller_count_snapshot
- get_audit_log SELECT includes seller_count_snapshot
- Audit-log endpoint response includes seller_count_snapshot for each entry
  </verify>
  <done>Audit-log endpoint returns seller_count_snapshot for each entry</done>
</task>

</tasks>

<verification>
- [ ] auth.py has require_permission_key_flexible function
- [ ] SSE endpoint uses flexible auth (accepts token query param)
- [ ] CollectionHistoryEntry model has seller_count_snapshot
- [ ] get_history includes seller_count_snapshot in SELECT and response
- [ ] get_audit_log includes seller_count_snapshot in SELECT and response
- [ ] EventSource can connect to SSE endpoint with ?token= query param
- [ ] No Python syntax errors in modified files
</verification>

<success_criteria>
1. SSE endpoint accepts authentication via query parameter
2. EventSource connections work from frontend
3. History endpoint returns seller_count_snapshot for each run
4. Audit-log endpoint returns seller_count_snapshot for each entry
5. Frontend history panel can display "X sellers at this point"
</success_criteria>

<output>
After completion, create `.planning/phases/12-live-activity-feed-concurrency/12-04-SUMMARY.md`
</output>
