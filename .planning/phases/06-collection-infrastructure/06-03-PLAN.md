---
phase: 06-collection-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - apps/api/migrations/038_seller_audit_log.sql
  - apps/api/migrations/039_run_templates.sql
  - apps/api/migrations/040_enhanced_progress.sql
  - apps/api/src/app/models.py
  - apps/api/src/app/services/collection.py
  - apps/api/src/app/routers/collection.py
  - apps/api/src/app/routers/sellers.py
  - apps/api/src/app/main.py
autonomous: true

must_haves:
  truths:
    - "Sellers can be added, edited, and deleted via API"
    - "All seller changes are logged with full audit trail"
    - "Two seller snapshots can be compared to show additions/removals"
    - "Run templates can be saved and retrieved"
    - "Progress tracks departments, categories, products, and new sellers"
  artifacts:
    - path: "apps/api/migrations/038_seller_audit_log.sql"
      provides: "Audit log schema for seller changes"
      contains: "seller_audit_log"
    - path: "apps/api/migrations/039_run_templates.sql"
      provides: "Run templates schema"
      contains: "run_templates"
    - path: "apps/api/migrations/040_enhanced_progress.sql"
      provides: "Enhanced progress tracking columns"
      contains: "departments_total"
    - path: "apps/api/src/app/routers/sellers.py"
      provides: "Seller CRUD endpoints"
      exports: ["router"]
  key_links:
    - from: "apps/api/src/app/routers/sellers.py"
      to: "apps/api/src/app/services/collection.py"
      via: "import CollectionService"
      pattern: "from app.services.collection import"
    - from: "apps/api/src/app/main.py"
      to: "apps/api/src/app/routers/sellers.py"
      via: "router include"
      pattern: "app.include_router\\(sellers"
---

<objective>
Extend backend to support seller-focused Collections UI: direct seller CRUD, audit logging for all changes, diff calculation, run templates, and enhanced progress tracking (departments/categories/products/sellers).

Purpose: Enable the new UI to show master seller list, track all changes with full audit trail, compare snapshots, and display detailed real-time progress.
Output: 3 migrations + extended models/services/routes for seller management and progress tracking
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-collection-infrastructure/06-CONTEXT.md
@.planning/phases/06-collection-infrastructure/06-01-SUMMARY.md
@.planning/phases/06-collection-infrastructure/06-02-SUMMARY.md
@apps/api/migrations/037_collection_infrastructure.sql (existing schema)
@apps/api/src/app/services/collection.py (existing service)
@apps/api/src/app/routers/collection.py (existing router)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create seller audit log migration</name>
  <files>apps/api/migrations/038_seller_audit_log.sql</files>
  <action>
Create migration for seller_audit_log table to track all changes with full audit trail.

```sql
-- Migration: 038_seller_audit_log.sql
-- Purpose: Audit log for seller changes (add/edit/remove)

-- Seller audit log table
CREATE TABLE IF NOT EXISTS seller_audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,

    -- What changed
    action TEXT NOT NULL CHECK (action IN ('add', 'edit', 'remove')),
    seller_id UUID REFERENCES sellers(id) ON DELETE SET NULL,
    seller_name TEXT NOT NULL,  -- Capture name at time of action
    old_value JSONB,  -- Previous state for edits
    new_value JSONB,  -- New state for edits/adds

    -- Source of change
    source TEXT NOT NULL CHECK (source IN ('manual', 'collection_run', 'auto_remove')),
    source_run_id UUID REFERENCES collection_runs(id) ON DELETE SET NULL,
    source_criteria JSONB,  -- For auto_remove: what criteria matched

    -- Who made the change
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,

    -- When
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Affected count (for bulk operations)
    affected_count INTEGER NOT NULL DEFAULT 1
);

-- Indexes for common queries
CREATE INDEX idx_seller_audit_log_org ON seller_audit_log(org_id);
CREATE INDEX idx_seller_audit_log_created ON seller_audit_log(created_at DESC);
CREATE INDEX idx_seller_audit_log_source_run ON seller_audit_log(source_run_id) WHERE source_run_id IS NOT NULL;

-- RLS policies
ALTER TABLE seller_audit_log ENABLE ROW LEVEL SECURITY;

CREATE POLICY seller_audit_log_org_access ON seller_audit_log
    FOR ALL USING (
        org_id IN (SELECT org_id FROM memberships WHERE user_id = auth.uid())
    );

-- Comment
COMMENT ON TABLE seller_audit_log IS 'Audit trail for all seller changes - manual edits, collection runs, auto-removals';
```
  </action>
  <verify>
- File exists: `test -f apps/api/migrations/038_seller_audit_log.sql && echo "exists"`
- Contains table: `grep "CREATE TABLE.*seller_audit_log" apps/api/migrations/038_seller_audit_log.sql`
  </verify>
  <done>
Migration 038 created with seller_audit_log table:
- Tracks action type (add/edit/remove)
- Captures seller name and state at time of action
- Records source (manual/collection_run/auto_remove)
- Links to user and run when applicable
- RLS policy for org-scoped access
  </done>
</task>

<task type="auto">
  <name>Task 2: Create run templates migration</name>
  <files>apps/api/migrations/039_run_templates.sql</files>
  <action>
Create migration for run_templates table to save and reuse collection configurations.

```sql
-- Migration: 039_run_templates.sql
-- Purpose: Save collection run configurations as reusable templates

CREATE TABLE IF NOT EXISTS run_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES orgs(id) ON DELETE CASCADE,

    -- Template info
    name TEXT NOT NULL,
    description TEXT,
    is_default BOOLEAN NOT NULL DEFAULT FALSE,

    -- Configuration
    department_ids TEXT[] NOT NULL DEFAULT '{}',  -- Which departments to include
    concurrency INTEGER NOT NULL DEFAULT 3 CHECK (concurrency >= 1 AND concurrency <= 10),

    -- Metadata
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Unique name per org
    UNIQUE (org_id, name)
);

-- Only one default template per org
CREATE UNIQUE INDEX idx_run_templates_default ON run_templates(org_id) WHERE is_default = TRUE;

-- RLS policies
ALTER TABLE run_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY run_templates_org_access ON run_templates
    FOR ALL USING (
        org_id IN (SELECT org_id FROM memberships WHERE user_id = auth.uid())
    );

-- Insert default "All Departments" template (will be created per-org on first access)
COMMENT ON TABLE run_templates IS 'Saved configurations for collection runs - departments, concurrency, etc.';
```
  </action>
  <verify>
- File exists: `test -f apps/api/migrations/039_run_templates.sql && echo "exists"`
- Contains table: `grep "CREATE TABLE.*run_templates" apps/api/migrations/039_run_templates.sql`
  </verify>
  <done>
Migration 039 created with run_templates table:
- Template name and description
- Department selection
- Concurrency setting (1-10)
- One default template per org
- RLS policy for org-scoped access
  </done>
</task>

<task type="auto">
  <name>Task 3: Create enhanced progress migration</name>
  <files>apps/api/migrations/040_enhanced_progress.sql</files>
  <action>
Add enhanced progress tracking columns to collection_runs for departments/categories/products/sellers counts.

```sql
-- Migration: 040_enhanced_progress.sql
-- Purpose: Enhanced progress tracking for collection runs

-- Add hierarchical progress columns to collection_runs
ALTER TABLE collection_runs
ADD COLUMN IF NOT EXISTS departments_total INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS departments_completed INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS categories_total INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS categories_completed INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS products_total INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS products_searched INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS sellers_found INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS sellers_new INTEGER NOT NULL DEFAULT 0;

-- Add current worker status for live progress display
ALTER TABLE collection_runs
ADD COLUMN IF NOT EXISTS worker_status JSONB NOT NULL DEFAULT '[]'::JSONB;
-- Structure: [{ "worker_id": 1, "department": "Electronics", "category": "Laptops", "product": "MacBook Pro", "status": "searching" }, ...]

-- Add template reference
ALTER TABLE collection_runs
ADD COLUMN IF NOT EXISTS template_id UUID REFERENCES run_templates(id) ON DELETE SET NULL;

-- Comment
COMMENT ON COLUMN collection_runs.worker_status IS 'Real-time status of each concurrent worker: department, category, current product';
COMMENT ON COLUMN collection_runs.departments_total IS 'Total Amazon Best Sellers departments being processed';
COMMENT ON COLUMN collection_runs.sellers_new IS 'New unique sellers added (not already in master list)';
```
  </action>
  <verify>
- File exists: `test -f apps/api/migrations/040_enhanced_progress.sql && echo "exists"`
- Contains columns: `grep "departments_total" apps/api/migrations/040_enhanced_progress.sql`
  </verify>
  <done>
Migration 040 adds to collection_runs:
- departments_total/completed counts
- categories_total/completed counts
- products_total/searched counts
- sellers_found/new counts
- worker_status JSONB for real-time per-worker display
- template_id reference
  </done>
</task>

<task type="auto">
  <name>Task 4: Add Pydantic models for new features</name>
  <files>apps/api/src/app/models.py</files>
  <action>
Add Pydantic models for sellers, audit logs, templates, and enhanced progress.

**Add these models to models.py:**

```python
# Seller models
class SellerCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)

class SellerUpdate(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)

class SellerResponse(BaseModel):
    id: str
    name: str
    normalized_name: str
    discovered_at: datetime
    from_product: str | None
    from_run_id: str | None

class SellerListResponse(BaseModel):
    sellers: list[SellerResponse]
    total: int

# Audit log models
class AuditLogEntry(BaseModel):
    id: str
    action: Literal["add", "edit", "remove"]
    seller_name: str
    source: Literal["manual", "collection_run", "auto_remove"]
    source_run_id: str | None
    user_id: str | None
    created_at: datetime
    affected_count: int

class AuditLogResponse(BaseModel):
    entries: list[AuditLogEntry]
    total: int

# Diff models
class SellerDiff(BaseModel):
    added: list[str]  # Seller names added
    removed: list[str]  # Seller names removed
    added_count: int
    removed_count: int

class DiffRequest(BaseModel):
    source: Literal["log", "current"]
    source_id: str | None = None  # Log ID if source is "log"
    target: Literal["log", "current"]
    target_id: str | None = None  # Log ID if target is "log"

# Template models
class RunTemplateCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: str | None = None
    department_ids: list[str] = []
    concurrency: int = Field(default=3, ge=1, le=10)
    is_default: bool = False

class RunTemplateUpdate(BaseModel):
    name: str | None = None
    description: str | None = None
    department_ids: list[str] | None = None
    concurrency: int | None = Field(default=None, ge=1, le=10)
    is_default: bool | None = None

class RunTemplateResponse(BaseModel):
    id: str
    name: str
    description: str | None
    department_ids: list[str]
    concurrency: int
    is_default: bool
    created_at: datetime

class RunTemplateListResponse(BaseModel):
    templates: list[RunTemplateResponse]

# Enhanced progress models
class WorkerStatus(BaseModel):
    worker_id: int
    department: str
    category: str
    product: str | None
    status: Literal["idle", "fetching", "searching", "complete"]

class EnhancedProgress(BaseModel):
    # Hierarchical counts
    departments_total: int
    departments_completed: int
    categories_total: int
    categories_completed: int
    products_total: int
    products_searched: int
    sellers_found: int
    sellers_new: int
    # Cost
    actual_cost_cents: int
    budget_cap_cents: int
    cost_status: Literal["safe", "warning", "exceeded"]
    # Workers
    worker_status: list[WorkerStatus]
```
  </action>
  <verify>
- SellerCreate exists: `grep "class SellerCreate" apps/api/src/app/models.py`
- AuditLogEntry exists: `grep "class AuditLogEntry" apps/api/src/app/models.py`
- RunTemplateCreate exists: `grep "class RunTemplateCreate" apps/api/src/app/models.py`
- EnhancedProgress exists: `grep "class EnhancedProgress" apps/api/src/app/models.py`
  </verify>
  <done>
Added Pydantic models:
- Seller CRUD models (Create, Update, Response, List)
- Audit log models (Entry, Response)
- Diff models (SellerDiff, DiffRequest)
- Template models (Create, Update, Response, List)
- Enhanced progress models (WorkerStatus, EnhancedProgress)
  </done>
</task>

<task type="auto">
  <name>Task 5: Extend CollectionService with seller and audit methods</name>
  <files>apps/api/src/app/services/collection.py</files>
  <action>
Add methods to CollectionService for seller CRUD, audit logging, and diff calculation.

**Add these methods:**

```python
# ============ Seller Management ============

async def get_sellers(self, limit: int = 1000, offset: int = 0) -> tuple[list[dict], int]:
    """Get all sellers for the org, newest first."""
    result = await self.db.execute(
        """
        SELECT id, name, normalized_name, discovered_at, from_product, from_run_id
        FROM sellers
        WHERE org_id = :org_id
        ORDER BY discovered_at DESC
        LIMIT :limit OFFSET :offset
        """,
        {"org_id": str(self.org_id), "limit": limit, "offset": offset}
    )
    sellers = [dict(r._mapping) for r in result.fetchall()]

    count_result = await self.db.execute(
        "SELECT COUNT(*) FROM sellers WHERE org_id = :org_id",
        {"org_id": str(self.org_id)}
    )
    total = count_result.scalar()

    return sellers, total

async def add_seller(self, name: str, source: str = "manual", run_id: str | None = None) -> dict:
    """Add a seller manually or from collection run."""
    normalized = self._normalize_seller_name(name)

    # Check if already exists
    existing = await self.db.execute(
        "SELECT id FROM sellers WHERE org_id = :org_id AND normalized_name = :normalized",
        {"org_id": str(self.org_id), "normalized": normalized}
    )
    if existing.fetchone():
        raise ValueError(f"Seller '{name}' already exists")

    # Insert seller
    result = await self.db.execute(
        """
        INSERT INTO sellers (org_id, name, normalized_name, from_run_id)
        VALUES (:org_id, :name, :normalized, :run_id)
        RETURNING id, name, normalized_name, discovered_at, from_product, from_run_id
        """,
        {"org_id": str(self.org_id), "name": name, "normalized": normalized, "run_id": run_id}
    )
    seller = dict(result.fetchone()._mapping)

    # Log the addition
    await self._log_seller_change("add", seller["id"], name, None, {"name": name}, source, run_id)

    return seller

async def update_seller(self, seller_id: str, new_name: str) -> dict:
    """Update a seller's name."""
    # Get current state
    result = await self.db.execute(
        "SELECT id, name, normalized_name FROM sellers WHERE id = :id AND org_id = :org_id",
        {"id": seller_id, "org_id": str(self.org_id)}
    )
    current = result.fetchone()
    if not current:
        raise ValueError("Seller not found")

    old_name = current.name
    new_normalized = self._normalize_seller_name(new_name)

    # Check for duplicate
    dup_check = await self.db.execute(
        "SELECT id FROM sellers WHERE org_id = :org_id AND normalized_name = :normalized AND id != :id",
        {"org_id": str(self.org_id), "normalized": new_normalized, "id": seller_id}
    )
    if dup_check.fetchone():
        raise ValueError(f"Seller '{new_name}' already exists")

    # Update
    result = await self.db.execute(
        """
        UPDATE sellers SET name = :name, normalized_name = :normalized
        WHERE id = :id
        RETURNING id, name, normalized_name, discovered_at, from_product, from_run_id
        """,
        {"id": seller_id, "name": new_name, "normalized": new_normalized}
    )
    seller = dict(result.fetchone()._mapping)

    # Log the edit
    await self._log_seller_change("edit", seller_id, new_name, {"name": old_name}, {"name": new_name}, "manual", None)

    return seller

async def remove_seller(self, seller_id: str, source: str = "manual", criteria: dict | None = None) -> None:
    """Remove a seller."""
    # Get current state
    result = await self.db.execute(
        "SELECT name FROM sellers WHERE id = :id AND org_id = :org_id",
        {"id": seller_id, "org_id": str(self.org_id)}
    )
    current = result.fetchone()
    if not current:
        raise ValueError("Seller not found")

    name = current.name

    # Delete
    await self.db.execute(
        "DELETE FROM sellers WHERE id = :id",
        {"id": seller_id}
    )

    # Log the removal
    await self._log_seller_change("remove", seller_id, name, {"name": name}, None, source, None, criteria)

def _normalize_seller_name(self, name: str) -> str:
    """Normalize seller name for deduplication."""
    import re
    # Lowercase, strip, collapse whitespace
    normalized = re.sub(r'\s+', ' ', name.lower().strip())
    return normalized

# ============ Audit Logging ============

async def _log_seller_change(
    self,
    action: str,
    seller_id: str,
    seller_name: str,
    old_value: dict | None,
    new_value: dict | None,
    source: str,
    run_id: str | None,
    criteria: dict | None = None,
    affected_count: int = 1
) -> None:
    """Log a seller change to the audit log."""
    import json
    await self.db.execute(
        """
        INSERT INTO seller_audit_log
        (org_id, action, seller_id, seller_name, old_value, new_value, source, source_run_id, source_criteria, user_id, affected_count)
        VALUES (:org_id, :action, :seller_id, :seller_name, :old_value, :new_value, :source, :run_id, :criteria, :user_id, :count)
        """,
        {
            "org_id": str(self.org_id),
            "action": action,
            "seller_id": seller_id,
            "seller_name": seller_name,
            "old_value": json.dumps(old_value) if old_value else None,
            "new_value": json.dumps(new_value) if new_value else None,
            "source": source,
            "run_id": run_id,
            "criteria": json.dumps(criteria) if criteria else None,
            "user_id": str(self.user_id) if self.user_id else None,
            "count": affected_count
        }
    )

async def get_audit_log(self, limit: int = 50, offset: int = 0) -> tuple[list[dict], int]:
    """Get audit log entries, newest first."""
    result = await self.db.execute(
        """
        SELECT id, action, seller_name, source, source_run_id, user_id, created_at, affected_count
        FROM seller_audit_log
        WHERE org_id = :org_id
        ORDER BY created_at DESC
        LIMIT :limit OFFSET :offset
        """,
        {"org_id": str(self.org_id), "limit": limit, "offset": offset}
    )
    entries = [dict(r._mapping) for r in result.fetchall()]

    count_result = await self.db.execute(
        "SELECT COUNT(*) FROM seller_audit_log WHERE org_id = :org_id",
        {"org_id": str(self.org_id)}
    )
    total = count_result.scalar()

    return entries, total

async def get_sellers_at_log(self, log_id: str) -> list[str]:
    """Get the seller list as it was right after a specific log entry."""
    # Get the log entry timestamp
    log_result = await self.db.execute(
        "SELECT created_at FROM seller_audit_log WHERE id = :id AND org_id = :org_id",
        {"id": log_id, "org_id": str(self.org_id)}
    )
    log_entry = log_result.fetchone()
    if not log_entry:
        raise ValueError("Log entry not found")

    # Reconstruct seller list at that point in time
    # Get all sellers that existed at that time (added before, not removed before)
    result = await self.db.execute(
        """
        WITH added AS (
            SELECT DISTINCT seller_name FROM seller_audit_log
            WHERE org_id = :org_id AND action = 'add' AND created_at <= :timestamp
        ),
        removed AS (
            SELECT DISTINCT seller_name FROM seller_audit_log
            WHERE org_id = :org_id AND action = 'remove' AND created_at <= :timestamp
        )
        SELECT seller_name FROM added
        WHERE seller_name NOT IN (SELECT seller_name FROM removed)
        ORDER BY seller_name
        """,
        {"org_id": str(self.org_id), "timestamp": log_entry.created_at}
    )
    return [r.seller_name for r in result.fetchall()]

async def calculate_diff(self, source_sellers: list[str], target_sellers: list[str]) -> dict:
    """Calculate diff between two seller lists."""
    source_set = set(source_sellers)
    target_set = set(target_sellers)

    added = sorted(target_set - source_set)
    removed = sorted(source_set - target_set)

    return {
        "added": added,
        "removed": removed,
        "added_count": len(added),
        "removed_count": len(removed)
    }

# ============ Templates ============

async def get_templates(self) -> list[dict]:
    """Get all run templates for the org."""
    result = await self.db.execute(
        """
        SELECT id, name, description, department_ids, concurrency, is_default, created_at
        FROM run_templates
        WHERE org_id = :org_id
        ORDER BY is_default DESC, name ASC
        """,
        {"org_id": str(self.org_id)}
    )
    return [dict(r._mapping) for r in result.fetchall()]

async def create_template(self, name: str, description: str | None, department_ids: list[str], concurrency: int, is_default: bool) -> dict:
    """Create a new run template."""
    # If setting as default, unset other defaults
    if is_default:
        await self.db.execute(
            "UPDATE run_templates SET is_default = FALSE WHERE org_id = :org_id",
            {"org_id": str(self.org_id)}
        )

    result = await self.db.execute(
        """
        INSERT INTO run_templates (org_id, name, description, department_ids, concurrency, is_default, created_by)
        VALUES (:org_id, :name, :description, :dept_ids, :concurrency, :is_default, :user_id)
        RETURNING id, name, description, department_ids, concurrency, is_default, created_at
        """,
        {
            "org_id": str(self.org_id),
            "name": name,
            "description": description,
            "dept_ids": department_ids,
            "concurrency": concurrency,
            "is_default": is_default,
            "user_id": str(self.user_id) if self.user_id else None
        }
    )
    return dict(result.fetchone()._mapping)

async def update_template(self, template_id: str, updates: dict) -> dict:
    """Update a run template."""
    # If setting as default, unset other defaults
    if updates.get("is_default"):
        await self.db.execute(
            "UPDATE run_templates SET is_default = FALSE WHERE org_id = :org_id AND id != :id",
            {"org_id": str(self.org_id), "id": template_id}
        )

    # Build update query dynamically
    set_clauses = []
    params = {"id": template_id, "org_id": str(self.org_id)}

    for key in ["name", "description", "department_ids", "concurrency", "is_default"]:
        if key in updates and updates[key] is not None:
            set_clauses.append(f"{key} = :{key}")
            params[key] = updates[key]

    if not set_clauses:
        raise ValueError("No updates provided")

    set_clauses.append("updated_at = NOW()")

    result = await self.db.execute(
        f"""
        UPDATE run_templates SET {", ".join(set_clauses)}
        WHERE id = :id AND org_id = :org_id
        RETURNING id, name, description, department_ids, concurrency, is_default, created_at
        """,
        params
    )
    row = result.fetchone()
    if not row:
        raise ValueError("Template not found")
    return dict(row._mapping)

async def delete_template(self, template_id: str) -> None:
    """Delete a run template."""
    result = await self.db.execute(
        "DELETE FROM run_templates WHERE id = :id AND org_id = :org_id RETURNING id",
        {"id": template_id, "org_id": str(self.org_id)}
    )
    if not result.fetchone():
        raise ValueError("Template not found")

# ============ Enhanced Progress ============

async def get_enhanced_progress(self, run_id: str) -> dict:
    """Get detailed progress for a collection run."""
    result = await self.db.execute(
        """
        SELECT
            departments_total, departments_completed,
            categories_total, categories_completed,
            products_total, products_searched,
            sellers_found, sellers_new,
            actual_cost_cents, budget_cap_cents,
            worker_status
        FROM collection_runs
        WHERE id = :id AND org_id = :org_id
        """,
        {"id": run_id, "org_id": str(self.org_id)}
    )
    row = result.fetchone()
    if not row:
        raise ValueError("Run not found")

    data = dict(row._mapping)

    # Calculate cost status
    if data["actual_cost_cents"] > data["budget_cap_cents"]:
        cost_status = "exceeded"
    elif data["actual_cost_cents"] > data["budget_cap_cents"] * 0.8:
        cost_status = "warning"
    else:
        cost_status = "safe"

    data["cost_status"] = cost_status

    return data
```
  </action>
  <verify>
- get_sellers exists: `grep "async def get_sellers" apps/api/src/app/services/collection.py`
- add_seller exists: `grep "async def add_seller" apps/api/src/app/services/collection.py`
- get_audit_log exists: `grep "async def get_audit_log" apps/api/src/app/services/collection.py`
- calculate_diff exists: `grep "async def calculate_diff" apps/api/src/app/services/collection.py`
- get_templates exists: `grep "async def get_templates" apps/api/src/app/services/collection.py`
- get_enhanced_progress exists: `grep "async def get_enhanced_progress" apps/api/src/app/services/collection.py`
  </verify>
  <done>
CollectionService extended with:
- Seller CRUD: get_sellers, add_seller, update_seller, remove_seller
- Audit logging: _log_seller_change, get_audit_log, get_sellers_at_log
- Diff calculation: calculate_diff
- Templates: get_templates, create_template, update_template, delete_template
- Enhanced progress: get_enhanced_progress
  </done>
</task>

<task type="auto">
  <name>Task 6: Create sellers router</name>
  <files>apps/api/src/app/routers/sellers.py</files>
  <action>
Create new router for seller CRUD, audit log, and diff endpoints.

```python
"""Seller management endpoints."""

from fastapi import APIRouter, Depends, HTTPException
from ..auth import get_current_user, AuthenticatedUser
from ..database import get_db
from ..services.collection import CollectionService
from ..models import (
    SellerCreate,
    SellerUpdate,
    SellerResponse,
    SellerListResponse,
    AuditLogResponse,
    DiffRequest,
    SellerDiff,
)

router = APIRouter(prefix="/sellers", tags=["sellers"])


async def get_collection_service(
    user: AuthenticatedUser = Depends(get_current_user),
    db=Depends(get_db),
) -> CollectionService:
    """Get CollectionService instance for current user."""
    return CollectionService(db, user.org_id, user.user_id)


# ============ Seller CRUD ============

@router.get("", response_model=SellerListResponse)
async def list_sellers(
    limit: int = 1000,
    offset: int = 0,
    service: CollectionService = Depends(get_collection_service),
):
    """Get all sellers for the organization."""
    sellers, total = await service.get_sellers(limit=limit, offset=offset)
    return SellerListResponse(
        sellers=[SellerResponse(**s) for s in sellers],
        total=total,
    )


@router.post("", response_model=SellerResponse, status_code=201)
async def add_seller(
    data: SellerCreate,
    service: CollectionService = Depends(get_collection_service),
):
    """Add a new seller manually."""
    try:
        seller = await service.add_seller(data.name, source="manual")
        return SellerResponse(**seller)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.patch("/{seller_id}", response_model=SellerResponse)
async def update_seller(
    seller_id: str,
    data: SellerUpdate,
    service: CollectionService = Depends(get_collection_service),
):
    """Update a seller's name."""
    try:
        seller = await service.update_seller(seller_id, data.name)
        return SellerResponse(**seller)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.delete("/{seller_id}", status_code=204)
async def delete_seller(
    seller_id: str,
    service: CollectionService = Depends(get_collection_service),
):
    """Remove a seller."""
    try:
        await service.remove_seller(seller_id, source="manual")
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


# ============ Audit Log ============

@router.get("/audit-log", response_model=AuditLogResponse)
async def get_audit_log(
    limit: int = 50,
    offset: int = 0,
    service: CollectionService = Depends(get_collection_service),
):
    """Get audit log of seller changes."""
    entries, total = await service.get_audit_log(limit=limit, offset=offset)
    return AuditLogResponse(entries=entries, total=total)


@router.get("/audit-log/{log_id}/sellers")
async def get_sellers_at_log(
    log_id: str,
    service: CollectionService = Depends(get_collection_service),
):
    """Get the seller list as it was after a specific log entry."""
    try:
        sellers = await service.get_sellers_at_log(log_id)
        return {"sellers": sellers, "count": len(sellers)}
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


# ============ Diff ============

@router.post("/diff", response_model=SellerDiff)
async def calculate_diff(
    request: DiffRequest,
    service: CollectionService = Depends(get_collection_service),
):
    """Calculate diff between two seller snapshots."""
    # Get source sellers
    if request.source == "current":
        source_sellers_data, _ = await service.get_sellers(limit=100000)
        source_sellers = [s["name"] for s in source_sellers_data]
    else:
        if not request.source_id:
            raise HTTPException(status_code=400, detail="source_id required when source is 'log'")
        try:
            source_sellers = await service.get_sellers_at_log(request.source_id)
        except ValueError as e:
            raise HTTPException(status_code=404, detail=str(e))

    # Get target sellers
    if request.target == "current":
        target_sellers_data, _ = await service.get_sellers(limit=100000)
        target_sellers = [s["name"] for s in target_sellers_data]
    else:
        if not request.target_id:
            raise HTTPException(status_code=400, detail="target_id required when target is 'log'")
        try:
            target_sellers = await service.get_sellers_at_log(request.target_id)
        except ValueError as e:
            raise HTTPException(status_code=404, detail=str(e))

    diff = await service.calculate_diff(source_sellers, target_sellers)
    return SellerDiff(**diff)


# ============ Export ============

@router.get("/export")
async def export_sellers(
    format: str = "json",
    service: CollectionService = Depends(get_collection_service),
):
    """Export all sellers in specified format (json, csv, text)."""
    from fastapi.responses import PlainTextResponse

    sellers, _ = await service.get_sellers(limit=100000)
    names = [s["name"] for s in sellers]

    if format == "csv":
        content = "seller_name\n" + "\n".join(names)
        return PlainTextResponse(content, media_type="text/csv", headers={"Content-Disposition": "attachment; filename=sellers.csv"})
    elif format == "text":
        content = "\n".join(names)
        return PlainTextResponse(content, media_type="text/plain")
    else:  # json
        return {"sellers": names, "count": len(names)}
```
  </action>
  <verify>
- File exists: `test -f apps/api/src/app/routers/sellers.py && echo "exists"`
- Router defined: `grep "router = APIRouter" apps/api/src/app/routers/sellers.py`
- CRUD endpoints: `grep -E "@router\.(get|post|patch|delete)" apps/api/src/app/routers/sellers.py | wc -l` returns 7+
  </verify>
  <done>
Sellers router created with endpoints:
- GET /sellers - List all sellers
- POST /sellers - Add seller manually
- PATCH /sellers/{id} - Update seller
- DELETE /sellers/{id} - Remove seller
- GET /sellers/audit-log - Get audit log
- GET /sellers/audit-log/{id}/sellers - Get sellers at log point
- POST /sellers/diff - Calculate diff between snapshots
- GET /sellers/export - Export as JSON/CSV/text
  </done>
</task>

<task type="auto">
  <name>Task 7: Add template endpoints to collection router</name>
  <files>apps/api/src/app/routers/collection.py</files>
  <action>
Add template CRUD and enhanced progress endpoints to existing collection router.

**Add these endpoints:**

```python
# ============ Templates ============

@router.get("/templates", response_model=RunTemplateListResponse)
async def list_templates(
    service: CollectionService = Depends(get_collection_service),
):
    """Get all run templates."""
    templates = await service.get_templates()
    return RunTemplateListResponse(templates=[RunTemplateResponse(**t) for t in templates])


@router.post("/templates", response_model=RunTemplateResponse, status_code=201)
async def create_template(
    data: RunTemplateCreate,
    service: CollectionService = Depends(get_collection_service),
):
    """Create a new run template."""
    try:
        template = await service.create_template(
            name=data.name,
            description=data.description,
            department_ids=data.department_ids,
            concurrency=data.concurrency,
            is_default=data.is_default,
        )
        return RunTemplateResponse(**template)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.patch("/templates/{template_id}", response_model=RunTemplateResponse)
async def update_template(
    template_id: str,
    data: RunTemplateUpdate,
    service: CollectionService = Depends(get_collection_service),
):
    """Update a run template."""
    try:
        updates = data.model_dump(exclude_unset=True)
        template = await service.update_template(template_id, updates)
        return RunTemplateResponse(**template)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.delete("/templates/{template_id}", status_code=204)
async def delete_template(
    template_id: str,
    service: CollectionService = Depends(get_collection_service),
):
    """Delete a run template."""
    try:
        await service.delete_template(template_id)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


# ============ Enhanced Progress ============

@router.get("/runs/{run_id}/progress", response_model=EnhancedProgress)
async def get_run_progress(
    run_id: str,
    service: CollectionService = Depends(get_collection_service),
):
    """Get detailed progress for a collection run."""
    try:
        progress = await service.get_enhanced_progress(run_id)
        return EnhancedProgress(**progress)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
```

Also add the new model imports at the top of the file.
  </action>
  <verify>
- Template endpoints: `grep "/templates" apps/api/src/app/routers/collection.py | wc -l` returns 4+
- Progress endpoint: `grep "progress" apps/api/src/app/routers/collection.py`
  </verify>
  <done>
Collection router extended with:
- GET /collection/templates - List templates
- POST /collection/templates - Create template
- PATCH /collection/templates/{id} - Update template
- DELETE /collection/templates/{id} - Delete template
- GET /collection/runs/{id}/progress - Get enhanced progress
  </done>
</task>

<task type="auto">
  <name>Task 8: Register sellers router in main.py</name>
  <files>apps/api/src/app/main.py</files>
  <action>
Import and register the sellers router.

**Add import:**
```python
from .routers.sellers import router as sellers_router
```

**Add router registration (after collection_router):**
```python
app.include_router(sellers_router)
```
  </action>
  <verify>
- Import added: `grep "from .routers.sellers import" apps/api/src/app/main.py`
- Router included: `grep "sellers_router" apps/api/src/app/main.py`
  </verify>
  <done>
Sellers router registered in main.py:
- Import added
- Router included with /sellers prefix
  </done>
</task>

</tasks>

<verification>
- [ ] Migration 038 creates seller_audit_log table
- [ ] Migration 039 creates run_templates table
- [ ] Migration 040 adds enhanced progress columns
- [ ] Pydantic models added for all new features
- [ ] CollectionService has seller CRUD methods
- [ ] CollectionService has audit log methods
- [ ] CollectionService has diff calculation
- [ ] CollectionService has template methods
- [ ] Sellers router created with all endpoints
- [ ] Collection router has template and progress endpoints
- [ ] Sellers router registered in main.py
</verification>

<success_criteria>
Backend supports new Collections UI:
- Direct seller manipulation (add/edit/remove via API)
- Full audit trail of all changes
- Diff calculation between any two snapshots
- Run templates can be saved and reused
- Enhanced progress shows departments/categories/products/sellers
</success_criteria>

<output>
After completion, create `.planning/phases/06-collection-infrastructure/06-03-SUMMARY.md`
</output>
