---
phase: 06-collection-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/api/src/app/services/collection.py
  - apps/api/src/app/routers/collection.py
  - apps/api/src/app/main.py
  - apps/api/src/app/background.py
  - apps/api/src/app/models.py
autonomous: true

must_haves:
  truths:
    - "Admin can create a collection run via API"
    - "Cost estimate calculated before run starts"
    - "Run blocked if estimated cost exceeds budget cap"
    - "Interrupted runs resume on server startup"
  artifacts:
    - path: "apps/api/src/app/services/collection.py"
      provides: "Collection orchestration logic"
      exports: ["CollectionService"]
    - path: "apps/api/src/app/routers/collection.py"
      provides: "Collection API endpoints"
      exports: ["router"]
  key_links:
    - from: "apps/api/src/app/routers/collection.py"
      to: "apps/api/src/app/services/collection.py"
      via: "import CollectionService"
      pattern: "from app.services.collection import"
    - from: "apps/api/src/app/main.py"
      to: "apps/api/src/app/routers/collection.py"
      via: "router include"
      pattern: "app.include_router\\(collection"
---

<objective>
Create CollectionService and API endpoints for collection run management with budget enforcement and checkpointing.

Purpose: Backend infrastructure for triggering, managing, and resuming collection runs
Output: Service class with cost estimation/budget enforcement, REST endpoints for CRUD, background task integration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-collection-infrastructure/06-CONTEXT.md
@.planning/phases/06-collection-infrastructure/06-RESEARCH.md
@.planning/phases/06-collection-infrastructure/06-01-SUMMARY.md
@apps/api/src/app/routers/automation.py (router pattern reference)
@apps/api/src/app/services/access_code.py (service pattern reference)
@apps/api/src/app/background.py (background task pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic models for collection</name>
  <files>apps/api/src/app/models.py</files>
  <action>
Add collection-related Pydantic models to the existing models.py file.

Add these models at the end of the file:

```python
# ============================================================
# Collection Models
# ============================================================

class CollectionRunStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class CostEstimate(BaseModel):
    """Cost estimate for a collection run."""
    total_cents: int
    breakdown: dict[str, int]  # category_id -> estimated_cents
    within_budget: bool
    budget_cap_cents: int
    warning_threshold_cents: int  # 80% of budget

class CollectionSettingsResponse(BaseModel):
    """Current collection settings."""
    budget_cap_cents: int
    soft_warning_percent: int
    max_concurrent_runs: int

class CollectionSettingsUpdate(BaseModel):
    """Update collection settings."""
    budget_cap_cents: int | None = None
    soft_warning_percent: int | None = None
    max_concurrent_runs: int | None = None

class CollectionRunCreate(BaseModel):
    """Create a new collection run."""
    name: str | None = None  # Auto-generated if blank
    category_ids: list[str]

class CollectionRunResponse(BaseModel):
    """Collection run details."""
    id: str
    name: str
    status: CollectionRunStatus
    estimated_cost_cents: int
    actual_cost_cents: int
    budget_cap_cents: int
    total_items: int
    processed_items: int
    failed_items: int
    category_ids: list[str]
    started_at: str | None
    completed_at: str | None
    paused_at: str | None
    created_by: str
    created_at: str

class CollectionRunListResponse(BaseModel):
    """List of collection runs."""
    runs: list[CollectionRunResponse]
    total: int

class EstimateRequest(BaseModel):
    """Request cost estimate."""
    category_ids: list[str]
```

Important: Add `from enum import Enum` if not already imported. Keep BaseModel import that already exists.
  </action>
  <verify>
- `grep "CollectionRunStatus" apps/api/src/app/models.py` returns match
- `grep "CostEstimate" apps/api/src/app/models.py` returns match
- No Python syntax errors: `cd apps/api && python -c "from app.models import CollectionRunStatus, CostEstimate, CollectionRunCreate"` exits 0
  </verify>
  <done>
Pydantic models added:
- CollectionRunStatus enum (pending/running/paused/completed/failed/cancelled)
- CostEstimate (total, breakdown, within_budget flags)
- CollectionSettingsResponse/Update
- CollectionRunCreate/Response/ListResponse
- EstimateRequest
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CollectionService</name>
  <files>apps/api/src/app/services/collection.py</files>
  <action>
Create new service file for collection orchestration.

```python
"""Collection service for managing seller collection runs.

This module handles:
- Cost estimation before runs
- Budget enforcement (soft warning + hard block)
- Run lifecycle (create, start, pause, cancel)
- Checkpointing for crash recovery
- Resume of interrupted runs on startup
"""

import logging
from datetime import datetime, timezone
from supabase import Client

logger = logging.getLogger(__name__)

# Cost constants (Oxylabs pricing)
# These are estimates - actual costs tracked per-item
COST_PER_AMAZON_PRODUCT_CENTS = 5  # ~$0.05 per product fetch
COST_PER_EBAY_SEARCH_CENTS = 5     # ~$0.05 per search
ESTIMATED_EBAY_SEARCHES_PER_PRODUCT = 1


class CollectionService:
    """Orchestrates collection runs with budget enforcement and checkpointing."""

    def __init__(self, supabase: Client):
        self.supabase = supabase

    async def get_settings(self, org_id: str) -> dict:
        """Get or create collection settings for an org."""
        result = (
            self.supabase.table("collection_settings")
            .select("*")
            .eq("org_id", org_id)
            .execute()
        )

        if result.data:
            return result.data[0]

        # Create default settings
        default = {
            "org_id": org_id,
            "budget_cap_cents": 2500,  # $25 default
            "soft_warning_percent": 80,
            "max_concurrent_runs": 3,
        }
        insert_result = (
            self.supabase.table("collection_settings")
            .insert(default)
            .execute()
        )
        return insert_result.data[0] if insert_result.data else default

    async def update_settings(
        self,
        org_id: str,
        budget_cap_cents: int | None = None,
        soft_warning_percent: int | None = None,
        max_concurrent_runs: int | None = None,
    ) -> dict:
        """Update collection settings."""
        settings = await self.get_settings(org_id)

        update_data = {"updated_at": datetime.now(timezone.utc).isoformat()}
        if budget_cap_cents is not None:
            update_data["budget_cap_cents"] = budget_cap_cents
        if soft_warning_percent is not None:
            update_data["soft_warning_percent"] = soft_warning_percent
        if max_concurrent_runs is not None:
            update_data["max_concurrent_runs"] = max_concurrent_runs

        result = (
            self.supabase.table("collection_settings")
            .update(update_data)
            .eq("org_id", org_id)
            .execute()
        )
        return result.data[0] if result.data else settings

    async def estimate_cost(
        self,
        org_id: str,
        category_ids: list[str],
    ) -> dict:
        """
        Calculate estimated API cost before starting a run.

        Returns cost estimate with per-category breakdown.
        Phase 6 uses placeholder product counts - Phase 7 will add real estimates.
        """
        settings = await self.get_settings(org_id)
        budget_cap = settings["budget_cap_cents"]
        warning_percent = settings["soft_warning_percent"]

        # Placeholder: estimate 50 products per category
        # Phase 7 will replace with actual category product counts
        PRODUCTS_PER_CATEGORY = 50

        breakdown = {}
        total_cents = 0

        for cat_id in category_ids:
            # Cost per category: Amazon fetch + eBay searches
            amazon_cost = PRODUCTS_PER_CATEGORY * COST_PER_AMAZON_PRODUCT_CENTS
            ebay_cost = PRODUCTS_PER_CATEGORY * ESTIMATED_EBAY_SEARCHES_PER_PRODUCT * COST_PER_EBAY_SEARCH_CENTS
            category_total = amazon_cost + ebay_cost

            breakdown[cat_id] = category_total
            total_cents += category_total

        warning_threshold = int(budget_cap * warning_percent / 100)

        return {
            "total_cents": total_cents,
            "breakdown": breakdown,
            "within_budget": total_cents <= budget_cap,
            "budget_cap_cents": budget_cap,
            "warning_threshold_cents": warning_threshold,
            "exceeds_warning": total_cents > warning_threshold,
        }

    async def create_run(
        self,
        org_id: str,
        user_id: str,
        category_ids: list[str],
        name: str | None = None,
    ) -> dict:
        """
        Create a new collection run in pending state.

        Validates budget before creating. Returns error if would exceed budget.
        """
        # Get cost estimate
        estimate = await self.estimate_cost(org_id, category_ids)

        if not estimate["within_budget"]:
            return {
                "error": "budget_exceeded",
                "message": f"Estimated cost ${estimate['total_cents']/100:.2f} exceeds budget cap ${estimate['budget_cap_cents']/100:.2f}",
                "estimate": estimate,
            }

        # Check concurrent run limit
        settings = await self.get_settings(org_id)
        active_runs = (
            self.supabase.table("collection_runs")
            .select("id", count="exact")
            .eq("org_id", org_id)
            .in_("status", ["pending", "running", "paused"])
            .execute()
        )

        if (active_runs.count or 0) >= settings["max_concurrent_runs"]:
            return {
                "error": "concurrent_limit",
                "message": f"Maximum {settings['max_concurrent_runs']} concurrent runs allowed",
            }

        # Generate name if not provided
        if not name:
            name = f"Collection {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M')}"

        # Create run
        now = datetime.now(timezone.utc).isoformat()
        run_data = {
            "org_id": org_id,
            "name": name,
            "status": "pending",
            "estimated_cost_cents": estimate["total_cents"],
            "actual_cost_cents": 0,
            "budget_cap_cents": estimate["budget_cap_cents"],
            "total_items": 0,
            "processed_items": 0,
            "failed_items": 0,
            "category_ids": category_ids,
            "created_by": user_id,
            "created_at": now,
            "updated_at": now,
        }

        result = self.supabase.table("collection_runs").insert(run_data).execute()

        if not result.data:
            return {"error": "insert_failed", "message": "Failed to create run"}

        run = result.data[0]
        logger.info(f"Created collection run {run['id']} for org {org_id}")

        return {"run": run, "estimate": estimate}

    async def get_run(self, run_id: str, org_id: str) -> dict | None:
        """Get a collection run by ID."""
        result = (
            self.supabase.table("collection_runs")
            .select("*")
            .eq("id", run_id)
            .eq("org_id", org_id)
            .execute()
        )
        return result.data[0] if result.data else None

    async def list_runs(
        self,
        org_id: str,
        limit: int = 20,
        offset: int = 0,
    ) -> tuple[list[dict], int]:
        """List collection runs for an org."""
        result = (
            self.supabase.table("collection_runs")
            .select("*", count="exact")
            .eq("org_id", org_id)
            .order("created_at", desc=True)
            .range(offset, offset + limit - 1)
            .execute()
        )
        return result.data or [], result.count or 0

    async def start_run(self, run_id: str, org_id: str) -> dict:
        """Start a pending run."""
        run = await self.get_run(run_id, org_id)
        if not run:
            return {"error": "not_found", "message": "Run not found"}

        if run["status"] != "pending":
            return {"error": "invalid_status", "message": f"Cannot start run in {run['status']} status"}

        now = datetime.now(timezone.utc).isoformat()
        self.supabase.table("collection_runs").update({
            "status": "running",
            "started_at": now,
            "updated_at": now,
        }).eq("id", run_id).execute()

        logger.info(f"Started collection run {run_id}")
        return {"ok": True, "status": "running"}

    async def pause_run(self, run_id: str, org_id: str) -> dict:
        """Pause a running collection."""
        run = await self.get_run(run_id, org_id)
        if not run:
            return {"error": "not_found", "message": "Run not found"}

        if run["status"] != "running":
            return {"error": "invalid_status", "message": f"Cannot pause run in {run['status']} status"}

        now = datetime.now(timezone.utc).isoformat()
        self.supabase.table("collection_runs").update({
            "status": "paused",
            "paused_at": now,
            "updated_at": now,
        }).eq("id", run_id).execute()

        logger.info(f"Paused collection run {run_id}")
        return {"ok": True, "status": "paused"}

    async def resume_run(self, run_id: str, org_id: str) -> dict:
        """Resume a paused collection."""
        run = await self.get_run(run_id, org_id)
        if not run:
            return {"error": "not_found", "message": "Run not found"}

        if run["status"] != "paused":
            return {"error": "invalid_status", "message": f"Cannot resume run in {run['status']} status"}

        now = datetime.now(timezone.utc).isoformat()
        self.supabase.table("collection_runs").update({
            "status": "running",
            "paused_at": None,
            "updated_at": now,
        }).eq("id", run_id).execute()

        logger.info(f"Resumed collection run {run_id}")
        return {"ok": True, "status": "running"}

    async def cancel_run(self, run_id: str, org_id: str) -> dict:
        """Cancel a collection run."""
        run = await self.get_run(run_id, org_id)
        if not run:
            return {"error": "not_found", "message": "Run not found"}

        if run["status"] in ("completed", "failed", "cancelled"):
            return {"error": "invalid_status", "message": f"Cannot cancel run in {run['status']} status"}

        now = datetime.now(timezone.utc).isoformat()
        self.supabase.table("collection_runs").update({
            "status": "cancelled",
            "completed_at": now,
            "updated_at": now,
        }).eq("id", run_id).execute()

        logger.info(f"Cancelled collection run {run_id}")
        return {"ok": True, "status": "cancelled"}

    async def checkpoint(
        self,
        run_id: str,
        checkpoint_data: dict,
        processed_items: int,
        failed_items: int,
        actual_cost_cents: int,
    ) -> None:
        """Save checkpoint for crash recovery."""
        now = datetime.now(timezone.utc).isoformat()
        self.supabase.table("collection_runs").update({
            "checkpoint": checkpoint_data,
            "processed_items": processed_items,
            "failed_items": failed_items,
            "actual_cost_cents": actual_cost_cents,
            "updated_at": now,
        }).eq("id", run_id).execute()

        logger.debug(f"Checkpointed run {run_id}: {processed_items} processed, {failed_items} failed")

    async def get_incomplete_runs(self) -> list[dict]:
        """Get runs that were interrupted (running/paused status)."""
        result = (
            self.supabase.table("collection_runs")
            .select("*")
            .in_("status", ["running", "paused"])
            .execute()
        )
        return result.data or []

    async def resume_incomplete_runs(self) -> int:
        """
        Called on server startup to find and flag interrupted runs.

        Returns count of runs found. Actual resume handled by collection_manager task.
        """
        runs = await self.get_incomplete_runs()

        if runs:
            logger.info(f"Found {len(runs)} interrupted collection run(s) to resume")
            for run in runs:
                logger.info(f"  - Run {run['id']}: {run['name']} (status: {run['status']}, checkpoint: {run.get('checkpoint') is not None})")

        return len(runs)
```
  </action>
  <verify>
- File exists: `test -f apps/api/src/app/services/collection.py && echo "exists"`
- No syntax errors: `cd apps/api && python -c "from app.services.collection import CollectionService"` exits 0
- Key methods present: `grep -c "async def" apps/api/src/app/services/collection.py` should be >= 12
  </verify>
  <done>
CollectionService created with:
- get_settings / update_settings: Budget configuration
- estimate_cost: Pre-run cost calculation with per-category breakdown
- create_run: Creates run with budget validation (blocks if exceeds cap)
- start_run / pause_run / resume_run / cancel_run: State transitions
- checkpoint: Save progress for crash recovery
- get_incomplete_runs / resume_incomplete_runs: Startup recovery
  </done>
</task>

<task type="auto">
  <name>Task 3: Create collection router with endpoints</name>
  <files>apps/api/src/app/routers/collection.py</files>
  <action>
Create new router file for collection API endpoints.

```python
"""Collection endpoints for seller collection runs.

Admin endpoints for:
- Settings configuration
- Cost estimation
- Run CRUD (create, list, pause, cancel)
- Progress tracking (placeholder for WebSocket in later phase)
"""

import logging
from fastapi import APIRouter, Depends, HTTPException

from app.auth import require_permission_key
from app.database import get_supabase
from app.models import (
    CollectionRunCreate,
    CollectionRunListResponse,
    CollectionRunResponse,
    CollectionSettingsResponse,
    CollectionSettingsUpdate,
    CostEstimate,
    EstimateRequest,
)
from app.services.collection import CollectionService

router = APIRouter(prefix="/collection", tags=["collection"])
logger = logging.getLogger(__name__)


def get_collection_service() -> CollectionService:
    """Dependency to get CollectionService instance."""
    supabase = get_supabase()
    return CollectionService(supabase)


# ============================================================
# Settings Endpoints
# ============================================================


@router.get("/settings", response_model=CollectionSettingsResponse)
async def get_settings(
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Get collection settings for the organization.

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    settings = await service.get_settings(org_id)

    return CollectionSettingsResponse(
        budget_cap_cents=settings["budget_cap_cents"],
        soft_warning_percent=settings["soft_warning_percent"],
        max_concurrent_runs=settings["max_concurrent_runs"],
    )


@router.patch("/settings", response_model=CollectionSettingsResponse)
async def update_settings(
    body: CollectionSettingsUpdate,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Update collection settings.

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    settings = await service.update_settings(
        org_id,
        budget_cap_cents=body.budget_cap_cents,
        soft_warning_percent=body.soft_warning_percent,
        max_concurrent_runs=body.max_concurrent_runs,
    )

    return CollectionSettingsResponse(
        budget_cap_cents=settings["budget_cap_cents"],
        soft_warning_percent=settings["soft_warning_percent"],
        max_concurrent_runs=settings["max_concurrent_runs"],
    )


# ============================================================
# Estimation Endpoint
# ============================================================


@router.post("/estimate", response_model=CostEstimate)
async def estimate_cost(
    body: EstimateRequest,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Get cost estimate for a collection run.

    Returns estimated cost with per-category breakdown and budget status.
    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]

    if not body.category_ids:
        raise HTTPException(status_code=400, detail="At least one category required")

    estimate = await service.estimate_cost(org_id, body.category_ids)

    return CostEstimate(
        total_cents=estimate["total_cents"],
        breakdown=estimate["breakdown"],
        within_budget=estimate["within_budget"],
        budget_cap_cents=estimate["budget_cap_cents"],
        warning_threshold_cents=estimate["warning_threshold_cents"],
    )


# ============================================================
# Run Endpoints
# ============================================================


@router.post("/runs", response_model=CollectionRunResponse)
async def create_run(
    body: CollectionRunCreate,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Create a new collection run.

    Validates budget before creating. Returns 400 if would exceed budget.
    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    user_id = user["user_id"]

    if not body.category_ids:
        raise HTTPException(status_code=400, detail="At least one category required")

    result = await service.create_run(
        org_id=org_id,
        user_id=user_id,
        category_ids=body.category_ids,
        name=body.name,
    )

    if "error" in result:
        if result["error"] == "budget_exceeded":
            raise HTTPException(status_code=400, detail=result["message"])
        elif result["error"] == "concurrent_limit":
            raise HTTPException(status_code=429, detail=result["message"])
        else:
            raise HTTPException(status_code=500, detail=result["message"])

    run = result["run"]
    return CollectionRunResponse(
        id=run["id"],
        name=run["name"],
        status=run["status"],
        estimated_cost_cents=run["estimated_cost_cents"],
        actual_cost_cents=run["actual_cost_cents"],
        budget_cap_cents=run["budget_cap_cents"],
        total_items=run["total_items"],
        processed_items=run["processed_items"],
        failed_items=run["failed_items"],
        category_ids=run["category_ids"],
        started_at=run.get("started_at"),
        completed_at=run.get("completed_at"),
        paused_at=run.get("paused_at"),
        created_by=run["created_by"],
        created_at=run["created_at"],
    )


@router.get("/runs", response_model=CollectionRunListResponse)
async def list_runs(
    limit: int = 20,
    offset: int = 0,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    List collection runs for the organization.

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    runs, total = await service.list_runs(org_id, limit=limit, offset=offset)

    return CollectionRunListResponse(
        runs=[
            CollectionRunResponse(
                id=r["id"],
                name=r["name"],
                status=r["status"],
                estimated_cost_cents=r["estimated_cost_cents"],
                actual_cost_cents=r["actual_cost_cents"],
                budget_cap_cents=r["budget_cap_cents"],
                total_items=r["total_items"],
                processed_items=r["processed_items"],
                failed_items=r["failed_items"],
                category_ids=r["category_ids"],
                started_at=r.get("started_at"),
                completed_at=r.get("completed_at"),
                paused_at=r.get("paused_at"),
                created_by=r["created_by"],
                created_at=r["created_at"],
            )
            for r in runs
        ],
        total=total,
    )


@router.get("/runs/{run_id}", response_model=CollectionRunResponse)
async def get_run(
    run_id: str,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Get a specific collection run.

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    run = await service.get_run(run_id, org_id)

    if not run:
        raise HTTPException(status_code=404, detail="Run not found")

    return CollectionRunResponse(
        id=run["id"],
        name=run["name"],
        status=run["status"],
        estimated_cost_cents=run["estimated_cost_cents"],
        actual_cost_cents=run["actual_cost_cents"],
        budget_cap_cents=run["budget_cap_cents"],
        total_items=run["total_items"],
        processed_items=run["processed_items"],
        failed_items=run["failed_items"],
        category_ids=run["category_ids"],
        started_at=run.get("started_at"),
        completed_at=run.get("completed_at"),
        paused_at=run.get("paused_at"),
        created_by=run["created_by"],
        created_at=run["created_at"],
    )


@router.post("/runs/{run_id}/start")
async def start_run(
    run_id: str,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Start a pending collection run.

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    result = await service.start_run(run_id, org_id)

    if "error" in result:
        if result["error"] == "not_found":
            raise HTTPException(status_code=404, detail=result["message"])
        else:
            raise HTTPException(status_code=400, detail=result["message"])

    return result


@router.post("/runs/{run_id}/pause")
async def pause_run(
    run_id: str,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Pause a running collection.

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    result = await service.pause_run(run_id, org_id)

    if "error" in result:
        if result["error"] == "not_found":
            raise HTTPException(status_code=404, detail=result["message"])
        else:
            raise HTTPException(status_code=400, detail=result["message"])

    return result


@router.post("/runs/{run_id}/resume")
async def resume_run(
    run_id: str,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Resume a paused collection.

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    result = await service.resume_run(run_id, org_id)

    if "error" in result:
        if result["error"] == "not_found":
            raise HTTPException(status_code=404, detail=result["message"])
        else:
            raise HTTPException(status_code=400, detail=result["message"])

    return result


@router.post("/runs/{run_id}/cancel")
async def cancel_run(
    run_id: str,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Cancel a collection run.

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    result = await service.cancel_run(run_id, org_id)

    if "error" in result:
        if result["error"] == "not_found":
            raise HTTPException(status_code=404, detail=result["message"])
        else:
            raise HTTPException(status_code=400, detail=result["message"])

    return result
```
  </action>
  <verify>
- File exists: `test -f apps/api/src/app/routers/collection.py && echo "exists"`
- No syntax errors: `cd apps/api && python -c "from app.routers.collection import router"` exits 0
- Endpoints present: `grep -c "@router" apps/api/src/app/routers/collection.py` should be >= 9
  </verify>
  <done>
Collection router created with endpoints:
- GET /settings: Get budget settings
- PATCH /settings: Update budget settings
- POST /estimate: Get cost estimate
- POST /runs: Create run (with budget validation)
- GET /runs: List runs
- GET /runs/{id}: Get run details
- POST /runs/{id}/start: Start pending run
- POST /runs/{id}/pause: Pause running run
- POST /runs/{id}/resume: Resume paused run
- POST /runs/{id}/cancel: Cancel run
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate router and background task</name>
  <files>apps/api/src/app/main.py, apps/api/src/app/background.py</files>
  <action>
**1. Update main.py to include collection router:**

Add import and include_router after other routers:

```python
from app.routers import collection as collection_router

# In the router includes section:
app.include_router(collection_router.router)
```

**2. Update background.py to resume interrupted runs:**

Add collection manager that runs on startup:

```python
from app.services.collection import CollectionService

# Add after existing cleanup_worker function:

async def collection_startup_recovery():
    """
    One-time task on startup to check for interrupted collection runs.

    Logs any runs that were in running/paused state when server stopped.
    Full resume logic will be implemented in Phase 7 when actual collection runs.
    """
    try:
        supabase = get_supabase()
        service = CollectionService(supabase)
        count = await service.resume_incomplete_runs()
        if count > 0:
            logger.info(f"Collection startup recovery: {count} run(s) need attention")
    except Exception as e:
        logger.error(f"Collection startup recovery failed: {e}")
```

**3. Update main.py lifespan to call collection_startup_recovery:**

In the lifespan function, add after cleanup_task creation:

```python
from app.background import cleanup_worker, collection_startup_recovery

@asynccontextmanager
async def lifespan(app: FastAPI):
    global _cleanup_task
    _cleanup_task = asyncio.create_task(cleanup_worker())

    # Check for interrupted collection runs
    await collection_startup_recovery()

    yield

    if _cleanup_task:
        _cleanup_task.cancel()
```
  </action>
  <verify>
- Router included: `grep "collection_router" apps/api/src/app/main.py` returns match
- Background function exists: `grep "collection_startup_recovery" apps/api/src/app/background.py` returns match
- Startup recovery called: `grep "collection_startup_recovery" apps/api/src/app/main.py` returns match
- API starts without error: `cd apps/api && timeout 5 python -c "from app.main import app; print('OK')"` prints OK
  </verify>
  <done>
Integration complete:
- Collection router included in main.py
- collection_startup_recovery function added to background.py
- Lifespan calls recovery on startup
- API loads without import errors
  </done>
</task>

</tasks>

<verification>
- [ ] Pydantic models added to models.py
- [ ] CollectionService created with cost estimation and budget enforcement
- [ ] Collection router with all endpoints
- [ ] Router included in main.py
- [ ] Startup recovery integrated in background.py
- [ ] API imports successfully
</verification>

<success_criteria>
Backend collection API ready:
- Cost estimation endpoint returns per-category breakdown
- Create run validates budget and blocks if exceeded
- Run state transitions work (start/pause/resume/cancel)
- Interrupted runs detected on server startup
- All endpoints protected by admin.automation permission
</success_criteria>

<output>
After completion, create `.planning/phases/06-collection-infrastructure/06-02-SUMMARY.md`
</output>
