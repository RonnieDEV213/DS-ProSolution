---
phase: 29-app-wide-persistent-cache
plan: 02
type: execute
wave: 2
depends_on: [29-01]
files_modified:
  - apps/web/src/components/admin/users-table.tsx
  - apps/web/src/components/admin/department-roles-table.tsx
  - apps/web/src/components/admin/invites-list.tsx
  - apps/web/src/app/admin/page.tsx
autonomous: true

must_haves:
  truths:
    - "/admin/users page uses useCachedQuery with pagination-aware cache key"
    - "/admin/department-roles page uses useCachedQuery with org-scoped cache key"
    - "/admin/invites page uses useCachedQuery with pagination-aware cache key"
    - "/admin dashboard counts use useCachedQuery with singleton cache key"
    - "All 4 pages show skeleton on first load and cached data instantly on revisit"
    - "Stale times are appropriate: 30s for users/invites (moderate churn), 60s for roles/dashboard (low churn)"
  artifacts:
    - path: "apps/web/src/components/admin/users-table.tsx"
      provides: "Persistent cache wiring for admin users page"
      contains: "useCachedQuery"
    - path: "apps/web/src/components/admin/department-roles-table.tsx"
      provides: "Persistent cache wiring for department roles page"
      contains: "useCachedQuery"
    - path: "apps/web/src/components/admin/invites-list.tsx"
      provides: "Persistent cache wiring for invites page"
      contains: "useCachedQuery"
    - path: "apps/web/src/app/admin/page.tsx"
      provides: "Persistent cache wiring for admin dashboard counts"
      contains: "useCachedQuery"
  key_links:
    - from: "apps/web/src/components/admin/users-table.tsx"
      to: "apps/web/src/hooks/use-cached-query.ts"
      via: "useCachedQuery import and usage"
      pattern: "useCachedQuery"
---

<objective>
Wire 4 legacy admin pages to use useCachedQuery for persistent IndexedDB caching: /admin/users, /admin/department-roles, /admin/invites, and /admin dashboard counts.

Purpose: These pages currently wait for network responses on every visit. After this plan, they load instantly from IndexedDB cache on revisit, with background refresh for freshness. This eliminates the perceived slowness gap between V3 pages (instant) and legacy pages (network-dependent).

Output: 4 admin pages using persistent cache with appropriate stale times.
</objective>

<execution_context>
@C:\Users\User\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\User\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/29-app-wide-persistent-cache/29-RESEARCH.md
@apps/web/src/hooks/use-cached-query.ts
@apps/web/src/lib/query-keys.ts
@apps/web/src/components/admin/users-table.tsx
@apps/web/src/components/admin/department-roles-table.tsx
@apps/web/src/components/admin/invites-list.tsx
@apps/web/src/app/admin/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire /admin/users to useCachedQuery</name>
  <files>apps/web/src/components/admin/users-table.tsx</files>
  <action>
Replace existing useQuery call with useCachedQuery:
- Cache key: `admin:users:${debouncedSearch}:${page}` (pagination + search aware)
- Stale time: 30 seconds (moderate churn dataset)
- Show TableSkeleton when loading and no cached data
- Use existing API endpoint unchanged
  </action>
  <verify>
1. Grep for `useCachedQuery` in users-table.tsx
2. Cache key includes search and page parameters
3. TableSkeleton shown when loading with no data
  </verify>
  <done>
- /admin/users loads from IndexedDB cache on revisit
- Pagination-aware caching (each page/search combo cached separately)
- 30s stale time with background refresh
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire /admin/department-roles to useCachedQuery</name>
  <files>apps/web/src/components/admin/department-roles-table.tsx</files>
  <action>
Replace existing useQuery call with useCachedQuery:
- Cache key: `admin:department-roles:${orgId}` (org-scoped)
- Stale time: 60 seconds (low churn dataset â€” roles rarely change)
- Show skeleton when loading and no cached data
  </action>
  <verify>
1. Grep for `useCachedQuery` in department-roles-table.tsx
2. Cache key is org-scoped
3. Stale time is 60s
  </verify>
  <done>
- /admin/department-roles loads from IndexedDB cache on revisit
- Org-scoped caching
- 60s stale time reflecting low churn
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire /admin/invites to useCachedQuery</name>
  <files>apps/web/src/components/admin/invites-list.tsx</files>
  <action>
Replace existing useQuery call with useCachedQuery:
- Cache key: `admin:invites:${page}` (pagination-aware)
- Stale time: 30 seconds
- Show TableSkeleton when loading with no cached data
  </action>
  <verify>
1. Grep for `useCachedQuery` in invites-list.tsx
2. Cache key includes page parameter
3. TableSkeleton shown when loading
  </verify>
  <done>
- /admin/invites loads from IndexedDB cache on revisit
- Pagination-aware caching
- 30s stale time
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire /admin dashboard counts to useCachedQuery</name>
  <files>apps/web/src/app/admin/page.tsx</files>
  <action>
Replace existing useQuery call for dashboard counts with useCachedQuery:
- Cache key: `admin:dashboard-counts` (singleton)
- Stale time: 60 seconds (aggregate counts change infrequently)
- Show DashboardSkeleton when loading with no cached data
  </action>
  <verify>
1. Grep for `useCachedQuery` in admin/page.tsx
2. Cache key is `admin:dashboard-counts`
3. DashboardSkeleton shown when loading
  </verify>
  <done>
- /admin dashboard counts load from IndexedDB cache on revisit
- Singleton cache key
- 60s stale time
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Users page:** useCachedQuery with pagination + search-aware cache key
2. **Roles page:** useCachedQuery with org-scoped cache key
3. **Invites page:** useCachedQuery with pagination-aware cache key
4. **Dashboard:** useCachedQuery with singleton cache key
5. **Skeleton loading:** All pages show skeleton on first load, cached data on revisit
6. **Build:** `npm run build` succeeds
</verification>

<success_criteria>
- All 4 admin pages use useCachedQuery
- Each page has appropriate cache key scoping and stale time
- Skeleton loading states work correctly
- Build succeeds with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/29-app-wide-persistent-cache/29-02-SUMMARY.md`
</output>
