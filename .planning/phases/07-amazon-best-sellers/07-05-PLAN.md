---
phase: 07-amazon-best-sellers
plan: 05
type: execute
wave: 3
depends_on: ["07-02", "07-03", "07-04"]
files_modified:
  - apps/api/src/app/services/collection.py
  - apps/api/src/app/routers/collection.py
  - apps/web/src/components/admin/collection/run-config-modal.tsx
autonomous: true

must_haves:
  truths:
    - "Collection run fetches products from Oxylabs when started"
    - "Progress updates show products fetched per category"
    - "API cost is tracked during collection run"
    - "Rate limiting is handled with retry and throttle status"
    - "Multiple consecutive failures pause collection"
    - "RunConfigModal uses AmazonCategorySelector instead of placeholder"
  artifacts:
    - path: "apps/api/src/app/services/collection.py"
      provides: "run_amazon_collection method"
      contains: "run_amazon_collection"
    - path: "apps/web/src/components/admin/collection/run-config-modal.tsx"
      provides: "Updated modal with real category selector"
      contains: "AmazonCategorySelector"
  key_links:
    - from: "collection.py run_amazon_collection"
      to: "OxylabsAmazonScraper.fetch_bestsellers"
      via: "async call in loop"
      pattern: "scraper\\.fetch_bestsellers"
    - from: "run-config-modal.tsx"
      to: "amazon-category-selector.tsx"
      via: "component import"
      pattern: "AmazonCategorySelector"
---

<objective>
Integrate Oxylabs scraper with collection service and update RunConfigModal to use real Amazon category selector.

Purpose: Connect the scraper to the collection pipeline so that starting a run actually fetches products. Update the UI to use the new category selector instead of placeholders.

Output: Working end-to-end flow from UI category selection to Oxylabs API calls
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-amazon-best-sellers/07-CONTEXT.md
@apps/api/src/app/services/collection.py
@apps/api/src/app/routers/collection.py
@apps/web/src/components/admin/collection/run-config-modal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Amazon collection execution to CollectionService</name>
  <files>apps/api/src/app/services/collection.py</files>
  <action>
Add the `run_amazon_collection` method to CollectionService that orchestrates fetching products from Oxylabs.

Add these imports at the top:
```python
import asyncio
from app.services.scrapers import AmazonScraperService, OxylabsAmazonScraper, COST_PER_BESTSELLERS_PAGE_CENTS
```

Update the cost constant to use real value:
```python
# Update existing constant to match Oxylabs pricing
COST_PER_AMAZON_PRODUCT_CENTS = 1  # ~$0.01 per product (was 5)
```

Add this method to the CollectionService class:

```python
async def run_amazon_collection(
    self,
    run_id: str,
    org_id: str,
    category_ids: list[str],
) -> dict:
    """
    Execute Amazon best sellers collection for selected categories.

    Fetches products from each category via Oxylabs API, tracks cost,
    handles rate limiting and errors per CONTEXT.md requirements:
    - Retry failed category 3x, then skip
    - Pause on multiple consecutive failures
    - Track cost per request

    Args:
        run_id: Collection run ID
        org_id: Organization ID
        category_ids: List of category IDs to fetch (from amazon_categories.json)

    Returns:
        dict with status, products_fetched, actual_cost_cents, errors
    """
    import json

    # Load category data to get node IDs
    categories_path = Path(__file__).parent.parent / "data" / "amazon_categories.json"
    with open(categories_path) as f:
        cat_data = json.load(f)

    # Build category ID -> node_id lookup
    node_lookup = {}
    for dept in cat_data["departments"]:
        for cat in dept.get("categories", []):
            node_lookup[cat["id"]] = cat["node_id"]

    # Initialize scraper
    try:
        scraper = OxylabsAmazonScraper()
    except ValueError as e:
        logger.error(f"Scraper initialization failed: {e}")
        return {
            "status": "failed",
            "error": "Oxylabs credentials not configured",
            "products_fetched": 0,
            "actual_cost_cents": 0,
        }

    # Track progress
    products_fetched = 0
    actual_cost_cents = 0
    consecutive_failures = 0
    MAX_CONSECUTIVE_FAILURES = 5
    errors: list[dict] = []

    # Process each category
    for cat_id in category_ids:
        node_id = node_lookup.get(cat_id)
        if not node_id:
            logger.warning(f"Unknown category ID: {cat_id}")
            errors.append({"category": cat_id, "error": "unknown_category"})
            continue

        # Retry logic (3 attempts per category)
        for attempt in range(3):
            result = await scraper.fetch_bestsellers(node_id)

            # Handle rate limiting
            if result.error == "rate_limited":
                logger.info(f"Rate limited, waiting 5s (attempt {attempt + 1}/3)")
                # Update run with throttle status
                self.supabase.table("collection_runs").update({
                    "checkpoint": {
                        "status": "rate_limited",
                        "waiting_seconds": 5,
                        "current_category": cat_id,
                    },
                    "updated_at": datetime.now(timezone.utc).isoformat(),
                }).eq("id", run_id).execute()

                await asyncio.sleep(5)
                continue

            # Handle other errors
            if result.error:
                consecutive_failures += 1
                logger.warning(f"Error fetching {cat_id}: {result.error} (consecutive: {consecutive_failures})")

                if consecutive_failures >= MAX_CONSECUTIVE_FAILURES:
                    # Pause collection and notify
                    logger.error(f"Multiple consecutive failures, pausing run {run_id}")
                    await self.pause_run(run_id, org_id)

                    self.supabase.table("collection_runs").update({
                        "checkpoint": {
                            "status": "paused_failures",
                            "consecutive_failures": consecutive_failures,
                            "last_category": cat_id,
                        },
                        "updated_at": datetime.now(timezone.utc).isoformat(),
                    }).eq("id", run_id).execute()

                    return {
                        "status": "paused",
                        "error": "Multiple consecutive failures",
                        "products_fetched": products_fetched,
                        "actual_cost_cents": actual_cost_cents,
                        "errors": errors,
                    }

                errors.append({"category": cat_id, "error": result.error})
                break  # Move to next category after max retries

            # Success - process products
            consecutive_failures = 0
            actual_cost_cents += result.cost_cents
            products_fetched += len(result.products)

            # Save products as collection items
            for product in result.products:
                item_data = {
                    "run_id": run_id,
                    "item_type": "amazon_product",
                    "external_id": product.asin,
                    "data": {
                        "title": product.title,
                        "price": product.price,
                        "currency": product.currency,
                        "rating": product.rating,
                        "url": product.url,
                        "position": product.position,
                        "category_id": cat_id,
                    },
                    "status": "pending",  # Will be processed by eBay search in Phase 8
                }
                self.supabase.table("collection_items").insert(item_data).execute()

            # Update progress checkpoint
            await self.checkpoint(
                run_id=run_id,
                checkpoint_data={
                    "current_category": cat_id,
                    "categories_completed": category_ids.index(cat_id) + 1,
                    "total_categories": len(category_ids),
                },
                processed_items=products_fetched,
                failed_items=len(errors),
                actual_cost_cents=actual_cost_cents,
            )

            logger.info(f"Fetched {len(result.products)} products from {cat_id}")
            break  # Success, move to next category

    # Mark run as completed
    now = datetime.now(timezone.utc).isoformat()
    self.supabase.table("collection_runs").update({
        "status": "completed",
        "completed_at": now,
        "total_items": products_fetched,
        "processed_items": products_fetched,
        "actual_cost_cents": actual_cost_cents,
        "updated_at": now,
    }).eq("id", run_id).execute()

    logger.info(f"Collection run {run_id} completed: {products_fetched} products, ${actual_cost_cents/100:.2f}")

    return {
        "status": "completed",
        "products_fetched": products_fetched,
        "actual_cost_cents": actual_cost_cents,
        "errors": errors if errors else None,
    }
```

Also add `from pathlib import Path` to imports.
  </action>
  <verify>Python syntax valid: `python -m py_compile apps/api/src/app/services/collection.py`</verify>
  <done>CollectionService has run_amazon_collection method with retry, rate limit handling, and progress tracking</done>
</task>

<task type="auto">
  <name>Task 2: Add API endpoint to trigger Amazon collection</name>
  <files>apps/api/src/app/routers/collection.py</files>
  <action>
Add endpoint to start Amazon collection execution as a background task.

Add import at top:
```python
from fastapi import BackgroundTasks
```

Add this endpoint after the existing `/runs/{run_id}/start` endpoint:

```python
@router.post("/runs/{run_id}/execute")
async def execute_run(
    run_id: str,
    background_tasks: BackgroundTasks,
    user: dict = Depends(require_permission_key("admin.automation")),
    service: CollectionService = Depends(get_collection_service),
):
    """
    Execute a collection run (start Amazon product fetching).

    This starts the actual scraping process in the background.
    The run must be in 'running' status (call /start first).

    Requires admin.automation permission.
    """
    org_id = user["membership"]["org_id"]
    run = await service.get_run(run_id, org_id)

    if not run:
        raise HTTPException(status_code=404, detail="Run not found")

    if run["status"] != "running":
        raise HTTPException(
            status_code=400,
            detail=f"Run must be in 'running' status to execute (current: {run['status']})"
        )

    # Start collection in background
    async def run_collection():
        await service.run_amazon_collection(
            run_id=run_id,
            org_id=org_id,
            category_ids=run["category_ids"],
        )

    background_tasks.add_task(run_collection)

    return {"ok": True, "message": "Collection started", "run_id": run_id}
```

This separates "start" (mark as running) from "execute" (actually run scraping) to allow the UI to show the run immediately while scraping happens in background.
  </action>
  <verify>Python syntax valid: `python -m py_compile apps/api/src/app/routers/collection.py`</verify>
  <done>POST /runs/{run_id}/execute endpoint triggers Amazon collection in background</done>
</task>

<task type="auto">
  <name>Task 3: Update RunConfigModal to use AmazonCategorySelector</name>
  <files>apps/web/src/components/admin/collection/run-config-modal.tsx</files>
  <action>
Replace the placeholder department selection with the real AmazonCategorySelector component.

Key changes:
1. Remove PLACEHOLDER_DEPARTMENTS constant
2. Import and use AmazonCategorySelector
3. Rename `departments` state to `selectedCategoryIds`
4. Update startRun to call /execute after /start
5. Keep template loading and cost estimation

Replace the entire file content with:

```tsx
"use client";

import { useState, useEffect } from "react";
import { createClient } from "@/lib/supabase/client";
import { toast } from "sonner";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import { Label } from "@/components/ui/label";
import { Loader2 } from "lucide-react";
import { AmazonCategorySelector } from "./amazon-category-selector";

const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL || "http://localhost:8000";

interface CostEstimate {
  total_cents: number;
  within_budget: boolean;
  budget_cap_cents: number;
}

interface RunConfigModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onRunStarted: () => void;
}

export function RunConfigModal({
  open,
  onOpenChange,
  onRunStarted,
}: RunConfigModalProps) {
  const [selectedCategoryIds, setSelectedCategoryIds] = useState<string[]>([]);
  const [concurrency, setConcurrency] = useState(3);
  const [estimate, setEstimate] = useState<CostEstimate | null>(null);
  const [loading, setLoading] = useState(false);
  const [estimating, setEstimating] = useState(false);

  const supabase = createClient();

  // Fetch cost estimate when categories change
  useEffect(() => {
    if (!open || selectedCategoryIds.length === 0) {
      setEstimate(null);
      return;
    }

    const fetchEstimate = async () => {
      setEstimating(true);
      try {
        const { data: { session } } = await supabase.auth.getSession();
        if (!session) return;

        const response = await fetch(`${API_BASE}/collection/estimate`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${session.access_token}`,
          },
          body: JSON.stringify({ category_ids: selectedCategoryIds }),
        });

        if (response.ok) {
          const data = await response.json();
          setEstimate(data);
        }
      } catch (e) {
        console.error("Failed to get estimate:", e);
      } finally {
        setEstimating(false);
      }
    };

    const timer = setTimeout(fetchEstimate, 300);
    return () => clearTimeout(timer);
  }, [open, selectedCategoryIds, supabase.auth]);

  // Start collection run
  const startRun = async () => {
    if (selectedCategoryIds.length === 0) {
      toast.error("Select at least one category");
      return;
    }

    if (estimate && !estimate.within_budget) {
      toast.error("Estimated cost exceeds budget");
      return;
    }

    setLoading(true);
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        toast.error("Not authenticated");
        return;
      }

      const headers = {
        "Content-Type": "application/json",
        Authorization: `Bearer ${session.access_token}`,
      };

      // 1. Create run
      const createResponse = await fetch(`${API_BASE}/collection/runs`, {
        method: "POST",
        headers,
        body: JSON.stringify({
          category_ids: selectedCategoryIds,
        }),
      });

      if (!createResponse.ok) {
        const error = await createResponse.json();
        throw new Error(error.detail || "Failed to create run");
      }

      const run = await createResponse.json();

      // 2. Start run (mark as running)
      const startResponse = await fetch(
        `${API_BASE}/collection/runs/${run.id}/start`,
        { method: "POST", headers }
      );

      if (!startResponse.ok) {
        throw new Error("Failed to start run");
      }

      // 3. Execute run (trigger background scraping)
      const executeResponse = await fetch(
        `${API_BASE}/collection/runs/${run.id}/execute`,
        { method: "POST", headers }
      );

      if (!executeResponse.ok) {
        throw new Error("Failed to execute run");
      }

      toast.success("Collection started");
      onRunStarted();
      onOpenChange(false);

      // Reset state
      setSelectedCategoryIds([]);
    } catch (err) {
      toast.error(err instanceof Error ? err.message : "Failed to start run");
    } finally {
      setLoading(false);
    }
  };

  const formatCost = (cents: number) => `$${(cents / 100).toFixed(2)}`;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="bg-gray-900 border-gray-800 sm:max-w-[600px] max-h-[90vh] overflow-hidden flex flex-col">
        <DialogHeader>
          <DialogTitle className="text-white">Start Collection Run</DialogTitle>
          <DialogDescription className="text-gray-400">
            Select Amazon categories to search for potential dropshippers.
          </DialogDescription>
        </DialogHeader>

        <div className="flex-1 overflow-y-auto space-y-4 py-4">
          {/* Category selector */}
          <AmazonCategorySelector
            selectedCategoryIds={selectedCategoryIds}
            onSelectionChange={setSelectedCategoryIds}
          />

          {/* Concurrency slider */}
          <div className="space-y-2 pt-4 border-t border-gray-800">
            <div className="flex justify-between">
              <Label className="text-gray-300">Concurrency</Label>
              <span className="text-sm text-gray-400">{concurrency} workers</span>
            </div>
            <Slider
              value={[concurrency]}
              onValueChange={([v]) => setConcurrency(v)}
              min={1}
              max={10}
              step={1}
              className="w-full"
            />
          </div>

          {/* Cost estimate */}
          {selectedCategoryIds.length > 0 && (
            <div
              className={`p-3 rounded border ${
                estimate && !estimate.within_budget
                  ? "bg-red-900/20 border-red-500/50"
                  : "bg-gray-800 border-gray-700"
              }`}
            >
              <div className="flex justify-between text-sm">
                <span className="text-gray-400">Estimated cost:</span>
                {estimating ? (
                  <Loader2 className="h-4 w-4 animate-spin text-gray-400" />
                ) : (
                  <span
                    className={
                      estimate && !estimate.within_budget
                        ? "text-red-400"
                        : "text-green-400"
                    }
                  >
                    {estimate ? formatCost(estimate.total_cents) : "-"}
                  </span>
                )}
              </div>
              {estimate && (
                <div className="flex justify-between text-sm text-gray-500 mt-1">
                  <span>Budget:</span>
                  <span>{formatCost(estimate.budget_cap_cents)}</span>
                </div>
              )}
              {estimate && !estimate.within_budget && (
                <div className="text-red-400 text-sm mt-2">
                  Exceeds budget - reduce categories or increase budget
                </div>
              )}
            </div>
          )}
        </div>

        <DialogFooter className="border-t border-gray-800 pt-4">
          <Button
            variant="outline"
            onClick={() => onOpenChange(false)}
            className="border-gray-700"
          >
            Cancel
          </Button>
          <Button
            onClick={startRun}
            disabled={
              loading ||
              selectedCategoryIds.length === 0 ||
              estimating ||
              (estimate !== null && !estimate.within_budget)
            }
            className="bg-blue-600 hover:bg-blue-700"
          >
            {loading ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                Starting...
              </>
            ) : (
              "Start Collection"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/web && npx tsc --noEmit src/components/admin/collection/run-config-modal.tsx 2>&1 | head -20`</verify>
  <done>RunConfigModal uses AmazonCategorySelector and calls create -> start -> execute flow</done>
</task>

</tasks>

<verification>
1. CollectionService.run_amazon_collection exists and handles retry/rate limiting
2. POST /runs/{run_id}/execute endpoint exists
3. RunConfigModal imports and uses AmazonCategorySelector
4. Starting a run creates items in collection_items table
5. Cost is tracked via actual_cost_cents
6. Multiple consecutive failures pause the run
7. All files committed to git
</verification>

<success_criteria>
- [ ] run_amazon_collection method fetches products via Oxylabs
- [ ] Rate limiting handled with 5-second wait and retry
- [ ] 5+ consecutive failures pause collection
- [ ] Products saved to collection_items table
- [ ] POST /execute endpoint triggers background collection
- [ ] RunConfigModal shows AmazonCategorySelector (not placeholders)
- [ ] Full flow: select categories -> estimate cost -> start -> execute
</success_criteria>

<output>
After completion, create `.planning/phases/07-amazon-best-sellers/07-05-SUMMARY.md`
</output>
