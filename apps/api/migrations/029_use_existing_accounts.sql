-- ============================================================
-- Migration 029: Use Existing Accounts for Automation
-- ============================================================
-- Removes automation_accounts table and links agents/jobs
-- to the existing accounts table (used for bookkeeping).
-- ============================================================

-- Step 1: Clear existing account_id values (they reference automation_accounts)
-- This is necessary because the existing UUIDs won't match accounts table
UPDATE public.automation_agents SET account_id = NULL;
UPDATE public.automation_jobs SET account_id = NULL;
UPDATE public.automation_pairing_requests SET account_id = NULL;

-- Step 2: Drop foreign key constraints that reference automation_accounts
ALTER TABLE public.automation_agents
  DROP CONSTRAINT IF EXISTS automation_agents_account_id_fkey;

ALTER TABLE public.automation_jobs
  DROP CONSTRAINT IF EXISTS automation_jobs_account_id_fkey;

-- Step 3: Drop the automation_accounts table
DROP TABLE IF EXISTS public.automation_accounts CASCADE;

-- Step 4: Add foreign key constraints to reference the real accounts table
ALTER TABLE public.automation_agents
ADD CONSTRAINT automation_agents_account_id_fkey
FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE SET NULL;

ALTER TABLE public.automation_jobs
ADD CONSTRAINT automation_jobs_account_id_fkey
FOREIGN KEY (account_id) REFERENCES public.accounts(id) ON DELETE SET NULL;

-- Step 5: Update rpc_pairing_poll to use accounts table
CREATE OR REPLACE FUNCTION public.rpc_pairing_poll(
  p_install_instance_id TEXT
) RETURNS TABLE (
  status TEXT,
  agent_id UUID,
  install_token TEXT,
  role TEXT,
  label TEXT,
  account_name TEXT,
  rejection_reason TEXT,
  expires_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  v_request public.automation_pairing_requests;
  v_agent public.automation_agents;
  v_account public.accounts;
  v_now TIMESTAMPTZ := NOW();
BEGIN
  -- Find most recent request for this device
  SELECT * INTO v_request
  FROM public.automation_pairing_requests
  WHERE public.automation_pairing_requests.install_instance_id = p_install_instance_id
  ORDER BY created_at DESC
  LIMIT 1;

  IF v_request IS NULL THEN
    RETURN QUERY SELECT
      'not_found'::TEXT, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TIMESTAMPTZ;
    RETURN;
  END IF;

  -- Check if expired (pending request past expiration)
  IF v_request.status = 'pending' AND v_request.expires_at <= v_now THEN
    -- Auto-expire it
    UPDATE public.automation_pairing_requests
    SET status = 'expired', updated_at = v_now
    WHERE id = v_request.id;

    RETURN QUERY SELECT
      'expired'::TEXT, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, v_request.expires_at;
    RETURN;
  END IF;

  -- Handle different statuses
  IF v_request.status = 'pending' THEN
    RETURN QUERY SELECT
      'pending'::TEXT, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, v_request.expires_at;
    RETURN;

  ELSIF v_request.status = 'rejected' THEN
    RETURN QUERY SELECT
      'rejected'::TEXT, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, v_request.rejection_reason, NULL::TIMESTAMPTZ;
    RETURN;

  ELSIF v_request.status = 'expired' THEN
    RETURN QUERY SELECT
      'expired'::TEXT, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, v_request.expires_at;
    RETURN;

  ELSIF v_request.status = 'approved' THEN
    -- Find the agent created for this request
    SELECT * INTO v_agent
    FROM public.automation_agents
    WHERE public.automation_agents.install_instance_id = p_install_instance_id
      AND public.automation_agents.status = 'active'
    ORDER BY created_at DESC
    LIMIT 1;

    IF v_agent IS NULL THEN
      -- Agent not found (shouldn't happen)
      RETURN QUERY SELECT
        'pending'::TEXT, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, v_request.expires_at;
      RETURN;
    END IF;

    -- Get account name from existing accounts table
    SELECT * INTO v_account
    FROM public.accounts
    WHERE id = v_agent.account_id;

    -- Update last_seen_at
    UPDATE public.automation_agents
    SET last_seen_at = v_now
    WHERE id = v_agent.id;

    -- Return agent info (token generated by API layer with token_secret)
    -- Use account_code as fallback if name is null
    RETURN QUERY SELECT
      'approved'::TEXT,
      v_agent.id,
      v_agent.token_secret,  -- API will use this to generate JWT
      v_agent.role,
      v_agent.label,
      COALESCE(v_account.name, v_account.account_code),
      NULL::TEXT,
      NULL::TIMESTAMPTZ;
    RETURN;
  END IF;

  -- Fallback
  RETURN QUERY SELECT
    v_request.status, NULL::UUID, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT, v_request.expires_at;
END;
$$;

-- Lock down execution privileges
REVOKE ALL ON FUNCTION public.rpc_pairing_poll(TEXT) FROM PUBLIC;
REVOKE ALL ON FUNCTION public.rpc_pairing_poll(TEXT) FROM anon, authenticated;
GRANT EXECUTE ON FUNCTION public.rpc_pairing_poll(TEXT) TO service_role;

-- Notify PostgREST to reload schema
NOTIFY pgrst, 'reload schema';
